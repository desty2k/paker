{
    "psutil": {
        "type": "package",
        "extension": "py",
        "code": "# -*- coding: utf-8 -*-\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"psutil is a cross-platform library for retrieving information on\nrunning processes and system utilization (CPU, memory, disks, network,\nsensors) in Python. Supported platforms:\n\n - Linux\n - Windows\n - macOS\n - FreeBSD\n - OpenBSD\n - NetBSD\n - Sun Solaris\n - AIX\n\nWorks with Python versions from 2.6 to 3.4+.\n\"\"\"\n\nfrom __future__ import division\nimport collections\nimport contextlib\nimport datetime\nimport functools\nimport os\nimport signal\nimport subprocess\nimport sys\nimport threading\nimport time\ntry:\n    import pwd\nexcept ImportError:\n    pwd = None\n\nfrom . import _common\nfrom ._common import AccessDenied\nfrom ._common import Error\nfrom ._common import memoize_when_activated\nfrom ._common import NoSuchProcess\nfrom ._common import TimeoutExpired\nfrom ._common import wrap_numbers as _wrap_numbers\nfrom ._common import ZombieProcess\nfrom ._compat import long\nfrom ._compat import PermissionError\nfrom ._compat import ProcessLookupError\nfrom ._compat import PY3 as _PY3\n\nfrom ._common import CONN_CLOSE\nfrom ._common import CONN_CLOSE_WAIT\nfrom ._common import CONN_CLOSING\nfrom ._common import CONN_ESTABLISHED\nfrom ._common import CONN_FIN_WAIT1\nfrom ._common import CONN_FIN_WAIT2\nfrom ._common import CONN_LAST_ACK\nfrom ._common import CONN_LISTEN\nfrom ._common import CONN_NONE\nfrom ._common import CONN_SYN_RECV\nfrom ._common import CONN_SYN_SENT\nfrom ._common import CONN_TIME_WAIT\nfrom ._common import NIC_DUPLEX_FULL\nfrom ._common import NIC_DUPLEX_HALF\nfrom ._common import NIC_DUPLEX_UNKNOWN\nfrom ._common import POWER_TIME_UNKNOWN\nfrom ._common import POWER_TIME_UNLIMITED\nfrom ._common import STATUS_DEAD\nfrom ._common import STATUS_DISK_SLEEP\nfrom ._common import STATUS_IDLE\nfrom ._common import STATUS_LOCKED\nfrom ._common import STATUS_PARKED\nfrom ._common import STATUS_RUNNING\nfrom ._common import STATUS_SLEEPING\nfrom ._common import STATUS_STOPPED\nfrom ._common import STATUS_TRACING_STOP\nfrom ._common import STATUS_WAITING\nfrom ._common import STATUS_WAKING\nfrom ._common import STATUS_ZOMBIE\n\nfrom ._common import AIX\nfrom ._common import BSD\nfrom ._common import FREEBSD  # NOQA\nfrom ._common import LINUX\nfrom ._common import MACOS\nfrom ._common import NETBSD  # NOQA\nfrom ._common import OPENBSD  # NOQA\nfrom ._common import OSX  # deprecated alias\nfrom ._common import POSIX  # NOQA\nfrom ._common import SUNOS\nfrom ._common import WINDOWS\n\nif LINUX:\n    # This is public API and it will be retrieved from _pslinux.py\n    # via sys.modules.\n    PROCFS_PATH = \"/proc\"\n\n    from . import _pslinux as _psplatform\n\n    from ._pslinux import IOPRIO_CLASS_BE  # NOQA\n    from ._pslinux import IOPRIO_CLASS_IDLE  # NOQA\n    from ._pslinux import IOPRIO_CLASS_NONE  # NOQA\n    from ._pslinux import IOPRIO_CLASS_RT  # NOQA\n\nelif WINDOWS:\n    from . import _pswindows as _psplatform\n    from ._psutil_windows import ABOVE_NORMAL_PRIORITY_CLASS  # NOQA\n    from ._psutil_windows import BELOW_NORMAL_PRIORITY_CLASS  # NOQA\n    from ._psutil_windows import HIGH_PRIORITY_CLASS  # NOQA\n    from ._psutil_windows import IDLE_PRIORITY_CLASS  # NOQA\n    from ._psutil_windows import NORMAL_PRIORITY_CLASS  # NOQA\n    from ._psutil_windows import REALTIME_PRIORITY_CLASS  # NOQA\n    from ._pswindows import CONN_DELETE_TCB  # NOQA\n    from ._pswindows import IOPRIO_VERYLOW  # NOQA\n    from ._pswindows import IOPRIO_LOW  # NOQA\n    from ._pswindows import IOPRIO_NORMAL  # NOQA\n    from ._pswindows import IOPRIO_HIGH  # NOQA\n\nelif MACOS:\n    from . import _psosx as _psplatform\n\nelif BSD:\n    from . import _psbsd as _psplatform\n\nelif SUNOS:\n    from . import _pssunos as _psplatform\n    from ._pssunos import CONN_BOUND  # NOQA\n    from ._pssunos import CONN_IDLE  # NOQA\n\n    # This is public writable API which is read from _pslinux.py and\n    # _pssunos.py via sys.modules.\n    PROCFS_PATH = \"/proc\"\n\nelif AIX:\n    from . import _psaix as _psplatform\n\n    # This is public API and it will be retrieved from _pslinux.py\n    # via sys.modules.\n    PROCFS_PATH = \"/proc\"\n\nelse:  # pragma: no cover\n    raise NotImplementedError('platform %s is not supported' % sys.platform)\n\n\n__all__ = [\n    # exceptions\n    \"Error\", \"NoSuchProcess\", \"ZombieProcess\", \"AccessDenied\",\n    \"TimeoutExpired\",\n\n    # constants\n    \"version_info\", \"__version__\",\n\n    \"STATUS_RUNNING\", \"STATUS_IDLE\", \"STATUS_SLEEPING\", \"STATUS_DISK_SLEEP\",\n    \"STATUS_STOPPED\", \"STATUS_TRACING_STOP\", \"STATUS_ZOMBIE\", \"STATUS_DEAD\",\n    \"STATUS_WAKING\", \"STATUS_LOCKED\", \"STATUS_WAITING\", \"STATUS_LOCKED\",\n    \"STATUS_PARKED\",\n\n    \"CONN_ESTABLISHED\", \"CONN_SYN_SENT\", \"CONN_SYN_RECV\", \"CONN_FIN_WAIT1\",\n    \"CONN_FIN_WAIT2\", \"CONN_TIME_WAIT\", \"CONN_CLOSE\", \"CONN_CLOSE_WAIT\",\n    \"CONN_LAST_ACK\", \"CONN_LISTEN\", \"CONN_CLOSING\", \"CONN_NONE\",\n    # \"CONN_IDLE\", \"CONN_BOUND\",\n\n    \"AF_LINK\",\n\n    \"NIC_DUPLEX_FULL\", \"NIC_DUPLEX_HALF\", \"NIC_DUPLEX_UNKNOWN\",\n\n    \"POWER_TIME_UNKNOWN\", \"POWER_TIME_UNLIMITED\",\n\n    \"BSD\", \"FREEBSD\", \"LINUX\", \"NETBSD\", \"OPENBSD\", \"MACOS\", \"OSX\", \"POSIX\",\n    \"SUNOS\", \"WINDOWS\", \"AIX\",\n\n    # \"RLIM_INFINITY\", \"RLIMIT_AS\", \"RLIMIT_CORE\", \"RLIMIT_CPU\", \"RLIMIT_DATA\",\n    # \"RLIMIT_FSIZE\", \"RLIMIT_LOCKS\", \"RLIMIT_MEMLOCK\", \"RLIMIT_NOFILE\",\n    # \"RLIMIT_NPROC\", \"RLIMIT_RSS\", \"RLIMIT_STACK\", \"RLIMIT_MSGQUEUE\",\n    # \"RLIMIT_NICE\", \"RLIMIT_RTPRIO\", \"RLIMIT_RTTIME\", \"RLIMIT_SIGPENDING\",\n\n    # classes\n    \"Process\", \"Popen\",\n\n    # functions\n    \"pid_exists\", \"pids\", \"process_iter\", \"wait_procs\",             # proc\n    \"virtual_memory\", \"swap_memory\",                                # memory\n    \"cpu_times\", \"cpu_percent\", \"cpu_times_percent\", \"cpu_count\",   # cpu\n    \"cpu_stats\",  # \"cpu_freq\", \"getloadavg\"\n    \"net_io_counters\", \"net_connections\", \"net_if_addrs\",           # network\n    \"net_if_stats\",\n    \"disk_io_counters\", \"disk_partitions\", \"disk_usage\",            # disk\n    # \"sensors_temperatures\", \"sensors_battery\", \"sensors_fans\"     # sensors\n    \"users\", \"boot_time\",                                           # others\n]\n\n\n__all__.extend(_psplatform.__extra__all__)\n\n# Linux, FreeBSD\nif hasattr(_psplatform.Process, \"rlimit\"):\n    # Populate global namespace with RLIM* constants.\n    from . import _psutil_posix\n\n    _globals = globals()\n    _name = None\n    for _name in dir(_psutil_posix):\n        if _name.startswith('RLIM') and _name.isupper():\n            _globals[_name] = getattr(_psutil_posix, _name)\n            __all__.append(_name)\n    del _globals, _name\n\nAF_LINK = _psplatform.AF_LINK\n\n__author__ = \"Giampaolo Rodola'\"\n__version__ = \"5.8.0\"\nversion_info = tuple([int(num) for num in __version__.split('.')])\n\n_timer = getattr(time, 'monotonic', time.time)\n_TOTAL_PHYMEM = None\n_LOWEST_PID = None\n_SENTINEL = object()\n\n# Sanity check in case the user messed up with psutil installation\n# or did something weird with sys.path. In this case we might end\n# up importing a python module using a C extension module which\n# was compiled for a different version of psutil.\n# We want to prevent that by failing sooner rather than later.\n# See: https://github.com/giampaolo/psutil/issues/564\nif (int(__version__.replace('.', '')) !=\n        getattr(_psplatform.cext, 'version', None)):\n    msg = \"version conflict: %r C extension module was built for another \" \\\n          \"version of psutil\" % getattr(_psplatform.cext, \"__file__\")\n    if hasattr(_psplatform.cext, 'version'):\n        msg += \" (%s instead of %s)\" % (\n            '.'.join([x for x in str(_psplatform.cext.version)]), __version__)\n    else:\n        msg += \" (different than %s)\" % __version__\n    msg += \"; you may try to 'pip uninstall psutil', manually remove %s\" % (\n        getattr(_psplatform.cext, \"__file__\",\n                \"the existing psutil install directory\"))\n    msg += \" or clean the virtual env somehow, then reinstall\"\n    raise ImportError(msg)\n\n\n# =====================================================================\n# --- Utils\n# =====================================================================\n\n\nif hasattr(_psplatform, 'ppid_map'):\n    # Faster version (Windows and Linux).\n    _ppid_map = _psplatform.ppid_map\nelse:  # pragma: no cover\n    def _ppid_map():\n        \"\"\"Return a {pid: ppid, ...} dict for all running processes in\n        one shot. Used to speed up Process.children().\n        \"\"\"\n        ret = {}\n        for pid in pids():\n            try:\n                ret[pid] = _psplatform.Process(pid).ppid()\n            except (NoSuchProcess, ZombieProcess):\n                pass\n        return ret\n\n\ndef _assert_pid_not_reused(fun):\n    \"\"\"Decorator which raises NoSuchProcess in case a process is no\n    longer running or its PID has been reused.\n    \"\"\"\n    @functools.wraps(fun)\n    def wrapper(self, *args, **kwargs):\n        if not self.is_running():\n            raise NoSuchProcess(self.pid, self._name)\n        return fun(self, *args, **kwargs)\n    return wrapper\n\n\ndef _pprint_secs(secs):\n    \"\"\"Format seconds in a human readable form.\"\"\"\n    now = time.time()\n    secs_ago = int(now - secs)\n    if secs_ago < 60 * 60 * 24:\n        fmt = \"%H:%M:%S\"\n    else:\n        fmt = \"%Y-%m-%d %H:%M:%S\"\n    return datetime.datetime.fromtimestamp(secs).strftime(fmt)\n\n\n# =====================================================================\n# --- Process class\n# =====================================================================\n\n\nclass Process(object):\n    \"\"\"Represents an OS process with the given PID.\n    If PID is omitted current process PID (os.getpid()) is used.\n    Raise NoSuchProcess if PID does not exist.\n\n    Note that most of the methods of this class do not make sure\n    the PID of the process being queried has been reused over time.\n    That means you might end up retrieving an information referring\n    to another process in case the original one this instance\n    refers to is gone in the meantime.\n\n    The only exceptions for which process identity is pre-emptively\n    checked and guaranteed are:\n\n     - parent()\n     - children()\n     - nice() (set)\n     - ionice() (set)\n     - rlimit() (set)\n     - cpu_affinity (set)\n     - suspend()\n     - resume()\n     - send_signal()\n     - terminate()\n     - kill()\n\n    To prevent this problem for all other methods you can:\n     - use is_running() before querying the process\n     - if you're continuously iterating over a set of Process\n       instances use process_iter() which pre-emptively checks\n     process identity for every yielded instance\n    \"\"\"\n\n    def __init__(self, pid=None):\n        self._init(pid)\n\n    def _init(self, pid, _ignore_nsp=False):\n        if pid is None:\n            pid = os.getpid()\n        else:\n            if not _PY3 and not isinstance(pid, (int, long)):\n                raise TypeError('pid must be an integer (got %r)' % pid)\n            if pid < 0:\n                raise ValueError('pid must be a positive integer (got %s)'\n                                 % pid)\n        self._pid = pid\n        self._name = None\n        self._exe = None\n        self._create_time = None\n        self._gone = False\n        self._hash = None\n        self._lock = threading.RLock()\n        # used for caching on Windows only (on POSIX ppid may change)\n        self._ppid = None\n        # platform-specific modules define an _psplatform.Process\n        # implementation class\n        self._proc = _psplatform.Process(pid)\n        self._last_sys_cpu_times = None\n        self._last_proc_cpu_times = None\n        self._exitcode = _SENTINEL\n        # cache creation time for later use in is_running() method\n        try:\n            self.create_time()\n        except AccessDenied:\n            # We should never get here as AFAIK we're able to get\n            # process creation time on all platforms even as a\n            # limited user.\n            pass\n        except ZombieProcess:\n            # Zombies can still be queried by this class (although\n            # not always) and pids() return them so just go on.\n            pass\n        except NoSuchProcess:\n            if not _ignore_nsp:\n                msg = 'no process found with pid %s' % pid\n                raise NoSuchProcess(pid, None, msg)\n            else:\n                self._gone = True\n        # This pair is supposed to indentify a Process instance\n        # univocally over time (the PID alone is not enough as\n        # it might refer to a process whose PID has been reused).\n        # This will be used later in __eq__() and is_running().\n        self._ident = (self.pid, self._create_time)\n\n    def __str__(self):\n        try:\n            info = collections.OrderedDict()\n        except AttributeError:  # pragma: no cover\n            info = {}  # Python 2.6\n        info[\"pid\"] = self.pid\n        if self._name:\n            info['name'] = self._name\n        with self.oneshot():\n            try:\n                info[\"name\"] = self.name()\n                info[\"status\"] = self.status()\n            except ZombieProcess:\n                info[\"status\"] = \"zombie\"\n            except NoSuchProcess:\n                info[\"status\"] = \"terminated\"\n            except AccessDenied:\n                pass\n            if self._exitcode not in (_SENTINEL, None):\n                info[\"exitcode\"] = self._exitcode\n            if self._create_time:\n                info['started'] = _pprint_secs(self._create_time)\n            return \"%s.%s(%s)\" % (\n                self.__class__.__module__,\n                self.__class__.__name__,\n                \", \".join([\"%s=%r\" % (k, v) for k, v in info.items()]))\n\n    __repr__ = __str__\n\n    def __eq__(self, other):\n        # Test for equality with another Process object based\n        # on PID and creation time.\n        if not isinstance(other, Process):\n            return NotImplemented\n        return self._ident == other._ident\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __hash__(self):\n        if self._hash is None:\n            self._hash = hash(self._ident)\n        return self._hash\n\n    @property\n    def pid(self):\n        \"\"\"The process PID.\"\"\"\n        return self._pid\n\n    # --- utility methods\n\n    @contextlib.contextmanager\n    def oneshot(self):\n        \"\"\"Utility context manager which considerably speeds up the\n        retrieval of multiple process information at the same time.\n\n        Internally different process info (e.g. name, ppid, uids,\n        gids, ...) may be fetched by using the same routine, but\n        only one information is returned and the others are discarded.\n        When using this context manager the internal routine is\n        executed once (in the example below on name()) and the\n        other info are cached.\n\n        The cache is cleared when exiting the context manager block.\n        The advice is to use this every time you retrieve more than\n        one information about the process. If you're lucky, you'll\n        get a hell of a speedup.\n\n        >>> import psutil\n        >>> p = psutil.Process()\n        >>> with p.oneshot():\n        ...     p.name()  # collect multiple info\n        ...     p.cpu_times()  # return cached value\n        ...     p.cpu_percent()  # return cached value\n        ...     p.create_time()  # return cached value\n        ...\n        >>>\n        \"\"\"\n        with self._lock:\n            if hasattr(self, \"_cache\"):\n                # NOOP: this covers the use case where the user enters the\n                # context twice:\n                #\n                # >>> with p.oneshot():\n                # ...    with p.oneshot():\n                # ...\n                #\n                # Also, since as_dict() internally uses oneshot()\n                # I expect that the code below will be a pretty common\n                # \"mistake\" that the user will make, so let's guard\n                # against that:\n                #\n                # >>> with p.oneshot():\n                # ...    p.as_dict()\n                # ...\n                yield\n            else:\n                try:\n                    # cached in case cpu_percent() is used\n                    self.cpu_times.cache_activate(self)\n                    # cached in case memory_percent() is used\n                    self.memory_info.cache_activate(self)\n                    # cached in case parent() is used\n                    self.ppid.cache_activate(self)\n                    # cached in case username() is used\n                    if POSIX:\n                        self.uids.cache_activate(self)\n                    # specific implementation cache\n                    self._proc.oneshot_enter()\n                    yield\n                finally:\n                    self.cpu_times.cache_deactivate(self)\n                    self.memory_info.cache_deactivate(self)\n                    self.ppid.cache_deactivate(self)\n                    if POSIX:\n                        self.uids.cache_deactivate(self)\n                    self._proc.oneshot_exit()\n\n    def as_dict(self, attrs=None, ad_value=None):\n        \"\"\"Utility method returning process information as a\n        hashable dictionary.\n        If *attrs* is specified it must be a list of strings\n        reflecting available Process class' attribute names\n        (e.g. ['cpu_times', 'name']) else all public (read\n        only) attributes are assumed.\n        *ad_value* is the value which gets assigned in case\n        AccessDenied or ZombieProcess exception is raised when\n        retrieving that particular process information.\n        \"\"\"\n        valid_names = _as_dict_attrnames\n        if attrs is not None:\n            if not isinstance(attrs, (list, tuple, set, frozenset)):\n                raise TypeError(\"invalid attrs type %s\" % type(attrs))\n            attrs = set(attrs)\n            invalid_names = attrs - valid_names\n            if invalid_names:\n                raise ValueError(\"invalid attr name%s %s\" % (\n                    \"s\" if len(invalid_names) > 1 else \"\",\n                    \", \".join(map(repr, invalid_names))))\n\n        retdict = dict()\n        ls = attrs or valid_names\n        with self.oneshot():\n            for name in ls:\n                try:\n                    if name == 'pid':\n                        ret = self.pid\n                    else:\n                        meth = getattr(self, name)\n                        ret = meth()\n                except (AccessDenied, ZombieProcess):\n                    ret = ad_value\n                except NotImplementedError:\n                    # in case of not implemented functionality (may happen\n                    # on old or exotic systems) we want to crash only if\n                    # the user explicitly asked for that particular attr\n                    if attrs:\n                        raise\n                    continue\n                retdict[name] = ret\n        return retdict\n\n    def parent(self):\n        \"\"\"Return the parent process as a Process object pre-emptively\n        checking whether PID has been reused.\n        If no parent is known return None.\n        \"\"\"\n        lowest_pid = _LOWEST_PID if _LOWEST_PID is not None else pids()[0]\n        if self.pid == lowest_pid:\n            return None\n        ppid = self.ppid()\n        if ppid is not None:\n            ctime = self.create_time()\n            try:\n                parent = Process(ppid)\n                if parent.create_time() <= ctime:\n                    return parent\n                # ...else ppid has been reused by another process\n            except NoSuchProcess:\n                pass\n\n    def parents(self):\n        \"\"\"Return the parents of this process as a list of Process\n        instances. If no parents are known return an empty list.\n        \"\"\"\n        parents = []\n        proc = self.parent()\n        while proc is not None:\n            parents.append(proc)\n            proc = proc.parent()\n        return parents\n\n    def is_running(self):\n        \"\"\"Return whether this process is running.\n        It also checks if PID has been reused by another process in\n        which case return False.\n        \"\"\"\n        if self._gone:\n            return False\n        try:\n            # Checking if PID is alive is not enough as the PID might\n            # have been reused by another process: we also want to\n            # verify process identity.\n            # Process identity / uniqueness over time is guaranteed by\n            # (PID + creation time) and that is verified in __eq__.\n            return self == Process(self.pid)\n        except ZombieProcess:\n            # We should never get here as it's already handled in\n            # Process.__init__; here just for extra safety.\n            return True\n        except NoSuchProcess:\n            self._gone = True\n            return False\n\n    # --- actual API\n\n    @memoize_when_activated\n    def ppid(self):\n        \"\"\"The process parent PID.\n        On Windows the return value is cached after first call.\n        \"\"\"\n        # On POSIX we don't want to cache the ppid as it may unexpectedly\n        # change to 1 (init) in case this process turns into a zombie:\n        # https://github.com/giampaolo/psutil/issues/321\n        # http://stackoverflow.com/questions/356722/\n\n        # XXX should we check creation time here rather than in\n        # Process.parent()?\n        if POSIX:\n            return self._proc.ppid()\n        else:  # pragma: no cover\n            self._ppid = self._ppid or self._proc.ppid()\n            return self._ppid\n\n    def name(self):\n        \"\"\"The process name. The return value is cached after first call.\"\"\"\n        # Process name is only cached on Windows as on POSIX it may\n        # change, see:\n        # https://github.com/giampaolo/psutil/issues/692\n        if WINDOWS and self._name is not None:\n            return self._name\n        name = self._proc.name()\n        if POSIX and len(name) >= 15:\n            # On UNIX the name gets truncated to the first 15 characters.\n            # If it matches the first part of the cmdline we return that\n            # one instead because it's usually more explicative.\n            # Examples are \"gnome-keyring-d\" vs. \"gnome-keyring-daemon\".\n            try:\n                cmdline = self.cmdline()\n            except AccessDenied:\n                pass\n            else:\n                if cmdline:\n                    extended_name = os.path.basename(cmdline[0])\n                    if extended_name.startswith(name):\n                        name = extended_name\n        self._name = name\n        self._proc._name = name\n        return name\n\n    def exe(self):\n        \"\"\"The process executable as an absolute path.\n        May also be an empty string.\n        The return value is cached after first call.\n        \"\"\"\n        def guess_it(fallback):\n            # try to guess exe from cmdline[0] in absence of a native\n            # exe representation\n            cmdline = self.cmdline()\n            if cmdline and hasattr(os, 'access') and hasattr(os, 'X_OK'):\n                exe = cmdline[0]  # the possible exe\n                # Attempt to guess only in case of an absolute path.\n                # It is not safe otherwise as the process might have\n                # changed cwd.\n                if (os.path.isabs(exe) and\n                        os.path.isfile(exe) and\n                        os.access(exe, os.X_OK)):\n                    return exe\n            if isinstance(fallback, AccessDenied):\n                raise fallback\n            return fallback\n\n        if self._exe is None:\n            try:\n                exe = self._proc.exe()\n            except AccessDenied as err:\n                return guess_it(fallback=err)\n            else:\n                if not exe:\n                    # underlying implementation can legitimately return an\n                    # empty string; if that's the case we don't want to\n                    # raise AD while guessing from the cmdline\n                    try:\n                        exe = guess_it(fallback=exe)\n                    except AccessDenied:\n                        pass\n                self._exe = exe\n        return self._exe\n\n    def cmdline(self):\n        \"\"\"The command line this process has been called with.\"\"\"\n        return self._proc.cmdline()\n\n    def status(self):\n        \"\"\"The process current status as a STATUS_* constant.\"\"\"\n        try:\n            return self._proc.status()\n        except ZombieProcess:\n            return STATUS_ZOMBIE\n\n    def username(self):\n        \"\"\"The name of the user that owns the process.\n        On UNIX this is calculated by using *real* process uid.\n        \"\"\"\n        if POSIX:\n            if pwd is None:\n                # might happen if python was installed from sources\n                raise ImportError(\n                    \"requires pwd module shipped with standard python\")\n            real_uid = self.uids().real\n            try:\n                return pwd.getpwuid(real_uid).pw_name\n            except KeyError:\n                # the uid can't be resolved by the system\n                return str(real_uid)\n        else:\n            return self._proc.username()\n\n    def create_time(self):\n        \"\"\"The process creation time as a floating point number\n        expressed in seconds since the epoch.\n        The return value is cached after first call.\n        \"\"\"\n        if self._create_time is None:\n            self._create_time = self._proc.create_time()\n        return self._create_time\n\n    def cwd(self):\n        \"\"\"Process current working directory as an absolute path.\"\"\"\n        return self._proc.cwd()\n\n    def nice(self, value=None):\n        \"\"\"Get or set process niceness (priority).\"\"\"\n        if value is None:\n            return self._proc.nice_get()\n        else:\n            if not self.is_running():\n                raise NoSuchProcess(self.pid, self._name)\n            self._proc.nice_set(value)\n\n    if POSIX:\n\n        @memoize_when_activated\n        def uids(self):\n            \"\"\"Return process UIDs as a (real, effective, saved)\n            namedtuple.\n            \"\"\"\n            return self._proc.uids()\n\n        def gids(self):\n            \"\"\"Return process GIDs as a (real, effective, saved)\n            namedtuple.\n            \"\"\"\n            return self._proc.gids()\n\n        def terminal(self):\n            \"\"\"The terminal associated with this process, if any,\n            else None.\n            \"\"\"\n            return self._proc.terminal()\n\n        def num_fds(self):\n            \"\"\"Return the number of file descriptors opened by this\n            process (POSIX only).\n            \"\"\"\n            return self._proc.num_fds()\n\n    # Linux, BSD, AIX and Windows only\n    if hasattr(_psplatform.Process, \"io_counters\"):\n\n        def io_counters(self):\n            \"\"\"Return process I/O statistics as a\n            (read_count, write_count, read_bytes, write_bytes)\n            namedtuple.\n            Those are the number of read/write calls performed and the\n            amount of bytes read and written by the process.\n            \"\"\"\n            return self._proc.io_counters()\n\n    # Linux and Windows\n    if hasattr(_psplatform.Process, \"ionice_get\"):\n\n        def ionice(self, ioclass=None, value=None):\n            \"\"\"Get or set process I/O niceness (priority).\n\n            On Linux *ioclass* is one of the IOPRIO_CLASS_* constants.\n            *value* is a number which goes from 0 to 7. The higher the\n            value, the lower the I/O priority of the process.\n\n            On Windows only *ioclass* is used and it can be set to 2\n            (normal), 1 (low) or 0 (very low).\n\n            Available on Linux and Windows > Vista only.\n            \"\"\"\n            if ioclass is None:\n                if value is not None:\n                    raise ValueError(\"'ioclass' argument must be specified\")\n                return self._proc.ionice_get()\n            else:\n                return self._proc.ionice_set(ioclass, value)\n\n    # Linux / FreeBSD only\n    if hasattr(_psplatform.Process, \"rlimit\"):\n\n        def rlimit(self, resource, limits=None):\n            \"\"\"Get or set process resource limits as a (soft, hard)\n            tuple.\n\n            *resource* is one of the RLIMIT_* constants.\n            *limits* is supposed to be a (soft, hard) tuple.\n\n            See \"man prlimit\" for further info.\n            Available on Linux and FreeBSD only.\n            \"\"\"\n            return self._proc.rlimit(resource, limits)\n\n    # Windows, Linux and FreeBSD only\n    if hasattr(_psplatform.Process, \"cpu_affinity_get\"):\n\n        def cpu_affinity(self, cpus=None):\n            \"\"\"Get or set process CPU affinity.\n            If specified, *cpus* must be a list of CPUs for which you\n            want to set the affinity (e.g. [0, 1]).\n            If an empty list is passed, all egible CPUs are assumed\n            (and set).\n            (Windows, Linux and BSD only).\n            \"\"\"\n            if cpus is None:\n                return sorted(set(self._proc.cpu_affinity_get()))\n            else:\n                if not cpus:\n                    if hasattr(self._proc, \"_get_eligible_cpus\"):\n                        cpus = self._proc._get_eligible_cpus()\n                    else:\n                        cpus = tuple(range(len(cpu_times(percpu=True))))\n                self._proc.cpu_affinity_set(list(set(cpus)))\n\n    # Linux, FreeBSD, SunOS\n    if hasattr(_psplatform.Process, \"cpu_num\"):\n\n        def cpu_num(self):\n            \"\"\"Return what CPU this process is currently running on.\n            The returned number should be <= psutil.cpu_count()\n            and <= len(psutil.cpu_percent(percpu=True)).\n            It may be used in conjunction with\n            psutil.cpu_percent(percpu=True) to observe the system\n            workload distributed across CPUs.\n            \"\"\"\n            return self._proc.cpu_num()\n\n    # All platforms has it, but maybe not in the future.\n    if hasattr(_psplatform.Process, \"environ\"):\n\n        def environ(self):\n            \"\"\"The environment variables of the process as a dict.  Note: this\n            might not reflect changes made after the process started.  \"\"\"\n            return self._proc.environ()\n\n    if WINDOWS:\n\n        def num_handles(self):\n            \"\"\"Return the number of handles opened by this process\n            (Windows only).\n            \"\"\"\n            return self._proc.num_handles()\n\n    def num_ctx_switches(self):\n        \"\"\"Return the number of voluntary and involuntary context\n        switches performed by this process.\n        \"\"\"\n        return self._proc.num_ctx_switches()\n\n    def num_threads(self):\n        \"\"\"Return the number of threads used by this process.\"\"\"\n        return self._proc.num_threads()\n\n    if hasattr(_psplatform.Process, \"threads\"):\n\n        def threads(self):\n            \"\"\"Return threads opened by process as a list of\n            (id, user_time, system_time) namedtuples representing\n            thread id and thread CPU times (user/system).\n            On OpenBSD this method requires root access.\n            \"\"\"\n            return self._proc.threads()\n\n    @_assert_pid_not_reused\n    def children(self, recursive=False):\n        \"\"\"Return the children of this process as a list of Process\n        instances, pre-emptively checking whether PID has been reused.\n        If *recursive* is True return all the parent descendants.\n\n        Example (A == this process):\n\n         A \u2500\u2510\n            \u2502\n            \u251c\u2500 B (child) \u2500\u2510\n            \u2502             \u2514\u2500 X (grandchild) \u2500\u2510\n            \u2502                                \u2514\u2500 Y (great grandchild)\n            \u251c\u2500 C (child)\n            \u2514\u2500 D (child)\n\n        >>> import psutil\n        >>> p = psutil.Process()\n        >>> p.children()\n        B, C, D\n        >>> p.children(recursive=True)\n        B, X, Y, C, D\n\n        Note that in the example above if process X disappears\n        process Y won't be listed as the reference to process A\n        is lost.\n        \"\"\"\n        ppid_map = _ppid_map()\n        ret = []\n        if not recursive:\n            for pid, ppid in ppid_map.items():\n                if ppid == self.pid:\n                    try:\n                        child = Process(pid)\n                        # if child happens to be older than its parent\n                        # (self) it means child's PID has been reused\n                        if self.create_time() <= child.create_time():\n                            ret.append(child)\n                    except (NoSuchProcess, ZombieProcess):\n                        pass\n        else:\n            # Construct a {pid: [child pids]} dict\n            reverse_ppid_map = collections.defaultdict(list)\n            for pid, ppid in ppid_map.items():\n                reverse_ppid_map[ppid].append(pid)\n            # Recursively traverse that dict, starting from self.pid,\n            # such that we only call Process() on actual children\n            seen = set()\n            stack = [self.pid]\n            while stack:\n                pid = stack.pop()\n                if pid in seen:\n                    # Since pids can be reused while the ppid_map is\n                    # constructed, there may be rare instances where\n                    # there's a cycle in the recorded process \"tree\".\n                    continue\n                seen.add(pid)\n                for child_pid in reverse_ppid_map[pid]:\n                    try:\n                        child = Process(child_pid)\n                        # if child happens to be older than its parent\n                        # (self) it means child's PID has been reused\n                        intime = self.create_time() <= child.create_time()\n                        if intime:\n                            ret.append(child)\n                            stack.append(child_pid)\n                    except (NoSuchProcess, ZombieProcess):\n                        pass\n        return ret\n\n    def cpu_percent(self, interval=None):\n        \"\"\"Return a float representing the current process CPU\n        utilization as a percentage.\n\n        When *interval* is 0.0 or None (default) compares process times\n        to system CPU times elapsed since last call, returning\n        immediately (non-blocking). That means that the first time\n        this is called it will return a meaningful 0.0 value.\n\n        When *interval* is > 0.0 compares process times to system CPU\n        times elapsed before and after the interval (blocking).\n\n        In this case is recommended for accuracy that this function\n        be called with at least 0.1 seconds between calls.\n\n        A value > 100.0 can be returned in case of processes running\n        multiple threads on different CPU cores.\n\n        The returned value is explicitly NOT split evenly between\n        all available logical CPUs. This means that a busy loop process\n        running on a system with 2 logical CPUs will be reported as\n        having 100% CPU utilization instead of 50%.\n\n        Examples:\n\n          >>> import psutil\n          >>> p = psutil.Process(os.getpid())\n          >>> # blocking\n          >>> p.cpu_percent(interval=1)\n          2.0\n          >>> # non-blocking (percentage since last call)\n          >>> p.cpu_percent(interval=None)\n          2.9\n          >>>\n        \"\"\"\n        blocking = interval is not None and interval > 0.0\n        if interval is not None and interval < 0:\n            raise ValueError(\"interval is not positive (got %r)\" % interval)\n        num_cpus = cpu_count() or 1\n\n        def timer():\n            return _timer() * num_cpus\n\n        if blocking:\n            st1 = timer()\n            pt1 = self._proc.cpu_times()\n            time.sleep(interval)\n            st2 = timer()\n            pt2 = self._proc.cpu_times()\n        else:\n            st1 = self._last_sys_cpu_times\n            pt1 = self._last_proc_cpu_times\n            st2 = timer()\n            pt2 = self._proc.cpu_times()\n            if st1 is None or pt1 is None:\n                self._last_sys_cpu_times = st2\n                self._last_proc_cpu_times = pt2\n                return 0.0\n\n        delta_proc = (pt2.user - pt1.user) + (pt2.system - pt1.system)\n        delta_time = st2 - st1\n        # reset values for next call in case of interval == None\n        self._last_sys_cpu_times = st2\n        self._last_proc_cpu_times = pt2\n\n        try:\n            # This is the utilization split evenly between all CPUs.\n            # E.g. a busy loop process on a 2-CPU-cores system at this\n            # point is reported as 50% instead of 100%.\n            overall_cpus_percent = ((delta_proc / delta_time) * 100)\n        except ZeroDivisionError:\n            # interval was too low\n            return 0.0\n        else:\n            # Note 1:\n            # in order to emulate \"top\" we multiply the value for the num\n            # of CPU cores. This way the busy process will be reported as\n            # having 100% (or more) usage.\n            #\n            # Note 2:\n            # taskmgr.exe on Windows differs in that it will show 50%\n            # instead.\n            #\n            # Note 3:\n            # a percentage > 100 is legitimate as it can result from a\n            # process with multiple threads running on different CPU\n            # cores (top does the same), see:\n            # http://stackoverflow.com/questions/1032357\n            # https://github.com/giampaolo/psutil/issues/474\n            single_cpu_percent = overall_cpus_percent * num_cpus\n            return round(single_cpu_percent, 1)\n\n    @memoize_when_activated\n    def cpu_times(self):\n        \"\"\"Return a (user, system, children_user, children_system)\n        namedtuple representing the accumulated process time, in\n        seconds.\n        This is similar to os.times() but per-process.\n        On macOS and Windows children_user and children_system are\n        always set to 0.\n        \"\"\"\n        return self._proc.cpu_times()\n\n    @memoize_when_activated\n    def memory_info(self):\n        \"\"\"Return a namedtuple with variable fields depending on the\n        platform, representing memory information about the process.\n\n        The \"portable\" fields available on all plaforms are `rss` and `vms`.\n\n        All numbers are expressed in bytes.\n        \"\"\"\n        return self._proc.memory_info()\n\n    @_common.deprecated_method(replacement=\"memory_info\")\n    def memory_info_ex(self):\n        return self.memory_info()\n\n    def memory_full_info(self):\n        \"\"\"This method returns the same information as memory_info(),\n        plus, on some platform (Linux, macOS, Windows), also provides\n        additional metrics (USS, PSS and swap).\n        The additional metrics provide a better representation of actual\n        process memory usage.\n\n        Namely USS is the memory which is unique to a process and which\n        would be freed if the process was terminated right now.\n\n        It does so by passing through the whole process address.\n        As such it usually requires higher user privileges than\n        memory_info() and is considerably slower.\n        \"\"\"\n        return self._proc.memory_full_info()\n\n    def memory_percent(self, memtype=\"rss\"):\n        \"\"\"Compare process memory to total physical system memory and\n        calculate process memory utilization as a percentage.\n        *memtype* argument is a string that dictates what type of\n        process memory you want to compare against (defaults to \"rss\").\n        The list of available strings can be obtained like this:\n\n        >>> psutil.Process().memory_info()._fields\n        ('rss', 'vms', 'shared', 'text', 'lib', 'data', 'dirty', 'uss', 'pss')\n        \"\"\"\n        valid_types = list(_psplatform.pfullmem._fields)\n        if memtype not in valid_types:\n            raise ValueError(\"invalid memtype %r; valid types are %r\" % (\n                memtype, tuple(valid_types)))\n        fun = self.memory_info if memtype in _psplatform.pmem._fields else \\\n            self.memory_full_info\n        metrics = fun()\n        value = getattr(metrics, memtype)\n\n        # use cached value if available\n        total_phymem = _TOTAL_PHYMEM or virtual_memory().total\n        if not total_phymem > 0:\n            # we should never get here\n            raise ValueError(\n                \"can't calculate process memory percent because \"\n                \"total physical system memory is not positive (%r)\"\n                % total_phymem)\n        return (value / float(total_phymem)) * 100\n\n    if hasattr(_psplatform.Process, \"memory_maps\"):\n        def memory_maps(self, grouped=True):\n            \"\"\"Return process' mapped memory regions as a list of namedtuples\n            whose fields are variable depending on the platform.\n\n            If *grouped* is True the mapped regions with the same 'path'\n            are grouped together and the different memory fields are summed.\n\n            If *grouped* is False every mapped region is shown as a single\n            entity and the namedtuple will also include the mapped region's\n            address space ('addr') and permission set ('perms').\n            \"\"\"\n            it = self._proc.memory_maps()\n            if grouped:\n                d = {}\n                for tupl in it:\n                    path = tupl[2]\n                    nums = tupl[3:]\n                    try:\n                        d[path] = map(lambda x, y: x + y, d[path], nums)\n                    except KeyError:\n                        d[path] = nums\n                nt = _psplatform.pmmap_grouped\n                return [nt(path, *d[path]) for path in d]  # NOQA\n            else:\n                nt = _psplatform.pmmap_ext\n                return [nt(*x) for x in it]\n\n    def open_files(self):\n        \"\"\"Return files opened by process as a list of\n        (path, fd) namedtuples including the absolute file name\n        and file descriptor number.\n        \"\"\"\n        return self._proc.open_files()\n\n    def connections(self, kind='inet'):\n        \"\"\"Return socket connections opened by process as a list of\n        (fd, family, type, laddr, raddr, status) namedtuples.\n        The *kind* parameter filters for connections that match the\n        following criteria:\n\n        +------------+----------------------------------------------------+\n        | Kind Value | Connections using                                  |\n        +------------+----------------------------------------------------+\n        | inet       | IPv4 and IPv6                                      |\n        | inet4      | IPv4                                               |\n        | inet6      | IPv6                                               |\n        | tcp        | TCP                                                |\n        | tcp4       | TCP over IPv4                                      |\n        | tcp6       | TCP over IPv6                                      |\n        | udp        | UDP                                                |\n        | udp4       | UDP over IPv4                                      |\n        | udp6       | UDP over IPv6                                      |\n        | unix       | UNIX socket (both UDP and TCP protocols)           |\n        | all        | the sum of all the possible families and protocols |\n        +------------+----------------------------------------------------+\n        \"\"\"\n        return self._proc.connections(kind)\n\n    # --- signals\n\n    if POSIX:\n        def _send_signal(self, sig):\n            assert not self.pid < 0, self.pid\n            if self.pid == 0:\n                # see \"man 2 kill\"\n                raise ValueError(\n                    \"preventing sending signal to process with PID 0 as it \"\n                    \"would affect every process in the process group of the \"\n                    \"calling process (os.getpid()) instead of PID 0\")\n            try:\n                os.kill(self.pid, sig)\n            except ProcessLookupError:\n                if OPENBSD and pid_exists(self.pid):\n                    # We do this because os.kill() lies in case of\n                    # zombie processes.\n                    raise ZombieProcess(self.pid, self._name, self._ppid)\n                else:\n                    self._gone = True\n                    raise NoSuchProcess(self.pid, self._name)\n            except PermissionError:\n                raise AccessDenied(self.pid, self._name)\n\n    @_assert_pid_not_reused\n    def send_signal(self, sig):\n        \"\"\"Send a signal *sig* to process pre-emptively checking\n        whether PID has been reused (see signal module constants) .\n        On Windows only SIGTERM is valid and is treated as an alias\n        for kill().\n        \"\"\"\n        if POSIX:\n            self._send_signal(sig)\n        else:  # pragma: no cover\n            self._proc.send_signal(sig)\n\n    @_assert_pid_not_reused\n    def suspend(self):\n        \"\"\"Suspend process execution with SIGSTOP pre-emptively checking\n        whether PID has been reused.\n        On Windows this has the effect ot suspending all process threads.\n        \"\"\"\n        if POSIX:\n            self._send_signal(signal.SIGSTOP)\n        else:  # pragma: no cover\n            self._proc.suspend()\n\n    @_assert_pid_not_reused\n    def resume(self):\n        \"\"\"Resume process execution with SIGCONT pre-emptively checking\n        whether PID has been reused.\n        On Windows this has the effect of resuming all process threads.\n        \"\"\"\n        if POSIX:\n            self._send_signal(signal.SIGCONT)\n        else:  # pragma: no cover\n            self._proc.resume()\n\n    @_assert_pid_not_reused\n    def terminate(self):\n        \"\"\"Terminate the process with SIGTERM pre-emptively checking\n        whether PID has been reused.\n        On Windows this is an alias for kill().\n        \"\"\"\n        if POSIX:\n            self._send_signal(signal.SIGTERM)\n        else:  # pragma: no cover\n            self._proc.kill()\n\n    @_assert_pid_not_reused\n    def kill(self):\n        \"\"\"Kill the current process with SIGKILL pre-emptively checking\n        whether PID has been reused.\n        \"\"\"\n        if POSIX:\n            self._send_signal(signal.SIGKILL)\n        else:  # pragma: no cover\n            self._proc.kill()\n\n    def wait(self, timeout=None):\n        \"\"\"Wait for process to terminate and, if process is a children\n        of os.getpid(), also return its exit code, else None.\n        On Windows there's no such limitation (exit code is always\n        returned).\n\n        If the process is already terminated immediately return None\n        instead of raising NoSuchProcess.\n\n        If *timeout* (in seconds) is specified and process is still\n        alive raise TimeoutExpired.\n\n        To wait for multiple Process(es) use psutil.wait_procs().\n        \"\"\"\n        if timeout is not None and not timeout >= 0:\n            raise ValueError(\"timeout must be a positive integer\")\n        if self._exitcode is not _SENTINEL:\n            return self._exitcode\n        self._exitcode = self._proc.wait(timeout)\n        return self._exitcode\n\n\n# The valid attr names which can be processed by Process.as_dict().\n_as_dict_attrnames = set(\n    [x for x in dir(Process) if not x.startswith('_') and x not in\n     ['send_signal', 'suspend', 'resume', 'terminate', 'kill', 'wait',\n      'is_running', 'as_dict', 'parent', 'parents', 'children', 'rlimit',\n      'memory_info_ex', 'oneshot']])\n\n\n# =====================================================================\n# --- Popen class\n# =====================================================================\n\n\nclass Popen(Process):\n    \"\"\"Same as subprocess.Popen, but in addition it provides all\n    psutil.Process methods in a single class.\n    For the following methods which are common to both classes, psutil\n    implementation takes precedence:\n\n    * send_signal()\n    * terminate()\n    * kill()\n\n    This is done in order to avoid killing another process in case its\n    PID has been reused, fixing BPO-6973.\n\n      >>> import psutil\n      >>> from subprocess import PIPE\n      >>> p = psutil.Popen([\"python\", \"-c\", \"print 'hi'\"], stdout=PIPE)\n      >>> p.name()\n      'python'\n      >>> p.uids()\n      user(real=1000, effective=1000, saved=1000)\n      >>> p.username()\n      'giampaolo'\n      >>> p.communicate()\n      ('hi\\n', None)\n      >>> p.terminate()\n      >>> p.wait(timeout=2)\n      0\n      >>>\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        # Explicitly avoid to raise NoSuchProcess in case the process\n        # spawned by subprocess.Popen terminates too quickly, see:\n        # https://github.com/giampaolo/psutil/issues/193\n        self.__subproc = subprocess.Popen(*args, **kwargs)\n        self._init(self.__subproc.pid, _ignore_nsp=True)\n\n    def __dir__(self):\n        return sorted(set(dir(Popen) + dir(subprocess.Popen)))\n\n    def __enter__(self):\n        if hasattr(self.__subproc, '__enter__'):\n            self.__subproc.__enter__()\n        return self\n\n    def __exit__(self, *args, **kwargs):\n        if hasattr(self.__subproc, '__exit__'):\n            return self.__subproc.__exit__(*args, **kwargs)\n        else:\n            if self.stdout:\n                self.stdout.close()\n            if self.stderr:\n                self.stderr.close()\n            try:\n                # Flushing a BufferedWriter may raise an error.\n                if self.stdin:\n                    self.stdin.close()\n            finally:\n                # Wait for the process to terminate, to avoid zombies.\n                self.wait()\n\n    def __getattribute__(self, name):\n        try:\n            return object.__getattribute__(self, name)\n        except AttributeError:\n            try:\n                return object.__getattribute__(self.__subproc, name)\n            except AttributeError:\n                raise AttributeError(\"%s instance has no attribute '%s'\"\n                                     % (self.__class__.__name__, name))\n\n    def wait(self, timeout=None):\n        if self.__subproc.returncode is not None:\n            return self.__subproc.returncode\n        ret = super(Popen, self).wait(timeout)\n        self.__subproc.returncode = ret\n        return ret\n\n\n# =====================================================================\n# --- system processes related functions\n# =====================================================================\n\n\ndef pids():\n    \"\"\"Return a list of current running PIDs.\"\"\"\n    global _LOWEST_PID\n    ret = sorted(_psplatform.pids())\n    _LOWEST_PID = ret[0]\n    return ret\n\n\ndef pid_exists(pid):\n    \"\"\"Return True if given PID exists in the current process list.\n    This is faster than doing \"pid in psutil.pids()\" and\n    should be preferred.\n    \"\"\"\n    if pid < 0:\n        return False\n    elif pid == 0 and POSIX:\n        # On POSIX we use os.kill() to determine PID existence.\n        # According to \"man 2 kill\" PID 0 has a special meaning\n        # though: it refers to <<every process in the process\n        # group of the calling process>> and that is not we want\n        # to do here.\n        return pid in pids()\n    else:\n        return _psplatform.pid_exists(pid)\n\n\n_pmap = {}\n_lock = threading.Lock()\n\n\ndef process_iter(attrs=None, ad_value=None):\n    \"\"\"Return a generator yielding a Process instance for all\n    running processes.\n\n    Every new Process instance is only created once and then cached\n    into an internal table which is updated every time this is used.\n\n    Cached Process instances are checked for identity so that you're\n    safe in case a PID has been reused by another process, in which\n    case the cached instance is updated.\n\n    The sorting order in which processes are yielded is based on\n    their PIDs.\n\n    *attrs* and *ad_value* have the same meaning as in\n    Process.as_dict(). If *attrs* is specified as_dict() is called\n    and the resulting dict is stored as a 'info' attribute attached\n    to returned Process instance.\n    If *attrs* is an empty list it will retrieve all process info\n    (slow).\n    \"\"\"\n    def add(pid):\n        proc = Process(pid)\n        if attrs is not None:\n            proc.info = proc.as_dict(attrs=attrs, ad_value=ad_value)\n        with _lock:\n            _pmap[proc.pid] = proc\n        return proc\n\n    def remove(pid):\n        with _lock:\n            _pmap.pop(pid, None)\n\n    a = set(pids())\n    b = set(_pmap.keys())\n    new_pids = a - b\n    gone_pids = b - a\n    for pid in gone_pids:\n        remove(pid)\n\n    with _lock:\n        ls = sorted(list(_pmap.items()) +\n                    list(dict.fromkeys(new_pids).items()))\n\n    for pid, proc in ls:\n        try:\n            if proc is None:  # new process\n                yield add(pid)\n            else:\n                # use is_running() to check whether PID has been reused by\n                # another process in which case yield a new Process instance\n                if proc.is_running():\n                    if attrs is not None:\n                        proc.info = proc.as_dict(\n                            attrs=attrs, ad_value=ad_value)\n                    yield proc\n                else:\n                    yield add(pid)\n        except NoSuchProcess:\n            remove(pid)\n        except AccessDenied:\n            # Process creation time can't be determined hence there's\n            # no way to tell whether the pid of the cached process\n            # has been reused. Just return the cached version.\n            if proc is None and pid in _pmap:\n                try:\n                    yield _pmap[pid]\n                except KeyError:\n                    # If we get here it is likely that 2 threads were\n                    # using process_iter().\n                    pass\n            else:\n                raise\n\n\ndef wait_procs(procs, timeout=None, callback=None):\n    \"\"\"Convenience function which waits for a list of processes to\n    terminate.\n\n    Return a (gone, alive) tuple indicating which processes\n    are gone and which ones are still alive.\n\n    The gone ones will have a new *returncode* attribute indicating\n    process exit status (may be None).\n\n    *callback* is a function which gets called every time a process\n    terminates (a Process instance is passed as callback argument).\n\n    Function will return as soon as all processes terminate or when\n    *timeout* occurs.\n    Differently from Process.wait() it will not raise TimeoutExpired if\n    *timeout* occurs.\n\n    Typical use case is:\n\n     - send SIGTERM to a list of processes\n     - give them some time to terminate\n     - send SIGKILL to those ones which are still alive\n\n    Example:\n\n    >>> def on_terminate(proc):\n    ...     print(\"process {} terminated\".format(proc))\n    ...\n    >>> for p in procs:\n    ...    p.terminate()\n    ...\n    >>> gone, alive = wait_procs(procs, timeout=3, callback=on_terminate)\n    >>> for p in alive:\n    ...     p.kill()\n    \"\"\"\n    def check_gone(proc, timeout):\n        try:\n            returncode = proc.wait(timeout=timeout)\n        except TimeoutExpired:\n            pass\n        else:\n            if returncode is not None or not proc.is_running():\n                # Set new Process instance attribute.\n                proc.returncode = returncode\n                gone.add(proc)\n                if callback is not None:\n                    callback(proc)\n\n    if timeout is not None and not timeout >= 0:\n        msg = \"timeout must be a positive integer, got %s\" % timeout\n        raise ValueError(msg)\n    gone = set()\n    alive = set(procs)\n    if callback is not None and not callable(callback):\n        raise TypeError(\"callback %r is not a callable\" % callable)\n    if timeout is not None:\n        deadline = _timer() + timeout\n\n    while alive:\n        if timeout is not None and timeout <= 0:\n            break\n        for proc in alive:\n            # Make sure that every complete iteration (all processes)\n            # will last max 1 sec.\n            # We do this because we don't want to wait too long on a\n            # single process: in case it terminates too late other\n            # processes may disappear in the meantime and their PID\n            # reused.\n            max_timeout = 1.0 / len(alive)\n            if timeout is not None:\n                timeout = min((deadline - _timer()), max_timeout)\n                if timeout <= 0:\n                    break\n                check_gone(proc, timeout)\n            else:\n                check_gone(proc, max_timeout)\n        alive = alive - gone\n\n    if alive:\n        # Last attempt over processes survived so far.\n        # timeout == 0 won't make this function wait any further.\n        for proc in alive:\n            check_gone(proc, 0)\n        alive = alive - gone\n\n    return (list(gone), list(alive))\n\n\n# =====================================================================\n# --- CPU related functions\n# =====================================================================\n\n\ndef cpu_count(logical=True):\n    \"\"\"Return the number of logical CPUs in the system (same as\n    os.cpu_count() in Python 3.4).\n\n    If *logical* is False return the number of physical cores only\n    (e.g. hyper thread CPUs are excluded).\n\n    Return None if undetermined.\n\n    The return value is cached after first call.\n    If desired cache can be cleared like this:\n\n    >>> psutil.cpu_count.cache_clear()\n    \"\"\"\n    if logical:\n        ret = _psplatform.cpu_count_logical()\n    else:\n        ret = _psplatform.cpu_count_physical()\n    if ret is not None and ret < 1:\n        ret = None\n    return ret\n\n\ndef cpu_times(percpu=False):\n    \"\"\"Return system-wide CPU times as a namedtuple.\n    Every CPU time represents the seconds the CPU has spent in the\n    given mode. The namedtuple's fields availability varies depending on the\n    platform:\n\n     - user\n     - system\n     - idle\n     - nice (UNIX)\n     - iowait (Linux)\n     - irq (Linux, FreeBSD)\n     - softirq (Linux)\n     - steal (Linux >= 2.6.11)\n     - guest (Linux >= 2.6.24)\n     - guest_nice (Linux >= 3.2.0)\n\n    When *percpu* is True return a list of namedtuples for each CPU.\n    First element of the list refers to first CPU, second element\n    to second CPU and so on.\n    The order of the list is consistent across calls.\n    \"\"\"\n    if not percpu:\n        return _psplatform.cpu_times()\n    else:\n        return _psplatform.per_cpu_times()\n\n\ntry:\n    _last_cpu_times = cpu_times()\nexcept Exception:\n    # Don't want to crash at import time.\n    _last_cpu_times = None\n\ntry:\n    _last_per_cpu_times = cpu_times(percpu=True)\nexcept Exception:\n    # Don't want to crash at import time.\n    _last_per_cpu_times = None\n\n\ndef _cpu_tot_time(times):\n    \"\"\"Given a cpu_time() ntuple calculates the total CPU time\n    (including idle time).\n    \"\"\"\n    tot = sum(times)\n    if LINUX:\n        # On Linux guest times are already accounted in \"user\" or\n        # \"nice\" times, so we subtract them from total.\n        # Htop does the same. References:\n        # https://github.com/giampaolo/psutil/pull/940\n        # http://unix.stackexchange.com/questions/178045\n        # https://github.com/torvalds/linux/blob/\n        #     447976ef4fd09b1be88b316d1a81553f1aa7cd07/kernel/sched/\n        #     cputime.c#L158\n        tot -= getattr(times, \"guest\", 0)  # Linux 2.6.24+\n        tot -= getattr(times, \"guest_nice\", 0)  # Linux 3.2.0+\n    return tot\n\n\ndef _cpu_busy_time(times):\n    \"\"\"Given a cpu_time() ntuple calculates the busy CPU time.\n    We do so by subtracting all idle CPU times.\n    \"\"\"\n    busy = _cpu_tot_time(times)\n    busy -= times.idle\n    # Linux: \"iowait\" is time during which the CPU does not do anything\n    # (waits for IO to complete). On Linux IO wait is *not* accounted\n    # in \"idle\" time so we subtract it. Htop does the same.\n    # References:\n    # https://github.com/torvalds/linux/blob/\n    #     447976ef4fd09b1be88b316d1a81553f1aa7cd07/kernel/sched/cputime.c#L244\n    busy -= getattr(times, \"iowait\", 0)\n    return busy\n\n\ndef _cpu_times_deltas(t1, t2):\n    assert t1._fields == t2._fields, (t1, t2)\n    field_deltas = []\n    for field in _psplatform.scputimes._fields:\n        field_delta = getattr(t2, field) - getattr(t1, field)\n        # CPU times are always supposed to increase over time\n        # or at least remain the same and that's because time\n        # cannot go backwards.\n        # Surprisingly sometimes this might not be the case (at\n        # least on Windows and Linux), see:\n        # https://github.com/giampaolo/psutil/issues/392\n        # https://github.com/giampaolo/psutil/issues/645\n        # https://github.com/giampaolo/psutil/issues/1210\n        # Trim negative deltas to zero to ignore decreasing fields.\n        # top does the same. Reference:\n        # https://gitlab.com/procps-ng/procps/blob/v3.3.12/top/top.c#L5063\n        field_delta = max(0, field_delta)\n        field_deltas.append(field_delta)\n    return _psplatform.scputimes(*field_deltas)\n\n\ndef cpu_percent(interval=None, percpu=False):\n    \"\"\"Return a float representing the current system-wide CPU\n    utilization as a percentage.\n\n    When *interval* is > 0.0 compares system CPU times elapsed before\n    and after the interval (blocking).\n\n    When *interval* is 0.0 or None compares system CPU times elapsed\n    since last call or module import, returning immediately (non\n    blocking). That means the first time this is called it will\n    return a meaningless 0.0 value which you should ignore.\n    In this case is recommended for accuracy that this function be\n    called with at least 0.1 seconds between calls.\n\n    When *percpu* is True returns a list of floats representing the\n    utilization as a percentage for each CPU.\n    First element of the list refers to first CPU, second element\n    to second CPU and so on.\n    The order of the list is consistent across calls.\n\n    Examples:\n\n      >>> # blocking, system-wide\n      >>> psutil.cpu_percent(interval=1)\n      2.0\n      >>>\n      >>> # blocking, per-cpu\n      >>> psutil.cpu_percent(interval=1, percpu=True)\n      [2.0, 1.0]\n      >>>\n      >>> # non-blocking (percentage since last call)\n      >>> psutil.cpu_percent(interval=None)\n      2.9\n      >>>\n    \"\"\"\n    global _last_cpu_times\n    global _last_per_cpu_times\n    blocking = interval is not None and interval > 0.0\n    if interval is not None and interval < 0:\n        raise ValueError(\"interval is not positive (got %r)\" % interval)\n\n    def calculate(t1, t2):\n        times_delta = _cpu_times_deltas(t1, t2)\n\n        all_delta = _cpu_tot_time(times_delta)\n        busy_delta = _cpu_busy_time(times_delta)\n\n        try:\n            busy_perc = (busy_delta / all_delta) * 100\n        except ZeroDivisionError:\n            return 0.0\n        else:\n            return round(busy_perc, 1)\n\n    # system-wide usage\n    if not percpu:\n        if blocking:\n            t1 = cpu_times()\n            time.sleep(interval)\n        else:\n            t1 = _last_cpu_times\n            if t1 is None:\n                # Something bad happened at import time. We'll\n                # get a meaningful result on the next call. See:\n                # https://github.com/giampaolo/psutil/pull/715\n                t1 = cpu_times()\n        _last_cpu_times = cpu_times()\n        return calculate(t1, _last_cpu_times)\n    # per-cpu usage\n    else:\n        ret = []\n        if blocking:\n            tot1 = cpu_times(percpu=True)\n            time.sleep(interval)\n        else:\n            tot1 = _last_per_cpu_times\n            if tot1 is None:\n                # Something bad happened at import time. We'll\n                # get a meaningful result on the next call. See:\n                # https://github.com/giampaolo/psutil/pull/715\n                tot1 = cpu_times(percpu=True)\n        _last_per_cpu_times = cpu_times(percpu=True)\n        for t1, t2 in zip(tot1, _last_per_cpu_times):\n            ret.append(calculate(t1, t2))\n        return ret\n\n\n# Use separate global vars for cpu_times_percent() so that it's\n# independent from cpu_percent() and they can both be used within\n# the same program.\n_last_cpu_times_2 = _last_cpu_times\n_last_per_cpu_times_2 = _last_per_cpu_times\n\n\ndef cpu_times_percent(interval=None, percpu=False):\n    \"\"\"Same as cpu_percent() but provides utilization percentages\n    for each specific CPU time as is returned by cpu_times().\n    For instance, on Linux we'll get:\n\n      >>> cpu_times_percent()\n      cpupercent(user=4.8, nice=0.0, system=4.8, idle=90.5, iowait=0.0,\n                 irq=0.0, softirq=0.0, steal=0.0, guest=0.0, guest_nice=0.0)\n      >>>\n\n    *interval* and *percpu* arguments have the same meaning as in\n    cpu_percent().\n    \"\"\"\n    global _last_cpu_times_2\n    global _last_per_cpu_times_2\n    blocking = interval is not None and interval > 0.0\n    if interval is not None and interval < 0:\n        raise ValueError(\"interval is not positive (got %r)\" % interval)\n\n    def calculate(t1, t2):\n        nums = []\n        times_delta = _cpu_times_deltas(t1, t2)\n        all_delta = _cpu_tot_time(times_delta)\n        # \"scale\" is the value to multiply each delta with to get percentages.\n        # We use \"max\" to avoid division by zero (if all_delta is 0, then all\n        # fields are 0 so percentages will be 0 too. all_delta cannot be a\n        # fraction because cpu times are integers)\n        scale = 100.0 / max(1, all_delta)\n        for field_delta in times_delta:\n            field_perc = field_delta * scale\n            field_perc = round(field_perc, 1)\n            # make sure we don't return negative values or values over 100%\n            field_perc = min(max(0.0, field_perc), 100.0)\n            nums.append(field_perc)\n        return _psplatform.scputimes(*nums)\n\n    # system-wide usage\n    if not percpu:\n        if blocking:\n            t1 = cpu_times()\n            time.sleep(interval)\n        else:\n            t1 = _last_cpu_times_2\n            if t1 is None:\n                # Something bad happened at import time. We'll\n                # get a meaningful result on the next call. See:\n                # https://github.com/giampaolo/psutil/pull/715\n                t1 = cpu_times()\n        _last_cpu_times_2 = cpu_times()\n        return calculate(t1, _last_cpu_times_2)\n    # per-cpu usage\n    else:\n        ret = []\n        if blocking:\n            tot1 = cpu_times(percpu=True)\n            time.sleep(interval)\n        else:\n            tot1 = _last_per_cpu_times_2\n            if tot1 is None:\n                # Something bad happened at import time. We'll\n                # get a meaningful result on the next call. See:\n                # https://github.com/giampaolo/psutil/pull/715\n                tot1 = cpu_times(percpu=True)\n        _last_per_cpu_times_2 = cpu_times(percpu=True)\n        for t1, t2 in zip(tot1, _last_per_cpu_times_2):\n            ret.append(calculate(t1, t2))\n        return ret\n\n\ndef cpu_stats():\n    \"\"\"Return CPU statistics.\"\"\"\n    return _psplatform.cpu_stats()\n\n\nif hasattr(_psplatform, \"cpu_freq\"):\n\n    def cpu_freq(percpu=False):\n        \"\"\"Return CPU frequency as a nameduple including current,\n        min and max frequency expressed in Mhz.\n\n        If *percpu* is True and the system supports per-cpu frequency\n        retrieval (Linux only) a list of frequencies is returned for\n        each CPU. If not a list with one element is returned.\n        \"\"\"\n        ret = _psplatform.cpu_freq()\n        if percpu:\n            return ret\n        else:\n            num_cpus = float(len(ret))\n            if num_cpus == 0:\n                return None\n            elif num_cpus == 1:\n                return ret[0]\n            else:\n                currs, mins, maxs = 0.0, 0.0, 0.0\n                set_none = False\n                for cpu in ret:\n                    currs += cpu.current\n                    # On Linux if /proc/cpuinfo is used min/max are set\n                    # to None.\n                    if LINUX and cpu.min is None:\n                        set_none = True\n                        continue\n                    mins += cpu.min\n                    maxs += cpu.max\n\n                current = currs / num_cpus\n\n                if set_none:\n                    min_ = max_ = None\n                else:\n                    min_ = mins / num_cpus\n                    max_ = maxs / num_cpus\n\n                return _common.scpufreq(current, min_, max_)\n\n    __all__.append(\"cpu_freq\")\n\n\nif hasattr(os, \"getloadavg\") or hasattr(_psplatform, \"getloadavg\"):\n    # Perform this hasattr check once on import time to either use the\n    # platform based code or proxy straight from the os module.\n    if hasattr(os, \"getloadavg\"):\n        getloadavg = os.getloadavg\n    else:\n        getloadavg = _psplatform.getloadavg\n\n    __all__.append(\"getloadavg\")\n\n\n# =====================================================================\n# --- system memory related functions\n# =====================================================================\n\n\ndef virtual_memory():\n    \"\"\"Return statistics about system memory usage as a namedtuple\n    including the following fields, expressed in bytes:\n\n     - total:\n       total physical memory available.\n\n     - available:\n       the memory that can be given instantly to processes without the\n       system going into swap.\n       This is calculated by summing different memory values depending\n       on the platform and it is supposed to be used to monitor actual\n       memory usage in a cross platform fashion.\n\n     - percent:\n       the percentage usage calculated as (total - available) / total * 100\n\n     - used:\n        memory used, calculated differently depending on the platform and\n        designed for informational purposes only:\n        macOS: active + wired\n        BSD: active + wired + cached\n        Linux: total - free\n\n     - free:\n       memory not being used at all (zeroed) that is readily available;\n       note that this doesn't reflect the actual memory available\n       (use 'available' instead)\n\n    Platform-specific fields:\n\n     - active (UNIX):\n       memory currently in use or very recently used, and so it is in RAM.\n\n     - inactive (UNIX):\n       memory that is marked as not used.\n\n     - buffers (BSD, Linux):\n       cache for things like file system metadata.\n\n     - cached (BSD, macOS):\n       cache for various things.\n\n     - wired (macOS, BSD):\n       memory that is marked to always stay in RAM. It is never moved to disk.\n\n     - shared (BSD):\n       memory that may be simultaneously accessed by multiple processes.\n\n    The sum of 'used' and 'available' does not necessarily equal total.\n    On Windows 'available' and 'free' are the same.\n    \"\"\"\n    global _TOTAL_PHYMEM\n    ret = _psplatform.virtual_memory()\n    # cached for later use in Process.memory_percent()\n    _TOTAL_PHYMEM = ret.total\n    return ret\n\n\ndef swap_memory():\n    \"\"\"Return system swap memory statistics as a namedtuple including\n    the following fields:\n\n     - total:   total swap memory in bytes\n     - used:    used swap memory in bytes\n     - free:    free swap memory in bytes\n     - percent: the percentage usage\n     - sin:     no. of bytes the system has swapped in from disk (cumulative)\n     - sout:    no. of bytes the system has swapped out from disk (cumulative)\n\n    'sin' and 'sout' on Windows are meaningless and always set to 0.\n    \"\"\"\n    return _psplatform.swap_memory()\n\n\n# =====================================================================\n# --- disks/paritions related functions\n# =====================================================================\n\n\ndef disk_usage(path):\n    \"\"\"Return disk usage statistics about the given *path* as a\n    namedtuple including total, used and free space expressed in bytes\n    plus the percentage usage.\n    \"\"\"\n    return _psplatform.disk_usage(path)\n\n\ndef disk_partitions(all=False):\n    \"\"\"Return mounted partitions as a list of\n    (device, mountpoint, fstype, opts) namedtuple.\n    'opts' field is a raw string separated by commas indicating mount\n    options which may vary depending on the platform.\n\n    If *all* parameter is False return physical devices only and ignore\n    all others.\n    \"\"\"\n    def pathconf(path, name):\n        try:\n            return os.pathconf(path, name)\n        except (OSError, AttributeError):\n            pass\n\n    ret = _psplatform.disk_partitions(all)\n    if POSIX:\n        new = []\n        for item in ret:\n            nt = item._replace(\n                maxfile=pathconf(item.mountpoint, 'PC_NAME_MAX'),\n                maxpath=pathconf(item.mountpoint, 'PC_PATH_MAX'))\n            new.append(nt)\n        return new\n    else:\n        return ret\n\n\ndef disk_io_counters(perdisk=False, nowrap=True):\n    \"\"\"Return system disk I/O statistics as a namedtuple including\n    the following fields:\n\n     - read_count:  number of reads\n     - write_count: number of writes\n     - read_bytes:  number of bytes read\n     - write_bytes: number of bytes written\n     - read_time:   time spent reading from disk (in ms)\n     - write_time:  time spent writing to disk (in ms)\n\n    Platform specific:\n\n     - busy_time: (Linux, FreeBSD) time spent doing actual I/Os (in ms)\n     - read_merged_count (Linux): number of merged reads\n     - write_merged_count (Linux): number of merged writes\n\n    If *perdisk* is True return the same information for every\n    physical disk installed on the system as a dictionary\n    with partition names as the keys and the namedtuple\n    described above as the values.\n\n    If *nowrap* is True it detects and adjust the numbers which overflow\n    and wrap (restart from 0) and add \"old value\" to \"new value\" so that\n    the returned numbers will always be increasing or remain the same,\n    but never decrease.\n    \"disk_io_counters.cache_clear()\" can be used to invalidate the\n    cache.\n\n    On recent Windows versions 'diskperf -y' command may need to be\n    executed first otherwise this function won't find any disk.\n    \"\"\"\n    kwargs = dict(perdisk=perdisk) if LINUX else {}\n    rawdict = _psplatform.disk_io_counters(**kwargs)\n    if not rawdict:\n        return {} if perdisk else None\n    if nowrap:\n        rawdict = _wrap_numbers(rawdict, 'psutil.disk_io_counters')\n    nt = getattr(_psplatform, \"sdiskio\", _common.sdiskio)\n    if perdisk:\n        for disk, fields in rawdict.items():\n            rawdict[disk] = nt(*fields)\n        return rawdict\n    else:\n        return nt(*[sum(x) for x in zip(*rawdict.values())])\n\n\ndisk_io_counters.cache_clear = functools.partial(\n    _wrap_numbers.cache_clear, 'psutil.disk_io_counters')\ndisk_io_counters.cache_clear.__doc__ = \"Clears nowrap argument cache\"\n\n\n# =====================================================================\n# --- network related functions\n# =====================================================================\n\n\ndef net_io_counters(pernic=False, nowrap=True):\n    \"\"\"Return network I/O statistics as a namedtuple including\n    the following fields:\n\n     - bytes_sent:   number of bytes sent\n     - bytes_recv:   number of bytes received\n     - packets_sent: number of packets sent\n     - packets_recv: number of packets received\n     - errin:        total number of errors while receiving\n     - errout:       total number of errors while sending\n     - dropin:       total number of incoming packets which were dropped\n     - dropout:      total number of outgoing packets which were dropped\n                     (always 0 on macOS and BSD)\n\n    If *pernic* is True return the same information for every\n    network interface installed on the system as a dictionary\n    with network interface names as the keys and the namedtuple\n    described above as the values.\n\n    If *nowrap* is True it detects and adjust the numbers which overflow\n    and wrap (restart from 0) and add \"old value\" to \"new value\" so that\n    the returned numbers will always be increasing or remain the same,\n    but never decrease.\n    \"disk_io_counters.cache_clear()\" can be used to invalidate the\n    cache.\n    \"\"\"\n    rawdict = _psplatform.net_io_counters()\n    if not rawdict:\n        return {} if pernic else None\n    if nowrap:\n        rawdict = _wrap_numbers(rawdict, 'psutil.net_io_counters')\n    if pernic:\n        for nic, fields in rawdict.items():\n            rawdict[nic] = _common.snetio(*fields)\n        return rawdict\n    else:\n        return _common.snetio(*[sum(x) for x in zip(*rawdict.values())])\n\n\nnet_io_counters.cache_clear = functools.partial(\n    _wrap_numbers.cache_clear, 'psutil.net_io_counters')\nnet_io_counters.cache_clear.__doc__ = \"Clears nowrap argument cache\"\n\n\ndef net_connections(kind='inet'):\n    \"\"\"Return system-wide socket connections as a list of\n    (fd, family, type, laddr, raddr, status, pid) namedtuples.\n    In case of limited privileges 'fd' and 'pid' may be set to -1\n    and None respectively.\n    The *kind* parameter filters for connections that fit the\n    following criteria:\n\n    +------------+----------------------------------------------------+\n    | Kind Value | Connections using                                  |\n    +------------+----------------------------------------------------+\n    | inet       | IPv4 and IPv6                                      |\n    | inet4      | IPv4                                               |\n    | inet6      | IPv6                                               |\n    | tcp        | TCP                                                |\n    | tcp4       | TCP over IPv4                                      |\n    | tcp6       | TCP over IPv6                                      |\n    | udp        | UDP                                                |\n    | udp4       | UDP over IPv4                                      |\n    | udp6       | UDP over IPv6                                      |\n    | unix       | UNIX socket (both UDP and TCP protocols)           |\n    | all        | the sum of all the possible families and protocols |\n    +------------+----------------------------------------------------+\n\n    On macOS this function requires root privileges.\n    \"\"\"\n    return _psplatform.net_connections(kind)\n\n\ndef net_if_addrs():\n    \"\"\"Return the addresses associated to each NIC (network interface\n    card) installed on the system as a dictionary whose keys are the\n    NIC names and value is a list of namedtuples for each address\n    assigned to the NIC. Each namedtuple includes 5 fields:\n\n     - family: can be either socket.AF_INET, socket.AF_INET6 or\n               psutil.AF_LINK, which refers to a MAC address.\n     - address: is the primary address and it is always set.\n     - netmask: and 'broadcast' and 'ptp' may be None.\n     - ptp: stands for \"point to point\" and references the\n            destination address on a point to point interface\n            (typically a VPN).\n     - broadcast: and *ptp* are mutually exclusive.\n\n    Note: you can have more than one address of the same family\n    associated with each interface.\n    \"\"\"\n    has_enums = sys.version_info >= (3, 4)\n    if has_enums:\n        import socket\n    rawlist = _psplatform.net_if_addrs()\n    rawlist.sort(key=lambda x: x[1])  # sort by family\n    ret = collections.defaultdict(list)\n    for name, fam, addr, mask, broadcast, ptp in rawlist:\n        if has_enums:\n            try:\n                fam = socket.AddressFamily(fam)\n            except ValueError:\n                if WINDOWS and fam == -1:\n                    fam = _psplatform.AF_LINK\n                elif (hasattr(_psplatform, \"AF_LINK\") and\n                        _psplatform.AF_LINK == fam):\n                    # Linux defines AF_LINK as an alias for AF_PACKET.\n                    # We re-set the family here so that repr(family)\n                    # will show AF_LINK rather than AF_PACKET\n                    fam = _psplatform.AF_LINK\n        if fam == _psplatform.AF_LINK:\n            # The underlying C function may return an incomplete MAC\n            # address in which case we fill it with null bytes, see:\n            # https://github.com/giampaolo/psutil/issues/786\n            separator = \":\" if POSIX else \"-\"\n            while addr.count(separator) < 5:\n                addr += \"%s00\" % separator\n        ret[name].append(_common.snicaddr(fam, addr, mask, broadcast, ptp))\n    return dict(ret)\n\n\ndef net_if_stats():\n    \"\"\"Return information about each NIC (network interface card)\n    installed on the system as a dictionary whose keys are the\n    NIC names and value is a namedtuple with the following fields:\n\n     - isup: whether the interface is up (bool)\n     - duplex: can be either NIC_DUPLEX_FULL, NIC_DUPLEX_HALF or\n               NIC_DUPLEX_UNKNOWN\n     - speed: the NIC speed expressed in mega bits (MB); if it can't\n              be determined (e.g. 'localhost') it will be set to 0.\n     - mtu: the maximum transmission unit expressed in bytes.\n    \"\"\"\n    return _psplatform.net_if_stats()\n\n\n# =====================================================================\n# --- sensors\n# =====================================================================\n\n\n# Linux, macOS\nif hasattr(_psplatform, \"sensors_temperatures\"):\n\n    def sensors_temperatures(fahrenheit=False):\n        \"\"\"Return hardware temperatures. Each entry is a namedtuple\n        representing a certain hardware sensor (it may be a CPU, an\n        hard disk or something else, depending on the OS and its\n        configuration).\n        All temperatures are expressed in celsius unless *fahrenheit*\n        is set to True.\n        \"\"\"\n        def convert(n):\n            if n is not None:\n                return (float(n) * 9 / 5) + 32 if fahrenheit else n\n\n        ret = collections.defaultdict(list)\n        rawdict = _psplatform.sensors_temperatures()\n\n        for name, values in rawdict.items():\n            while values:\n                label, current, high, critical = values.pop(0)\n                current = convert(current)\n                high = convert(high)\n                critical = convert(critical)\n\n                if high and not critical:\n                    critical = high\n                elif critical and not high:\n                    high = critical\n\n                ret[name].append(\n                    _common.shwtemp(label, current, high, critical))\n\n        return dict(ret)\n\n    __all__.append(\"sensors_temperatures\")\n\n\n# Linux\nif hasattr(_psplatform, \"sensors_fans\"):\n\n    def sensors_fans():\n        \"\"\"Return fans speed. Each entry is a namedtuple\n        representing a certain hardware sensor.\n        All speed are expressed in RPM (rounds per minute).\n        \"\"\"\n        return _psplatform.sensors_fans()\n\n    __all__.append(\"sensors_fans\")\n\n\n# Linux, Windows, FreeBSD, macOS\nif hasattr(_psplatform, \"sensors_battery\"):\n\n    def sensors_battery():\n        \"\"\"Return battery information. If no battery is installed\n        returns None.\n\n         - percent: battery power left as a percentage.\n         - secsleft: a rough approximation of how many seconds are left\n                     before the battery runs out of power. May be\n                     POWER_TIME_UNLIMITED or POWER_TIME_UNLIMITED.\n         - power_plugged: True if the AC power cable is connected.\n        \"\"\"\n        return _psplatform.sensors_battery()\n\n    __all__.append(\"sensors_battery\")\n\n\n# =====================================================================\n# --- other system related functions\n# =====================================================================\n\n\ndef boot_time():\n    \"\"\"Return the system boot time expressed in seconds since the epoch.\"\"\"\n    # Note: we are not caching this because it is subject to\n    # system clock updates.\n    return _psplatform.boot_time()\n\n\ndef users():\n    \"\"\"Return users currently connected on the system as a list of\n    namedtuples including the following fields.\n\n     - user: the name of the user\n     - terminal: the tty or pseudo-tty associated with the user, if any.\n     - host: the host name associated with the entry, if any.\n     - started: the creation time as a floating point number expressed in\n       seconds since the epoch.\n    \"\"\"\n    return _psplatform.users()\n\n\n# =====================================================================\n# --- Windows services\n# =====================================================================\n\n\nif WINDOWS:\n\n    def win_service_iter():\n        \"\"\"Return a generator yielding a WindowsService instance for all\n        Windows services installed.\n        \"\"\"\n        return _psplatform.win_service_iter()\n\n    def win_service_get(name):\n        \"\"\"Get a Windows service by *name*.\n        Raise NoSuchProcess if no service with such name exists.\n        \"\"\"\n        return _psplatform.win_service_get(name)\n\n\n# =====================================================================\n\n\ndef test():  # pragma: no cover\n    from ._common import bytes2human\n    from ._compat import get_terminal_size\n\n    today_day = datetime.date.today()\n    templ = \"%-10s %5s %5s %7s %7s %5s %6s %6s %6s  %s\"\n    attrs = ['pid', 'memory_percent', 'name', 'cmdline', 'cpu_times',\n             'create_time', 'memory_info', 'status', 'nice', 'username']\n    print(templ % (\"USER\", \"PID\", \"%MEM\", \"VSZ\", \"RSS\", \"NICE\",  # NOQA\n                   \"STATUS\", \"START\", \"TIME\", \"CMDLINE\"))\n    for p in process_iter(attrs, ad_value=None):\n        if p.info['create_time']:\n            ctime = datetime.datetime.fromtimestamp(p.info['create_time'])\n            if ctime.date() == today_day:\n                ctime = ctime.strftime(\"%H:%M\")\n            else:\n                ctime = ctime.strftime(\"%b%d\")\n        else:\n            ctime = ''\n        if p.info['cpu_times']:\n            cputime = time.strftime(\"%M:%S\",\n                                    time.localtime(sum(p.info['cpu_times'])))\n        else:\n            cputime = ''\n\n        user = p.info['username'] or ''\n        if not user and POSIX:\n            try:\n                user = p.uids()[0]\n            except Error:\n                pass\n        if user and WINDOWS and '\\\\' in user:\n            user = user.split('\\\\')[1]\n        user = user[:9]\n        vms = bytes2human(p.info['memory_info'].vms) if \\\n            p.info['memory_info'] is not None else ''\n        rss = bytes2human(p.info['memory_info'].rss) if \\\n            p.info['memory_info'] is not None else ''\n        memp = round(p.info['memory_percent'], 1) if \\\n            p.info['memory_percent'] is not None else ''\n        nice = int(p.info['nice']) if p.info['nice'] else ''\n        if p.info['cmdline']:\n            cmdline = ' '.join(p.info['cmdline'])\n        else:\n            cmdline = p.info['name']\n        status = p.info['status'][:5] if p.info['status'] else ''\n\n        line = templ % (\n            user[:10],\n            p.info['pid'],\n            memp,\n            vms,\n            rss,\n            nice,\n            status,\n            ctime,\n            cputime,\n            cmdline)\n        print(line[:get_terminal_size()[0]])  # NOQA\n\n\ndel memoize_when_activated, division\nif sys.version_info[0] < 3:\n    del num, x\n\nif __name__ == \"__main__\":\n    test()\n",
        "modules": {
            "_common": {
                "type": "module",
                "extension": "py",
                "code": "# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Common objects shared by __init__.py and _ps*.py modules.\"\"\"\n\n# Note: this module is imported by setup.py so it should not import\n# psutil or third-party modules.\n\nfrom __future__ import division, print_function\n\nimport contextlib\nimport errno\nimport functools\nimport os\nimport socket\nimport stat\nimport sys\nimport threading\nimport warnings\nfrom collections import defaultdict\nfrom collections import namedtuple\nfrom socket import AF_INET\nfrom socket import SOCK_DGRAM\nfrom socket import SOCK_STREAM\n\ntry:\n    from socket import AF_INET6\nexcept ImportError:\n    AF_INET6 = None\ntry:\n    from socket import AF_UNIX\nexcept ImportError:\n    AF_UNIX = None\n\nif sys.version_info >= (3, 4):\n    import enum\nelse:\n    enum = None\n\n\n# can't take it from _common.py as this script is imported by setup.py\nPY3 = sys.version_info[0] == 3\n\n__all__ = [\n    # OS constants\n    'FREEBSD', 'BSD', 'LINUX', 'NETBSD', 'OPENBSD', 'MACOS', 'OSX', 'POSIX',\n    'SUNOS', 'WINDOWS',\n    # connection constants\n    'CONN_CLOSE', 'CONN_CLOSE_WAIT', 'CONN_CLOSING', 'CONN_ESTABLISHED',\n    'CONN_FIN_WAIT1', 'CONN_FIN_WAIT2', 'CONN_LAST_ACK', 'CONN_LISTEN',\n    'CONN_NONE', 'CONN_SYN_RECV', 'CONN_SYN_SENT', 'CONN_TIME_WAIT',\n    # net constants\n    'NIC_DUPLEX_FULL', 'NIC_DUPLEX_HALF', 'NIC_DUPLEX_UNKNOWN',\n    # process status constants\n    'STATUS_DEAD', 'STATUS_DISK_SLEEP', 'STATUS_IDLE', 'STATUS_LOCKED',\n    'STATUS_RUNNING', 'STATUS_SLEEPING', 'STATUS_STOPPED', 'STATUS_SUSPENDED',\n    'STATUS_TRACING_STOP', 'STATUS_WAITING', 'STATUS_WAKE_KILL',\n    'STATUS_WAKING', 'STATUS_ZOMBIE', 'STATUS_PARKED',\n    # other constants\n    'ENCODING', 'ENCODING_ERRS', 'AF_INET6',\n    # named tuples\n    'pconn', 'pcputimes', 'pctxsw', 'pgids', 'pio', 'pionice', 'popenfile',\n    'pthread', 'puids', 'sconn', 'scpustats', 'sdiskio', 'sdiskpart',\n    'sdiskusage', 'snetio', 'snicaddr', 'snicstats', 'sswap', 'suser',\n    # utility functions\n    'conn_tmap', 'deprecated_method', 'isfile_strict', 'memoize',\n    'parse_environ_block', 'path_exists_strict', 'usage_percent',\n    'supports_ipv6', 'sockfam_to_enum', 'socktype_to_enum', \"wrap_numbers\",\n    'bytes2human', 'conn_to_ntuple', 'debug',\n    # shell utils\n    'hilite', 'term_supports_colors', 'print_color',\n]\n\n\n# ===================================================================\n# --- OS constants\n# ===================================================================\n\n\nPOSIX = os.name == \"posix\"\nWINDOWS = os.name == \"nt\"\nLINUX = sys.platform.startswith(\"linux\")\nMACOS = sys.platform.startswith(\"darwin\")\nOSX = MACOS  # deprecated alias\nFREEBSD = sys.platform.startswith(\"freebsd\")\nOPENBSD = sys.platform.startswith(\"openbsd\")\nNETBSD = sys.platform.startswith(\"netbsd\")\nBSD = FREEBSD or OPENBSD or NETBSD\nSUNOS = sys.platform.startswith((\"sunos\", \"solaris\"))\nAIX = sys.platform.startswith(\"aix\")\n\n\n# ===================================================================\n# --- API constants\n# ===================================================================\n\n\n# Process.status()\nSTATUS_RUNNING = \"running\"\nSTATUS_SLEEPING = \"sleeping\"\nSTATUS_DISK_SLEEP = \"disk-sleep\"\nSTATUS_STOPPED = \"stopped\"\nSTATUS_TRACING_STOP = \"tracing-stop\"\nSTATUS_ZOMBIE = \"zombie\"\nSTATUS_DEAD = \"dead\"\nSTATUS_WAKE_KILL = \"wake-kill\"\nSTATUS_WAKING = \"waking\"\nSTATUS_IDLE = \"idle\"  # Linux, macOS, FreeBSD\nSTATUS_LOCKED = \"locked\"  # FreeBSD\nSTATUS_WAITING = \"waiting\"  # FreeBSD\nSTATUS_SUSPENDED = \"suspended\"  # NetBSD\nSTATUS_PARKED = \"parked\"  # Linux\n\n# Process.connections() and psutil.net_connections()\nCONN_ESTABLISHED = \"ESTABLISHED\"\nCONN_SYN_SENT = \"SYN_SENT\"\nCONN_SYN_RECV = \"SYN_RECV\"\nCONN_FIN_WAIT1 = \"FIN_WAIT1\"\nCONN_FIN_WAIT2 = \"FIN_WAIT2\"\nCONN_TIME_WAIT = \"TIME_WAIT\"\nCONN_CLOSE = \"CLOSE\"\nCONN_CLOSE_WAIT = \"CLOSE_WAIT\"\nCONN_LAST_ACK = \"LAST_ACK\"\nCONN_LISTEN = \"LISTEN\"\nCONN_CLOSING = \"CLOSING\"\nCONN_NONE = \"NONE\"\n\n# net_if_stats()\nif enum is None:\n    NIC_DUPLEX_FULL = 2\n    NIC_DUPLEX_HALF = 1\n    NIC_DUPLEX_UNKNOWN = 0\nelse:\n    class NicDuplex(enum.IntEnum):\n        NIC_DUPLEX_FULL = 2\n        NIC_DUPLEX_HALF = 1\n        NIC_DUPLEX_UNKNOWN = 0\n\n    globals().update(NicDuplex.__members__)\n\n# sensors_battery()\nif enum is None:\n    POWER_TIME_UNKNOWN = -1\n    POWER_TIME_UNLIMITED = -2\nelse:\n    class BatteryTime(enum.IntEnum):\n        POWER_TIME_UNKNOWN = -1\n        POWER_TIME_UNLIMITED = -2\n\n    globals().update(BatteryTime.__members__)\n\n# --- others\n\nENCODING = sys.getfilesystemencoding()\nif not PY3:\n    ENCODING_ERRS = \"replace\"\nelse:\n    try:\n        ENCODING_ERRS = sys.getfilesystemencodeerrors()  # py 3.6\n    except AttributeError:\n        ENCODING_ERRS = \"surrogateescape\" if POSIX else \"replace\"\n\n\n# ===================================================================\n# --- namedtuples\n# ===================================================================\n\n# --- for system functions\n\n# psutil.swap_memory()\nsswap = namedtuple('sswap', ['total', 'used', 'free', 'percent', 'sin',\n                             'sout'])\n# psutil.disk_usage()\nsdiskusage = namedtuple('sdiskusage', ['total', 'used', 'free', 'percent'])\n# psutil.disk_io_counters()\nsdiskio = namedtuple('sdiskio', ['read_count', 'write_count',\n                                 'read_bytes', 'write_bytes',\n                                 'read_time', 'write_time'])\n# psutil.disk_partitions()\nsdiskpart = namedtuple('sdiskpart', ['device', 'mountpoint', 'fstype', 'opts',\n                                     'maxfile', 'maxpath'])\n# psutil.net_io_counters()\nsnetio = namedtuple('snetio', ['bytes_sent', 'bytes_recv',\n                               'packets_sent', 'packets_recv',\n                               'errin', 'errout',\n                               'dropin', 'dropout'])\n# psutil.users()\nsuser = namedtuple('suser', ['name', 'terminal', 'host', 'started', 'pid'])\n# psutil.net_connections()\nsconn = namedtuple('sconn', ['fd', 'family', 'type', 'laddr', 'raddr',\n                             'status', 'pid'])\n# psutil.net_if_addrs()\nsnicaddr = namedtuple('snicaddr',\n                      ['family', 'address', 'netmask', 'broadcast', 'ptp'])\n# psutil.net_if_stats()\nsnicstats = namedtuple('snicstats', ['isup', 'duplex', 'speed', 'mtu'])\n# psutil.cpu_stats()\nscpustats = namedtuple(\n    'scpustats', ['ctx_switches', 'interrupts', 'soft_interrupts', 'syscalls'])\n# psutil.cpu_freq()\nscpufreq = namedtuple('scpufreq', ['current', 'min', 'max'])\n# psutil.sensors_temperatures()\nshwtemp = namedtuple(\n    'shwtemp', ['label', 'current', 'high', 'critical'])\n# psutil.sensors_battery()\nsbattery = namedtuple('sbattery', ['percent', 'secsleft', 'power_plugged'])\n# psutil.sensors_fans()\nsfan = namedtuple('sfan', ['label', 'current'])\n\n# --- for Process methods\n\n# psutil.Process.cpu_times()\npcputimes = namedtuple('pcputimes',\n                       ['user', 'system', 'children_user', 'children_system'])\n# psutil.Process.open_files()\npopenfile = namedtuple('popenfile', ['path', 'fd'])\n# psutil.Process.threads()\npthread = namedtuple('pthread', ['id', 'user_time', 'system_time'])\n# psutil.Process.uids()\npuids = namedtuple('puids', ['real', 'effective', 'saved'])\n# psutil.Process.gids()\npgids = namedtuple('pgids', ['real', 'effective', 'saved'])\n# psutil.Process.io_counters()\npio = namedtuple('pio', ['read_count', 'write_count',\n                         'read_bytes', 'write_bytes'])\n# psutil.Process.ionice()\npionice = namedtuple('pionice', ['ioclass', 'value'])\n# psutil.Process.ctx_switches()\npctxsw = namedtuple('pctxsw', ['voluntary', 'involuntary'])\n# psutil.Process.connections()\npconn = namedtuple('pconn', ['fd', 'family', 'type', 'laddr', 'raddr',\n                             'status'])\n\n# psutil.connections() and psutil.Process.connections()\naddr = namedtuple('addr', ['ip', 'port'])\n\n\n# ===================================================================\n# --- Process.connections() 'kind' parameter mapping\n# ===================================================================\n\n\nconn_tmap = {\n    \"all\": ([AF_INET, AF_INET6, AF_UNIX], [SOCK_STREAM, SOCK_DGRAM]),\n    \"tcp\": ([AF_INET, AF_INET6], [SOCK_STREAM]),\n    \"tcp4\": ([AF_INET], [SOCK_STREAM]),\n    \"udp\": ([AF_INET, AF_INET6], [SOCK_DGRAM]),\n    \"udp4\": ([AF_INET], [SOCK_DGRAM]),\n    \"inet\": ([AF_INET, AF_INET6], [SOCK_STREAM, SOCK_DGRAM]),\n    \"inet4\": ([AF_INET], [SOCK_STREAM, SOCK_DGRAM]),\n    \"inet6\": ([AF_INET6], [SOCK_STREAM, SOCK_DGRAM]),\n}\n\nif AF_INET6 is not None:\n    conn_tmap.update({\n        \"tcp6\": ([AF_INET6], [SOCK_STREAM]),\n        \"udp6\": ([AF_INET6], [SOCK_DGRAM]),\n    })\n\nif AF_UNIX is not None:\n    conn_tmap.update({\n        \"unix\": ([AF_UNIX], [SOCK_STREAM, SOCK_DGRAM]),\n    })\n\n\n# =====================================================================\n# --- Exceptions\n# =====================================================================\n\n\nclass Error(Exception):\n    \"\"\"Base exception class. All other psutil exceptions inherit\n    from this one.\n    \"\"\"\n    __module__ = 'psutil'\n\n    def __init__(self, msg=\"\"):\n        Exception.__init__(self, msg)\n        self.msg = msg\n\n    def __repr__(self):\n        ret = \"psutil.%s %s\" % (self.__class__.__name__, self.msg)\n        return ret.strip()\n\n    __str__ = __repr__\n\n\nclass NoSuchProcess(Error):\n    \"\"\"Exception raised when a process with a certain PID doesn't\n    or no longer exists.\n    \"\"\"\n    __module__ = 'psutil'\n\n    def __init__(self, pid, name=None, msg=None):\n        Error.__init__(self, msg)\n        self.pid = pid\n        self.name = name\n        self.msg = msg\n        if msg is None:\n            if name:\n                details = \"(pid=%s, name=%s)\" % (self.pid, repr(self.name))\n            else:\n                details = \"(pid=%s)\" % self.pid\n            self.msg = \"process no longer exists \" + details\n\n\nclass ZombieProcess(NoSuchProcess):\n    \"\"\"Exception raised when querying a zombie process. This is\n    raised on macOS, BSD and Solaris only, and not always: depending\n    on the query the OS may be able to succeed anyway.\n    On Linux all zombie processes are querable (hence this is never\n    raised). Windows doesn't have zombie processes.\n    \"\"\"\n    __module__ = 'psutil'\n\n    def __init__(self, pid, name=None, ppid=None, msg=None):\n        NoSuchProcess.__init__(self, msg)\n        self.pid = pid\n        self.ppid = ppid\n        self.name = name\n        self.msg = msg\n        if msg is None:\n            args = [\"pid=%s\" % pid]\n            if name:\n                args.append(\"name=%s\" % repr(self.name))\n            if ppid:\n                args.append(\"ppid=%s\" % self.ppid)\n            details = \"(%s)\" % \", \".join(args)\n            self.msg = \"process still exists but it's a zombie \" + details\n\n\nclass AccessDenied(Error):\n    \"\"\"Exception raised when permission to perform an action is denied.\"\"\"\n    __module__ = 'psutil'\n\n    def __init__(self, pid=None, name=None, msg=None):\n        Error.__init__(self, msg)\n        self.pid = pid\n        self.name = name\n        self.msg = msg\n        if msg is None:\n            if (pid is not None) and (name is not None):\n                self.msg = \"(pid=%s, name=%s)\" % (pid, repr(name))\n            elif (pid is not None):\n                self.msg = \"(pid=%s)\" % self.pid\n            else:\n                self.msg = \"\"\n\n\nclass TimeoutExpired(Error):\n    \"\"\"Raised on Process.wait(timeout) if timeout expires and process\n    is still alive.\n    \"\"\"\n    __module__ = 'psutil'\n\n    def __init__(self, seconds, pid=None, name=None):\n        Error.__init__(self, \"timeout after %s seconds\" % seconds)\n        self.seconds = seconds\n        self.pid = pid\n        self.name = name\n        if (pid is not None) and (name is not None):\n            self.msg += \" (pid=%s, name=%s)\" % (pid, repr(name))\n        elif (pid is not None):\n            self.msg += \" (pid=%s)\" % self.pid\n\n\n# ===================================================================\n# --- utils\n# ===================================================================\n\n\ndef usage_percent(used, total, round_=None):\n    \"\"\"Calculate percentage usage of 'used' against 'total'.\"\"\"\n    try:\n        ret = (float(used) / total) * 100\n    except ZeroDivisionError:\n        return 0.0\n    else:\n        if round_ is not None:\n            ret = round(ret, round_)\n        return ret\n\n\ndef memoize(fun):\n    \"\"\"A simple memoize decorator for functions supporting (hashable)\n    positional arguments.\n    It also provides a cache_clear() function for clearing the cache:\n\n    >>> @memoize\n    ... def foo()\n    ...     return 1\n        ...\n    >>> foo()\n    1\n    >>> foo.cache_clear()\n    >>>\n    \"\"\"\n    @functools.wraps(fun)\n    def wrapper(*args, **kwargs):\n        key = (args, frozenset(sorted(kwargs.items())))\n        try:\n            return cache[key]\n        except KeyError:\n            ret = cache[key] = fun(*args, **kwargs)\n            return ret\n\n    def cache_clear():\n        \"\"\"Clear cache.\"\"\"\n        cache.clear()\n\n    cache = {}\n    wrapper.cache_clear = cache_clear\n    return wrapper\n\n\ndef memoize_when_activated(fun):\n    \"\"\"A memoize decorator which is disabled by default. It can be\n    activated and deactivated on request.\n    For efficiency reasons it can be used only against class methods\n    accepting no arguments.\n\n    >>> class Foo:\n    ...     @memoize\n    ...     def foo()\n    ...         print(1)\n    ...\n    >>> f = Foo()\n    >>> # deactivated (default)\n    >>> foo()\n    1\n    >>> foo()\n    1\n    >>>\n    >>> # activated\n    >>> foo.cache_activate(self)\n    >>> foo()\n    1\n    >>> foo()\n    >>> foo()\n    >>>\n    \"\"\"\n    @functools.wraps(fun)\n    def wrapper(self):\n        try:\n            # case 1: we previously entered oneshot() ctx\n            ret = self._cache[fun]\n        except AttributeError:\n            # case 2: we never entered oneshot() ctx\n            return fun(self)\n        except KeyError:\n            # case 3: we entered oneshot() ctx but there's no cache\n            # for this entry yet\n            ret = self._cache[fun] = fun(self)\n        return ret\n\n    def cache_activate(proc):\n        \"\"\"Activate cache. Expects a Process instance. Cache will be\n        stored as a \"_cache\" instance attribute.\"\"\"\n        proc._cache = {}\n\n    def cache_deactivate(proc):\n        \"\"\"Deactivate and clear cache.\"\"\"\n        try:\n            del proc._cache\n        except AttributeError:\n            pass\n\n    wrapper.cache_activate = cache_activate\n    wrapper.cache_deactivate = cache_deactivate\n    return wrapper\n\n\ndef isfile_strict(path):\n    \"\"\"Same as os.path.isfile() but does not swallow EACCES / EPERM\n    exceptions, see:\n    http://mail.python.org/pipermail/python-dev/2012-June/120787.html\n    \"\"\"\n    try:\n        st = os.stat(path)\n    except OSError as err:\n        if err.errno in (errno.EPERM, errno.EACCES):\n            raise\n        return False\n    else:\n        return stat.S_ISREG(st.st_mode)\n\n\ndef path_exists_strict(path):\n    \"\"\"Same as os.path.exists() but does not swallow EACCES / EPERM\n    exceptions, see:\n    http://mail.python.org/pipermail/python-dev/2012-June/120787.html\n    \"\"\"\n    try:\n        os.stat(path)\n    except OSError as err:\n        if err.errno in (errno.EPERM, errno.EACCES):\n            raise\n        return False\n    else:\n        return True\n\n\n@memoize\ndef supports_ipv6():\n    \"\"\"Return True if IPv6 is supported on this platform.\"\"\"\n    if not socket.has_ipv6 or AF_INET6 is None:\n        return False\n    try:\n        sock = socket.socket(AF_INET6, socket.SOCK_STREAM)\n        with contextlib.closing(sock):\n            sock.bind((\"::1\", 0))\n        return True\n    except socket.error:\n        return False\n\n\ndef parse_environ_block(data):\n    \"\"\"Parse a C environ block of environment variables into a dictionary.\"\"\"\n    # The block is usually raw data from the target process.  It might contain\n    # trailing garbage and lines that do not look like assignments.\n    ret = {}\n    pos = 0\n\n    # localize global variable to speed up access.\n    WINDOWS_ = WINDOWS\n    while True:\n        next_pos = data.find(\"\\0\", pos)\n        # nul byte at the beginning or double nul byte means finish\n        if next_pos <= pos:\n            break\n        # there might not be an equals sign\n        equal_pos = data.find(\"=\", pos, next_pos)\n        if equal_pos > pos:\n            key = data[pos:equal_pos]\n            value = data[equal_pos + 1:next_pos]\n            # Windows expects environment variables to be uppercase only\n            if WINDOWS_:\n                key = key.upper()\n            ret[key] = value\n        pos = next_pos + 1\n\n    return ret\n\n\ndef sockfam_to_enum(num):\n    \"\"\"Convert a numeric socket family value to an IntEnum member.\n    If it's not a known member, return the numeric value itself.\n    \"\"\"\n    if enum is None:\n        return num\n    else:  # pragma: no cover\n        try:\n            return socket.AddressFamily(num)\n        except ValueError:\n            return num\n\n\ndef socktype_to_enum(num):\n    \"\"\"Convert a numeric socket type value to an IntEnum member.\n    If it's not a known member, return the numeric value itself.\n    \"\"\"\n    if enum is None:\n        return num\n    else:  # pragma: no cover\n        try:\n            return socket.SocketKind(num)\n        except ValueError:\n            return num\n\n\ndef conn_to_ntuple(fd, fam, type_, laddr, raddr, status, status_map, pid=None):\n    \"\"\"Convert a raw connection tuple to a proper ntuple.\"\"\"\n    if fam in (socket.AF_INET, AF_INET6):\n        if laddr:\n            laddr = addr(*laddr)\n        if raddr:\n            raddr = addr(*raddr)\n    if type_ == socket.SOCK_STREAM and fam in (AF_INET, AF_INET6):\n        status = status_map.get(status, CONN_NONE)\n    else:\n        status = CONN_NONE  # ignore whatever C returned to us\n    fam = sockfam_to_enum(fam)\n    type_ = socktype_to_enum(type_)\n    if pid is None:\n        return pconn(fd, fam, type_, laddr, raddr, status)\n    else:\n        return sconn(fd, fam, type_, laddr, raddr, status, pid)\n\n\ndef deprecated_method(replacement):\n    \"\"\"A decorator which can be used to mark a method as deprecated\n    'replcement' is the method name which will be called instead.\n    \"\"\"\n    def outer(fun):\n        msg = \"%s() is deprecated and will be removed; use %s() instead\" % (\n            fun.__name__, replacement)\n        if fun.__doc__ is None:\n            fun.__doc__ = msg\n\n        @functools.wraps(fun)\n        def inner(self, *args, **kwargs):\n            warnings.warn(msg, category=DeprecationWarning, stacklevel=2)\n            return getattr(self, replacement)(*args, **kwargs)\n        return inner\n    return outer\n\n\nclass _WrapNumbers:\n    \"\"\"Watches numbers so that they don't overflow and wrap\n    (reset to zero).\n    \"\"\"\n\n    def __init__(self):\n        self.lock = threading.Lock()\n        self.cache = {}\n        self.reminders = {}\n        self.reminder_keys = {}\n\n    def _add_dict(self, input_dict, name):\n        assert name not in self.cache\n        assert name not in self.reminders\n        assert name not in self.reminder_keys\n        self.cache[name] = input_dict\n        self.reminders[name] = defaultdict(int)\n        self.reminder_keys[name] = defaultdict(set)\n\n    def _remove_dead_reminders(self, input_dict, name):\n        \"\"\"In case the number of keys changed between calls (e.g. a\n        disk disappears) this removes the entry from self.reminders.\n        \"\"\"\n        old_dict = self.cache[name]\n        gone_keys = set(old_dict.keys()) - set(input_dict.keys())\n        for gone_key in gone_keys:\n            for remkey in self.reminder_keys[name][gone_key]:\n                del self.reminders[name][remkey]\n            del self.reminder_keys[name][gone_key]\n\n    def run(self, input_dict, name):\n        \"\"\"Cache dict and sum numbers which overflow and wrap.\n        Return an updated copy of `input_dict`\n        \"\"\"\n        if name not in self.cache:\n            # This was the first call.\n            self._add_dict(input_dict, name)\n            return input_dict\n\n        self._remove_dead_reminders(input_dict, name)\n\n        old_dict = self.cache[name]\n        new_dict = {}\n        for key in input_dict.keys():\n            input_tuple = input_dict[key]\n            try:\n                old_tuple = old_dict[key]\n            except KeyError:\n                # The input dict has a new key (e.g. a new disk or NIC)\n                # which didn't exist in the previous call.\n                new_dict[key] = input_tuple\n                continue\n\n            bits = []\n            for i in range(len(input_tuple)):\n                input_value = input_tuple[i]\n                old_value = old_tuple[i]\n                remkey = (key, i)\n                if input_value < old_value:\n                    # it wrapped!\n                    self.reminders[name][remkey] += old_value\n                    self.reminder_keys[name][key].add(remkey)\n                bits.append(input_value + self.reminders[name][remkey])\n\n            new_dict[key] = tuple(bits)\n\n        self.cache[name] = input_dict\n        return new_dict\n\n    def cache_clear(self, name=None):\n        \"\"\"Clear the internal cache, optionally only for function 'name'.\"\"\"\n        with self.lock:\n            if name is None:\n                self.cache.clear()\n                self.reminders.clear()\n                self.reminder_keys.clear()\n            else:\n                self.cache.pop(name, None)\n                self.reminders.pop(name, None)\n                self.reminder_keys.pop(name, None)\n\n    def cache_info(self):\n        \"\"\"Return internal cache dicts as a tuple of 3 elements.\"\"\"\n        with self.lock:\n            return (self.cache, self.reminders, self.reminder_keys)\n\n\ndef wrap_numbers(input_dict, name):\n    \"\"\"Given an `input_dict` and a function `name`, adjust the numbers\n    which \"wrap\" (restart from zero) across different calls by adding\n    \"old value\" to \"new value\" and return an updated dict.\n    \"\"\"\n    with _wn.lock:\n        return _wn.run(input_dict, name)\n\n\n_wn = _WrapNumbers()\nwrap_numbers.cache_clear = _wn.cache_clear\nwrap_numbers.cache_info = _wn.cache_info\n\n\ndef open_binary(fname, **kwargs):\n    return open(fname, \"rb\", **kwargs)\n\n\ndef open_text(fname, **kwargs):\n    \"\"\"On Python 3 opens a file in text mode by using fs encoding and\n    a proper en/decoding errors handler.\n    On Python 2 this is just an alias for open(name, 'rt').\n    \"\"\"\n    if PY3:\n        # See:\n        # https://github.com/giampaolo/psutil/issues/675\n        # https://github.com/giampaolo/psutil/pull/733\n        kwargs.setdefault('encoding', ENCODING)\n        kwargs.setdefault('errors', ENCODING_ERRS)\n    return open(fname, \"rt\", **kwargs)\n\n\ndef bytes2human(n, format=\"%(value).1f%(symbol)s\"):\n    \"\"\"Used by various scripts. See:\n    http://goo.gl/zeJZl\n\n    >>> bytes2human(10000)\n    '9.8K'\n    >>> bytes2human(100001221)\n    '95.4M'\n    \"\"\"\n    symbols = ('B', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')\n    prefix = {}\n    for i, s in enumerate(symbols[1:]):\n        prefix[s] = 1 << (i + 1) * 10\n    for symbol in reversed(symbols[1:]):\n        if n >= prefix[symbol]:\n            value = float(n) / prefix[symbol]\n            return format % locals()\n    return format % dict(symbol=symbols[0], value=n)\n\n\ndef get_procfs_path():\n    \"\"\"Return updated psutil.PROCFS_PATH constant.\"\"\"\n    return sys.modules['psutil'].PROCFS_PATH\n\n\nif PY3:\n    def decode(s):\n        return s.decode(encoding=ENCODING, errors=ENCODING_ERRS)\nelse:\n    def decode(s):\n        return s\n\n\n# =====================================================================\n# --- shell utils\n# =====================================================================\n\n\n@memoize\ndef term_supports_colors(file=sys.stdout):  # pragma: no cover\n    if os.name == 'nt':\n        return True\n    try:\n        import curses\n        assert file.isatty()\n        curses.setupterm()\n        assert curses.tigetnum(\"colors\") > 0\n    except Exception:\n        return False\n    else:\n        return True\n\n\ndef hilite(s, color=None, bold=False):  # pragma: no cover\n    \"\"\"Return an highlighted version of 'string'.\"\"\"\n    if not term_supports_colors():\n        return s\n    attr = []\n    colors = dict(green='32', red='91', brown='33', yellow='93', blue='34',\n                  violet='35', lightblue='36', grey='37', darkgrey='30')\n    colors[None] = '29'\n    try:\n        color = colors[color]\n    except KeyError:\n        raise ValueError(\"invalid color %r; choose between %s\" % (\n            list(colors.keys())))\n    attr.append(color)\n    if bold:\n        attr.append('1')\n    return '\\x1b[%sm%s\\x1b[0m' % (';'.join(attr), s)\n\n\ndef print_color(\n        s, color=None, bold=False, file=sys.stdout):  # pragma: no cover\n    \"\"\"Print a colorized version of string.\"\"\"\n    if not term_supports_colors():\n        print(s, file=file)  # NOQA\n    elif POSIX:\n        print(hilite(s, color, bold), file=file)  # NOQA\n    else:\n        import ctypes\n\n        DEFAULT_COLOR = 7\n        GetStdHandle = ctypes.windll.Kernel32.GetStdHandle\n        SetConsoleTextAttribute = \\\n            ctypes.windll.Kernel32.SetConsoleTextAttribute\n\n        colors = dict(green=2, red=4, brown=6, yellow=6)\n        colors[None] = DEFAULT_COLOR\n        try:\n            color = colors[color]\n        except KeyError:\n            raise ValueError(\"invalid color %r; choose between %r\" % (\n                color, list(colors.keys())))\n        if bold and color <= 7:\n            color += 8\n\n        handle_id = -12 if file is sys.stderr else -11\n        GetStdHandle.restype = ctypes.c_ulong\n        handle = GetStdHandle(handle_id)\n        SetConsoleTextAttribute(handle, color)\n        try:\n            print(s, file=file)    # NOQA\n        finally:\n            SetConsoleTextAttribute(handle, DEFAULT_COLOR)\n\n\nif bool(os.getenv('PSUTIL_DEBUG', 0)):\n    import inspect\n\n    def debug(msg):\n        \"\"\"If PSUTIL_DEBUG env var is set, print a debug message to stderr.\"\"\"\n        fname, lineno, func_name, lines, index = inspect.getframeinfo(\n            inspect.currentframe().f_back)\n        print(\"psutil-debug [%s:%s]> %s\" % (fname, lineno, msg),  # NOQA\n              file=sys.stderr)\nelse:\n    def debug(msg):\n        pass\n"
            },
            "_compat": {
                "type": "module",
                "extension": "py",
                "code": "# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Module which provides compatibility with older Python versions.\nThis is more future-compatible rather than the opposite (prefer latest\nPython 3 way of doing things).\n\"\"\"\n\nimport collections\nimport errno\nimport functools\nimport os\nimport sys\nimport types\n\n__all__ = [\n    # constants\n    \"PY3\",\n    # builtins\n    \"long\", \"range\", \"super\", \"unicode\", \"basestring\",\n    # literals\n    \"u\", \"b\",\n    # collections module\n    \"lru_cache\",\n    # shutil module\n    \"which\", \"get_terminal_size\",\n    # python 3 exceptions\n    \"FileNotFoundError\", \"PermissionError\", \"ProcessLookupError\",\n    \"InterruptedError\", \"ChildProcessError\", \"FileExistsError\"]\n\n\nPY3 = sys.version_info[0] == 3\n_SENTINEL = object()\n\nif PY3:\n    long = int\n    xrange = range\n    unicode = str\n    basestring = str\n    range = range\n\n    def u(s):\n        return s\n\n    def b(s):\n        return s.encode(\"latin-1\")\nelse:\n    long = long\n    range = xrange\n    unicode = unicode\n    basestring = basestring\n\n    def u(s):\n        return unicode(s, \"unicode_escape\")\n\n    def b(s):\n        return s\n\n\n# --- builtins\n\n\n# Python 3 super().\n# Taken from \"future\" package.\n# Credit: Ryan Kelly\nif PY3:\n    super = super\nelse:\n    _builtin_super = super\n\n    def super(type_=_SENTINEL, type_or_obj=_SENTINEL, framedepth=1):\n        \"\"\"Like Python 3 builtin super(). If called without any arguments\n        it attempts to infer them at runtime.\n        \"\"\"\n        if type_ is _SENTINEL:\n            f = sys._getframe(framedepth)\n            try:\n                # Get the function's first positional argument.\n                type_or_obj = f.f_locals[f.f_code.co_varnames[0]]\n            except (IndexError, KeyError):\n                raise RuntimeError('super() used in a function with no args')\n            try:\n                # Get the MRO so we can crawl it.\n                mro = type_or_obj.__mro__\n            except (AttributeError, RuntimeError):\n                try:\n                    mro = type_or_obj.__class__.__mro__\n                except AttributeError:\n                    raise RuntimeError('super() used in a non-newstyle class')\n            for type_ in mro:\n                #  Find the class that owns the currently-executing method.\n                for meth in type_.__dict__.values():\n                    # Drill down through any wrappers to the underlying func.\n                    # This handles e.g. classmethod() and staticmethod().\n                    try:\n                        while not isinstance(meth, types.FunctionType):\n                            if isinstance(meth, property):\n                                # Calling __get__ on the property will invoke\n                                # user code which might throw exceptions or\n                                # have side effects\n                                meth = meth.fget\n                            else:\n                                try:\n                                    meth = meth.__func__\n                                except AttributeError:\n                                    meth = meth.__get__(type_or_obj, type_)\n                    except (AttributeError, TypeError):\n                        continue\n                    if meth.func_code is f.f_code:\n                        break  # found\n                else:\n                    # Not found. Move onto the next class in MRO.\n                    continue\n                break  # found\n            else:\n                raise RuntimeError('super() called outside a method')\n\n        # Dispatch to builtin super().\n        if type_or_obj is not _SENTINEL:\n            return _builtin_super(type_, type_or_obj)\n        return _builtin_super(type_)\n\n\n# --- exceptions\n\n\nif PY3:\n    FileNotFoundError = FileNotFoundError  # NOQA\n    PermissionError = PermissionError  # NOQA\n    ProcessLookupError = ProcessLookupError  # NOQA\n    InterruptedError = InterruptedError  # NOQA\n    ChildProcessError = ChildProcessError  # NOQA\n    FileExistsError = FileExistsError  # NOQA\nelse:\n    # https://github.com/PythonCharmers/python-future/blob/exceptions/\n    #     src/future/types/exceptions/pep3151.py\n    import platform\n\n    def _instance_checking_exception(base_exception=Exception):\n        def wrapped(instance_checker):\n            class TemporaryClass(base_exception):\n\n                def __init__(self, *args, **kwargs):\n                    if len(args) == 1 and isinstance(args[0], TemporaryClass):\n                        unwrap_me = args[0]\n                        for attr in dir(unwrap_me):\n                            if not attr.startswith('__'):\n                                setattr(self, attr, getattr(unwrap_me, attr))\n                    else:\n                        super(TemporaryClass, self).__init__(*args, **kwargs)\n\n                class __metaclass__(type):\n                    def __instancecheck__(cls, inst):\n                        return instance_checker(inst)\n\n                    def __subclasscheck__(cls, classinfo):\n                        value = sys.exc_info()[1]\n                        return isinstance(value, cls)\n\n            TemporaryClass.__name__ = instance_checker.__name__\n            TemporaryClass.__doc__ = instance_checker.__doc__\n            return TemporaryClass\n\n        return wrapped\n\n    @_instance_checking_exception(EnvironmentError)\n    def FileNotFoundError(inst):\n        return getattr(inst, 'errno', _SENTINEL) == errno.ENOENT\n\n    @_instance_checking_exception(EnvironmentError)\n    def ProcessLookupError(inst):\n        return getattr(inst, 'errno', _SENTINEL) == errno.ESRCH\n\n    @_instance_checking_exception(EnvironmentError)\n    def PermissionError(inst):\n        return getattr(inst, 'errno', _SENTINEL) in (\n            errno.EACCES, errno.EPERM)\n\n    @_instance_checking_exception(EnvironmentError)\n    def InterruptedError(inst):\n        return getattr(inst, 'errno', _SENTINEL) == errno.EINTR\n\n    @_instance_checking_exception(EnvironmentError)\n    def ChildProcessError(inst):\n        return getattr(inst, 'errno', _SENTINEL) == errno.ECHILD\n\n    @_instance_checking_exception(EnvironmentError)\n    def FileExistsError(inst):\n        return getattr(inst, 'errno', _SENTINEL) == errno.EEXIST\n\n    if platform.python_implementation() != \"CPython\":\n        try:\n            raise OSError(errno.EEXIST, \"perm\")\n        except FileExistsError:\n            pass\n        except OSError:\n            raise RuntimeError(\n                \"broken or incompatible Python implementation, see: \"\n                \"https://github.com/giampaolo/psutil/issues/1659\")\n\n\n# --- stdlib additions\n\n\n# py 3.2 functools.lru_cache\n# Taken from: http://code.activestate.com/recipes/578078\n# Credit: Raymond Hettinger\ntry:\n    from functools import lru_cache\nexcept ImportError:\n    try:\n        from threading import RLock\n    except ImportError:\n        from dummy_threading import RLock\n\n    _CacheInfo = collections.namedtuple(\n        \"CacheInfo\", [\"hits\", \"misses\", \"maxsize\", \"currsize\"])\n\n    class _HashedSeq(list):\n        __slots__ = 'hashvalue'\n\n        def __init__(self, tup, hash=hash):\n            self[:] = tup\n            self.hashvalue = hash(tup)\n\n        def __hash__(self):\n            return self.hashvalue\n\n    def _make_key(args, kwds, typed,\n                  kwd_mark=(object(), ),\n                  fasttypes=set((int, str, frozenset, type(None))),\n                  sorted=sorted, tuple=tuple, type=type, len=len):\n        key = args\n        if kwds:\n            sorted_items = sorted(kwds.items())\n            key += kwd_mark\n            for item in sorted_items:\n                key += item\n        if typed:\n            key += tuple(type(v) for v in args)\n            if kwds:\n                key += tuple(type(v) for k, v in sorted_items)\n        elif len(key) == 1 and type(key[0]) in fasttypes:\n            return key[0]\n        return _HashedSeq(key)\n\n    def lru_cache(maxsize=100, typed=False):\n        \"\"\"Least-recently-used cache decorator, see:\n        http://docs.python.org/3/library/functools.html#functools.lru_cache\n        \"\"\"\n        def decorating_function(user_function):\n            cache = dict()\n            stats = [0, 0]\n            HITS, MISSES = 0, 1\n            make_key = _make_key\n            cache_get = cache.get\n            _len = len\n            lock = RLock()\n            root = []\n            root[:] = [root, root, None, None]\n            nonlocal_root = [root]\n            PREV, NEXT, KEY, RESULT = 0, 1, 2, 3\n            if maxsize == 0:\n                def wrapper(*args, **kwds):\n                    result = user_function(*args, **kwds)\n                    stats[MISSES] += 1\n                    return result\n            elif maxsize is None:\n                def wrapper(*args, **kwds):\n                    key = make_key(args, kwds, typed)\n                    result = cache_get(key, root)\n                    if result is not root:\n                        stats[HITS] += 1\n                        return result\n                    result = user_function(*args, **kwds)\n                    cache[key] = result\n                    stats[MISSES] += 1\n                    return result\n            else:\n                def wrapper(*args, **kwds):\n                    if kwds or typed:\n                        key = make_key(args, kwds, typed)\n                    else:\n                        key = args\n                    lock.acquire()\n                    try:\n                        link = cache_get(key)\n                        if link is not None:\n                            root, = nonlocal_root\n                            link_prev, link_next, key, result = link\n                            link_prev[NEXT] = link_next\n                            link_next[PREV] = link_prev\n                            last = root[PREV]\n                            last[NEXT] = root[PREV] = link\n                            link[PREV] = last\n                            link[NEXT] = root\n                            stats[HITS] += 1\n                            return result\n                    finally:\n                        lock.release()\n                    result = user_function(*args, **kwds)\n                    lock.acquire()\n                    try:\n                        root, = nonlocal_root\n                        if key in cache:\n                            pass\n                        elif _len(cache) >= maxsize:\n                            oldroot = root\n                            oldroot[KEY] = key\n                            oldroot[RESULT] = result\n                            root = nonlocal_root[0] = oldroot[NEXT]\n                            oldkey = root[KEY]\n                            root[KEY] = root[RESULT] = None\n                            del cache[oldkey]\n                            cache[key] = oldroot\n                        else:\n                            last = root[PREV]\n                            link = [last, root, key, result]\n                            last[NEXT] = root[PREV] = cache[key] = link\n                        stats[MISSES] += 1\n                    finally:\n                        lock.release()\n                    return result\n\n            def cache_info():\n                \"\"\"Report cache statistics\"\"\"\n                lock.acquire()\n                try:\n                    return _CacheInfo(stats[HITS], stats[MISSES], maxsize,\n                                      len(cache))\n                finally:\n                    lock.release()\n\n            def cache_clear():\n                \"\"\"Clear the cache and cache statistics\"\"\"\n                lock.acquire()\n                try:\n                    cache.clear()\n                    root = nonlocal_root[0]\n                    root[:] = [root, root, None, None]\n                    stats[:] = [0, 0]\n                finally:\n                    lock.release()\n\n            wrapper.__wrapped__ = user_function\n            wrapper.cache_info = cache_info\n            wrapper.cache_clear = cache_clear\n            return functools.update_wrapper(wrapper, user_function)\n\n        return decorating_function\n\n\n# python 3.3\ntry:\n    from shutil import which\nexcept ImportError:\n    def which(cmd, mode=os.F_OK | os.X_OK, path=None):\n        \"\"\"Given a command, mode, and a PATH string, return the path which\n        conforms to the given mode on the PATH, or None if there is no such\n        file.\n\n        `mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result\n        of os.environ.get(\"PATH\"), or can be overridden with a custom search\n        path.\n        \"\"\"\n        def _access_check(fn, mode):\n            return (os.path.exists(fn) and os.access(fn, mode) and\n                    not os.path.isdir(fn))\n\n        if os.path.dirname(cmd):\n            if _access_check(cmd, mode):\n                return cmd\n            return None\n\n        if path is None:\n            path = os.environ.get(\"PATH\", os.defpath)\n        if not path:\n            return None\n        path = path.split(os.pathsep)\n\n        if sys.platform == \"win32\":\n            if os.curdir not in path:\n                path.insert(0, os.curdir)\n\n            pathext = os.environ.get(\"PATHEXT\", \"\").split(os.pathsep)\n            if any(cmd.lower().endswith(ext.lower()) for ext in pathext):\n                files = [cmd]\n            else:\n                files = [cmd + ext for ext in pathext]\n        else:\n            files = [cmd]\n\n        seen = set()\n        for dir in path:\n            normdir = os.path.normcase(dir)\n            if normdir not in seen:\n                seen.add(normdir)\n                for thefile in files:\n                    name = os.path.join(dir, thefile)\n                    if _access_check(name, mode):\n                        return name\n        return None\n\n\n# python 3.3\ntry:\n    from shutil import get_terminal_size\nexcept ImportError:\n    def get_terminal_size(fallback=(80, 24)):\n        try:\n            import fcntl\n            import termios\n            import struct\n        except ImportError:\n            return fallback\n        else:\n            try:\n                # This should work on Linux.\n                res = struct.unpack(\n                    'hh', fcntl.ioctl(1, termios.TIOCGWINSZ, '1234'))\n                return (res[1], res[0])\n            except Exception:\n                return fallback\n"
            },
            "_psutil_windows": {
                "type": "module",
                "extension": "pyd",
                "code": "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JJACAABIi4wkgAIAAEgzzOhn1///SIHEmAIAAEFeXl1bw2aQgzgAAIw4AACVOAAAnjgAAKc4AACwOAAAuTgAAMI4AADLOAAAAAEIAggICAMICAgICAgIBAgICAgICAgICAgICAgICAUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIBggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAfMzMzMzMzMzMzMzMzMzMzMzMzMzA+2wf/Ig/h/d1tIjRVfxf//D7aEAiQ7AACLjIIAOwAASAPK/+FIjQV8CgEAw0iNBYjrAADDSI0FWOsAAMNIjQUY6wAAw0iNBQDrAADDSI0FuOoAAMNIjQWA6gAAw0iNBUjqAADDSI0FGOoAAMMPHwC1OgAAvToAAMU6AADNOgAA1ToAAN06AADlOgAA7ToAAPU6AAAAAQgCCAgIAwgICAgICAgECAgICAgICAgICAgICAgIBQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgGCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIB8zMzMzMzMzMzMzMzEBTSIPsIEiLykyNRCRASI0Vv+oAAP8VNZkAAIXAdDmLTCRAugAQAADoI2AAAEiL2EiFwHQjSI1UJEhIi8j/FQ2VAACFwHUZM8n/FXmYAABIi8v/FbiUAAAzwEiDxCBbw0iLy/8Vp5QAAItUJEhIjQ046gAA/xU+mAAASIPEIFvDzMzMzMzMzMzMzMzMzMzMzEBVQVRBV0iNrCQg9P//SIHs4AwAAEiLBazTAABIM8RIiYWwCwAARTPkM8lMiWQkSEyJZCRQTIlkJFhMiWQkaP8V65gAAEyL+EiFwA+EWgMAAEiLBcgIAQBIiZwkAA0AAEiJtCQIDQAASIm8JBANAABMiawk2AwAAEyJtCTQDAAADym0JMAMAABIhcAPhOcCAABMOSU4CQEAD4TaAgAATDklcwkBAA+EzQIAADPSSI1MJGBIiUwkIEyNTCRoM8lEjUIB/9CFwHU1/xVilQAAg/h4D4ShAgAATI0FKu8AAEiNFbPqAABIjU2w6DLT////FTyVAABIjVWw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hvwAAAAAAABu/AAAAAAAAF78AAAAAAAARvwAAAAAAAAu/AAAAAAAABr8AAAAAAAABvwAAAAAAAD0+wAAAAAAAOL7AAAAAAAAxPsAAAAAAAD2+QAAAAAAAOT5AAAAAAAA0PkAAAAAAAB4+gAAAAAAALL7AAAAAAAApPsAAAAAAACS+wAAAAAAAGz7AAAAAAAAWPsAAAAAAABK+wAAAAAAAIr6AAAAAAAANPsAAAAAAAC++QAAAAAAAAAAAAAAAAAADABHZXRNYXBwZWRGaWxlTmFtZVcAABUAR2V0UHJvY2Vzc01lbW9yeUluZm8AAAYARW51bVByb2Nlc3NlcwBQU0FQSS5ETEwAaQNJbml0aWFsaXplQ3JpdGljYWxTZWN0aW9uAH0CR2V0TW9kdWxlSGFuZGxlQQAAaQJHZXRMYXN0RXJyb3IAAMcDTG9hZExpYnJhcnlBAADsAkdldFN5c3RlbUluZm8AtwJHZXRQcm9jQWRkcmVzcwAAswFGcmVlTGlicmFyeQAvBFByb2Nlc3MzMkZpcnN0AABUA0hlYXBGcmVlAABKBVNldFByaW9yaXR5Q2xhc3MAAEsFU2V0UHJvY2Vzc0FmZmluaXR5TWFzawAAnAVUZXJtaW5hdGVQcm9jZXNzAAC4AkdldFByb2Nlc3NBZmZpbml0eU1hc2sAAK0FVGhyZWFkMzJOZXh0AADtAkdldFN5c3RlbVBvd2VyU3RhdHVzAACsBVRocmVhZDMyRmlyc3QA6AVXYWl0Rm9yU2luZ2xlT2JqZWN0ABEET3BlblByb2Nlc3MA/QBDcmVhdGVUb29saGVscDMyU25hcHNob3QAADEEUHJvY2VzczMyTmV4dACIAENsb3NlSGFuZGxlAMICR2V0UHJvY2Vzc0lvQ291bnRlcnMAAFADSGVhcEFsbG9jAKwCR2V0UHJpb3JpdHlDbGFzcwAAvQJHZXRQcm9jZXNzSGVhcAAARQNHbG9iYWxNZW1vcnlTdGF0dXNFeAAADgNHZXRUaHJlYWRUaW1lcwAA8gJHZXRTeXN0ZW1UaW1lQXNGaWxlVGltZQC8AkdldFByb2Nlc3NIYW5kbGVDb3VudADHAkdldFByb2Nlc3NUaW1lcwAYBE9wZW5UaHJlYWQAAOAFVmlydHVhbFF1ZXJ5RXgAAEUCR2V0RXhpdENvZGVQcm9jZXNzAAD0AkdldFN5c3RlbVRpbWVzAADQA0xvY2FsQWxsb2MAANUDTG9jYWxGcmVlAEAFU2V0TGFzdEVycm9yAAChAUZpbmRWb2x1bWVNb3VudFBvaW50Q2xvc2UAIwFEZXZpY2VJb0NvbnRyb2wANwJHZXREcml2ZVR5cGVBACQFU2V0RXJyb3JNb2RlAABIBFF1ZXJ5RG9zRGV2aWNlQQAnA0dldFZvbHVtZUluZm9ybWF0aW9uQQCXAUZpbmROZXh0Vm9sdW1lTW91bnRQb2ludEEAjAFGaW5kRmlyc3RWb2x1bWVNb3VudFBvaW50QQAAxQBDcmVhdGVGaWxlQQAxAkdldERpc2tGcmVlU3BhY2VFeFcAbgJHZXRMb2dpY2FsRHJpdmVTdHJpbmdzQQBEBmxzdHJjbXBBAAA3AUVudGVyQ3JpdGljYWxTZWN0aW9uAAAfAkdldEN1cnJlbnRQcm9jZXNzAMMDTGVhdmVDcml0aWNhbFNlY3Rpb24AADEBRHVwbGljYXRlSGFuZGxlAEYCR2V0RXhpdENvZGVUaHJlYWQAnQVUZXJtaW5hdGVUaHJlYWQA9ABDcmVhdGVUaHJlYWQAAFcCR2V0RmlsZVR5cGUAewRSZWFkUHJvY2Vzc01lbW9yeQCuBFJlZ2lzdGVyV2FpdEZvclNpbmdsZU9iamVjdADBAENyZWF0ZUV2ZW50VwAAS0VSTkVMMzIuZGxsAABwAUdldFRva2VuSW5mb3JtYXRpb24AqQFMb29rdXBBY2NvdW50U2lkVwAVAk9wZW5Qcm9jZXNzVG9rZW4AAI0BSW1wZXJzb25hdGVTZWxmAK4BTG9va3VwUHJpdmlsZWdlVmFsdWVBAMECUmV2ZXJ0VG9TZWxmAAAfAEFkanVzdFRva2VuUHJpdmlsZWdlcwAYAk9wZW5TZXJ2aWNlQQAAUQJRdWVyeVNlcnZpY2VTdGF0dXNFeAAASQJRdWVyeVNlcnZpY2VDb25maWcyVwAASwJRdWVyeVNlcnZpY2VDb25maWdXABQBRW51bVNlcnZpY2VzU3RhdHVzRXhXAPgCU3RhcnRTZXJ2aWNlQQBqAENvbnRyb2xTZXJ2aWNlAAAWAk9wZW5TQ01hbmFnZXJBAABlAENsb3NlU2VydmljZUhhbmRsZQAAQURWQVBJMzIuZGxsAAAIAENvbW1hbmRMaW5lVG9Bcmd2VwAAU0hFTEwzMi5kbGwAtQBpbmV0X250b3AAV1MyXzMyLmRsbAAAAABDYWxsTnRQb3dlckluZm9ybWF0aW9uAABQT1dSUFJPRi5kbGwAAD0AUGRoR2V0Rm9ybWF0dGVkQ291bnRlclZhbHVlAAMAUGRoQWRkRW5nbGlzaENvdW50ZXJXAA8AUGRoQ29sbGVjdFF1ZXJ5RGF0YUV4AFAAUGRoT3BlblF1ZXJ5VwBwZGguZGxsANcAUHlFcnJfU2V0T2JqZWN0APYAUHlFdmFsX1NhdmVUaHJlYWQAFwZfUHlfTm9uZVN0cnVjdAAAVQJQeU9iamVjdF9DYWxsRnVuY3Rpb24A9AVfUHlfRGVhbGxvYwCyAFB5RXJyX0NsZWFyANEAUHlFcnJfU2V0RnJvbVdpbmRvd3NFcnJXaXRoRmlsZW5hbWUAHwFQeUV4Y19PU0Vycm9yAPUAUHlFdmFsX1Jlc3RvcmVUaHJlYWQAABMAUHlCb29sX0Zyb21Mb25nAPcBUHlNb2R1bGVfQWRkSW50Q29uc3RhbnQAJwFQeUV4Y19SdW50aW1lRXJyb3IAAL0BUHlMb25nX0Zyb21Mb25nAPADUHlfQnVpbGRWYWx1ZQDQAFB5RXJyX1NldEZyb21XaW5kb3dzRXJyAMoDUHlVbmljb2RlX0Zyb21XaWRlQ2hhcgAA2ABQeUVycl9TZXRTdHJpbmcA/QVfUHlfRmFsc2VTdHJ1Y3QA+AFQeU1vZHVsZV9BZGRPYmplY3QAAKgBUHlMaXN0X05ldwAA+wFQeU1vZHVsZV9DcmVhdGUyAAC6AFB5RXJyX05ld0V4Y2VwdGlvbgAAowFQeUxpc3RfQXBwZW5kAKcAUHlEaWN0X1NldEl0ZW0AAKQAUHlEaWN0X05ldwAAvABQeUVycl9Ob01lbW9yeQAACwBQeUFyZ19QYXJzZVR1cGxlQW5kS2V5d29yZHMAfgJQeU9iamVjdF9Jc1RydWUAJAZfUHlfVHJ1ZVN0cnVjdAAABAJQeU1vZHVsZV9HZXRTdGF0ZQAKAFB5QXJnX1BhcnNlVHVwbGUAAKgAUHlEaWN0X1NldEl0ZW1TdHJpbmcAAMcDUHlVbmljb2RlX0Zyb21TdHJpbmcAANwAUHlFcnJfV2FybkV4AAAoAVB5RXhjX1J1bnRpbWVXYXJuaW5nAABJA1B5VHVwbGVfTmV3AM4CUHlTZXF1ZW5jZV9Db250YWlucwDMAlB5U2VxdWVuY2VfQ2hlY2sAADEBUHlFeGNfVHlwZUVycm9yAHB5dGhvbjM5LmRsbAAAVQBHZXRJZkVudHJ5MgBDAEdldEFkYXB0ZXJzQWRkcmVzc2VzAABYAEdldElmVGFibGUAABkAQ29udmVydExlbmd0aFRvSXB2NE1hc2sASVBITFBBUEkuRExMAABAAHN0cmNocgAACABfX0Nfc3BlY2lmaWNfaGFuZGxlcgAAJQBfX3N0ZF90eXBlX2luZm9fZGVzdHJveV9saXN0AAA+AG1lbXNldAAAVkNSVU5USU1FMTQwLmRsbAAAAABfX2FjcnRfaW9iX2Z1bmMAAwBfX3N0ZGlvX2NvbW1vbl92ZnByaW50ZgANAF9fc3RkaW9fY29tbW9uX3ZzcHJpbnRmABAAZ2V0ZW52AAAPAF9fc3RkaW9fY29tbW9uX3ZzcHJpbnRmX3MAGABmcmVlAAAZAG1hbGxvYwAAiQBzdHJjcHlfcwAAhQBzdHJjYXRfcwAAFwBjYWxsb2MAAKEAd2NzY3B5X3MAADYAX2luaXR0ZXJtADcAX2luaXR0ZXJtX2UAPwBfc2VoX2ZpbHRlcl9kbGwAGABfY29uZmlndXJlX25hcnJvd19hcmd2AAAzAF9pbml0aWFsaXplX25hcnJvd19lbnZpcm9ubWVudAAANABfaW5pdGlhbGl6ZV9vbmV4aXRfdGFibGUAACIAX2V4ZWN1dGVfb25leGl0X3RhYmxlABYAX2NleGl0AABhcGktbXMtd2luLWNydC1zdGRpby1sMS0xLTAuZGxsAGFwaS1tcy13aW4tY3J0LWVudmlyb25tZW50LWwxLTEtMC5kbGwAYXBpLW1zLXdpbi1jcnQtaGVhcC1sMS0xLTAuZGxsAABhcGktbXMtd2luLWNydC1zdHJpbmctbDEtMS0wLmRsbAAAYXBpLW1zLXdpbi1jcnQtcnVudGltZS1sMS0xLTAuZGxsANQEUnRsQ2FwdHVyZUNvbnRleHQA2wRSdGxMb29rdXBGdW5jdGlvbkVudHJ5AADiBFJ0bFZpcnR1YWxVbndpbmQAAL4FVW5oYW5kbGVkRXhjZXB0aW9uRmlsdGVyAAB9BVNldFVuaGFuZGxlZEV4Y2VwdGlvbkZpbHRlcgCLA0lzUHJvY2Vzc29yRmVhdHVyZVByZXNlbnQAUQRRdWVyeVBlcmZvcm1hbmNlQ291bnRlcgAgAkdldEN1cnJlbnRQcm9jZXNzSWQAJAJHZXRDdXJyZW50VGhyZWFkSWQAACQBRGlzYWJsZVRocmVhZExpYnJhcnlDYWxscwBuA0luaXRpYWxpemVTTGlzdEhlYWQAhANJc0RlYnVnZ2VyUHJlc2VudAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAzV0g0mbU//8yot8tmSsAAP////8AAAAAAQAAAAIAAAAvIAAAAAAAAAD4AAAAAAAAAQAAAAAAAAAAAAAAAAAAAHBpZAAAAAAAdXNlX3BlYgBwcm9jX2NtZGxpbmUAAAAAUmV0dXJuIHByb2Nlc3MgY21kbGluZSBhcyBhIGxpc3Qgb2YgY21kbGluZSBhcmd1bWVudHMAAABwcm9jX2Vudmlyb24AAAAAUmV0dXJuIHByb2Nlc3MgZW52aXJvbm1lbnQgZGF0YQBwcm9jX2V4ZQAAAAAAAAAAUmV0dXJuIHBhdGggb2YgdGhlIHByb2Nlc3MgZXhlY3V0YWJsZQAAAHByb2Nfa2lsbAAAAAAAAABLaWxsIHRoZSBwcm9jZXNzIGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuIFBJRAAAAABwcm9jX3RpbWVzAAAAAAAAUmV0dXJuIHR1cGxlIG9mIHVzZXIva2VybiB0aW1lIGZvciB0aGUgZ2l2ZW4gUElEAAAAAAAAAABwcm9jX21lbW9yeV9pbmZvAAAAAAAAAABSZXR1cm4gYSB0dXBsZSBvZiBwcm9jZXNzIG1lbW9yeSBpbmZvcm1hdGlvbgAAAABwcm9jX21lbW9yeV91c3MAUmV0dXJuIHRoZSBVU1Mgb2YgdGhlIHByb2Nlc3MAAABwcm9jX2N3ZAAAAAAAAAAAUmV0dXJuIHByb2Nlc3MgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeQAAAAAAAAAAcHJvY19zdXNwZW5kX29yX3Jlc3VtZQAAU3VzcGVuZCBvciByZXN1bWUgYSBwcm9jZXNzAAAAAABwcm9jX29wZW5fZmlsZXMAUmV0dXJuIGZpbGVzIG9wZW5lZCBieSBwcm9jZXNzAABwcm9jX3VzZXJuYW1lAAAAUmV0dXJuIHRoZSB1c2VybmFtZSBvZiBhIHByb2Nlc3MAAAAAAAAAAHByb2NfdGhyZWFkcwAAAABSZXR1cm4gcHJvY2VzcyB0aHJlYWRzIGluZm9ybWF0aW9uIGFzIGEgbGlzdCBvZiB0dXBsZQAAAHByb2Nfd2FpdAAAAAAAAABXYWl0IGZvciBwcm9jZXNzIHRvIHRlcm1pbmF0ZSBhbmQgcmV0dXJuIGl0cyBleGl0IGNvZGUuAHByb2NfcHJpb3JpdHlfZ2V0AAAAAAAAAFJldHVybiBwcm9jZXNzIHByaW9yaXR5LgAAAAAAAAAAcHJvY19wcmlvcml0eV9zZXQAAAAAAAAAU2V0IHByb2Nlc3MgcHJpb3JpdHkuAAAAcHJvY19pb19wcmlvcml0eV9nZXQAAAAAUmV0dXJuIHByb2Nlc3MgSU8gcHJpb3JpdHkuAAAAAABwcm9jX2lvX3ByaW9yaXR5X3NldAAAAABTZXQgcHJvY2VzcyBJTyBwcmlvcml0eS4AAAAAAAAAAHByb2NfY3B1X2FmZmluaXR5X2dldAAAAFJldHVybiBwcm9jZXNzIENQVSBhZmZpbml0eSBhcyBhIGJpdG1hc2suAAAAAAAAAHByb2NfY3B1X2FmZmluaXR5X3NldAAAAFNldCBwcm9jZXNzIENQVSBhZmZpbml0eS4AAAAAAAAAcHJvY19pb19jb3VudGVycwAAAAAAAAAAR2V0IHByb2Nlc3MgSS9PIGNvdW50ZXJzLgAAAAAAAABwcm9jX2lzX3N1c3BlbmRlZAAAAAAAAABwcm9jX251bV9oYW5kbGVzAAAAAAAAAABSZXR1cm4gVHJ1ZSBpZiBvbmUgb2YgdGhlIHByb2Nlc3MgdGhyZWFkcyBpcyBpbiBhIHN1c3BlbmRlZCBzdGF0ZQAAAAAAAABSZXR1cm4gdGhlIG51bWJlciBvZiBoYW5kbGVzIG9wZW5lZCBieSBwcm9jZXNzLgBwcm9jX21lbW9yeV9tYXBzAAAAAAAAAABSZXR1cm4gYSBsaXN0IG9mIHByb2Nlc3MncyBtZW1vcnkgbWFwcGluZ3MAAAAAAABwcm9jX2luZm8AAAAAAAAAVmFyaW91cyBwcm9jZXNzIGluZm9ybWF0aW9uAHBpZHMAAAAAAAAAAFJldHVybnMgYSBsaXN0IG9mIFBJRHMgY3VycmVudGx5IHJ1bm5pbmcgb24gdGhlIHN5c3RlbQAAcHBpZF9tYXAAAAAAAAAAAFJldHVybiBhIHtwaWQ6cHBpZCwgLi4ufSBkaWN0IGZvciBhbGwgcnVubmluZyBwcm9jZXNzZXMAcGlkX2V4aXN0cwAAAAAAAERldGVybWluZSBpZiB0aGUgcHJvY2VzcyBleGlzdHMgaW4gdGhlIGN1cnJlbnQgcHJvY2VzcyBsaXN0LgAAAABjcHVfY291bnRfbG9naWNhbAAAAAAAAABSZXR1cm5zIHRoZSBudW1iZXIgb2YgbG9naWNhbCBDUFVzIG9uIHRoZSBzeXN0ZW0AAAAAAAAAAGNwdV9jb3VudF9waHlzAABSZXR1cm5zIHRoZSBudW1iZXIgb2YgcGh5c2ljYWwgQ1BVcyBvbiB0aGUgc3lzdGVtAAAAAAAAAGJvb3RfdGltZQAAAAAAAABSZXR1cm4gdGhlIHN5c3RlbSBib290IHRpbWUgZXhwcmVzc2VkIGluIHNlY29uZHMgc2luY2UgdGhlIGVwb2NoLgAAAAAAAAB2aXJ0dWFsX21lbQAAAAAAUmV0dXJuIHRoZSB0b3RhbCBhbW91bnQgb2YgcGh5c2ljYWwgbWVtb3J5LCBpbiBieXRlcwAAAABjcHVfdGltZXMAAAAAAAAAUmV0dXJuIHN5c3RlbSBjcHUgdGltZXMgYXMgYSBsaXN0AAAAAAAAAHBlcl9jcHVfdGltZXMAAABSZXR1cm4gc3lzdGVtIHBlci1jcHUgdGltZXMgYXMgYSBsaXN0IG9mIHR1cGxlcwBkaXNrX3VzYWdlAAAAAAAAUmV0dXJuIHBhdGgncyBkaXNrIHRvdGFsIGFuZCBmcmVlIGFzIGEgUHl0aG9uIHR1cGxlLgAAAABuZXRfaW9fY291bnRlcnMAUmV0dXJuIGRpY3Qgb2YgdHVwbGVzIG9mIG5ldHdvcmtzIEkvTyBpbmZvcm1hdGlvbi4AAAAAAABkaXNrX2lvX2NvdW50ZXJzAAAAAAAAAABSZXR1cm4gZGljdCBvZiB0dXBsZXMgb2YgZGlza3MgSS9PIGluZm9ybWF0aW9uLgB1c2VycwAAAFJldHVybiBhIGxpc3Qgb2YgY3VycmVudGx5IGNvbm5lY3RlZCB1c2Vycy4AAAAAAGRpc2tfcGFydGl0aW9ucwBSZXR1cm4gZGlzayBwYXJ0aXRpb25zLgBuZXRfY29ubmVjdGlvbnMAUmV0dXJuIHN5c3RlbS13aWRlIGNvbm5lY3Rpb25zAABuZXRfaWZfYWRkcnMAAAAAUmV0dXJuIE5JQ3MgYWRkcmVzc2VzLgAAbmV0X2lmX3N0YXRzAAAAAFJldHVybiBOSUNzIHN0YXRzLgAAAAAAAGNwdV9zdGF0cwAAAAAAAABSZXR1cm4gTklDcyBzdGF0cy4AAAAAAABjcHVfZnJlcQAAAAAAAAAAUmV0dXJuIENQVSBmcmVxdWVuY3kuAAAAaW5pdF9sb2FkYXZnX2NvdW50ZXIAAAAASW5pdGlhbGl6ZXMgdGhlIGVtdWxhdGVkIGxvYWQgYXZlcmFnZSBjYWxjdWxhdG9yLgAAAAAAAABnZXRsb2FkYXZnAAAAAAAAUmV0dXJucyB0aGUgZW11bGF0ZWQgUE9TSVgtbGlrZSBsb2FkIGF2ZXJhZ2UuAAAAc2Vuc29yc19iYXR0ZXJ5AFJldHVybiBiYXR0ZXJ5IG1ldHJpY3MgdXNhZ2UuAAAAZ2V0cGFnZXNpemUAAAAAAFJldHVybiBzeXN0ZW0gbWVtb3J5IHBhZ2Ugc2l6ZS4Ad2luc2VydmljZV9lbnVtZXJhdGUAAAAATGlzdCBhbGwgc2VydmljZXMAAAAAAAAAd2luc2VydmljZV9xdWVyeV9jb25maWcAUmV0dXJuIHNlcnZpY2UgY29uZmlnAAAAd2luc2VydmljZV9xdWVyeV9zdGF0dXMA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AQAAAAAAAAC4GwGAAQAAANAbAYABAAAAYKcAgAEAAAABAAAAAAAAAOgbAYABAAAAABwBgAEAAACQsQCAAQAAAAEAAAAAAAAAGBwBgAEAAAAwHAGAAQAAAKCrAIABAAAAAQAAAAAAAABIHAGAAQAAAHAcAYABAAAAkLAAgAEAAAABAAAAAAAAAIgcAYABAAAAmBwBgAEAAABgqgCAAQAAAAEAAAAAAAAAqBwBgAEAAAC4HAGAAQAAABByAIABAAAAAQAAAAAAAADQHAGAAQAAAOgcAYABAAAAgC0AgAEAAAAEAAAAAAAAAPgcAYABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB3dHNhcGkzMi5kbGwAAAAAV1RTRnJlZU1lbW9yeQAAAHd0c2FwaTMyLmRsbAAAAABXVFNRdWVyeVNlc3Npb25JbmZvcm1hdGlvblcACgAAAHd0c2FwaTMyLmRsbAAAAABXVFNFbnVtZXJhdGVTZXNzaW9uc1cAAABrZXJuZWwzMgAAAABudGRsbAAAAFdJTlZFUgAASQAAAEdldExvZ2ljYWxQcm9jZXNzb3JJbmZvcm1hdGlvbkV4AAAAAG50ZGxsAAAAKEtzT0kpAABpAAAAa2VybmVsMzIAAAAAbnRkbGwAAAA/AAAAR2V0QWN0aXZlUHJvY2Vzc29yQ291bnQAbnRkbGwuZGxsAAAAeHdjAFJ0bElwdjZBZGRyZXNzVG9TdHJpbmdBAGtlcm5lbDMyAAAAAG50ZGxsAAAAeHJ3AEdldFRpY2tDb3VudDY0AABSdGxOdFN0YXR1c1RvRG9zRXJyb3JOb1RlYgAAeHIAAE50UXVlcnlWaXJ0dWFsTWVtb3J5AAAAAE50UmVzdW1lUHJvY2VzcwBOdFN1c3BlbmRQcm9jZXNzAAAAAHgAAABudGRsbC5kbGwAAAB3YwAAUnRsR2V0VmVyc2lvbgAAAGlwaGxwYXBpLmRsbAAAAABHZXRFeHRlbmRlZFVkcFRhYmxlAHJ3AABpcGhscGFwaS5kbGwAAAAAR2V0RXh0ZW5kZWRUY3BUYWJsZQByAAAAbnRkbGwuZGxsAAAAawAAAFJ0bElwdjRBZGRyZXNzVG9TdHJpbmdBAG50ZGxsLmRsbAAAAGkAAABOdFF1ZXJ5T2JqZWN0AAAAbnRkbGwuZGxsAAAAT09kAE50U2V0SW5mb3JtYXRpb25Qcm9jZXNzAG50ZGxsLmRsbAAAAHMAAABOdFF1ZXJ5SW5mb3JtYXRpb25Qcm9jZXNzAAAAaQAAAG50ZGxsLmRsbAAAAGlLAABOdFF1ZXJ5U3lzdGVtSW5mb3JtYXRpb24AAAAASwAAAChvcmlnaW5hdGVkIGZyb20gJXMpAAAAAFBTVVRJTF9URVNUSU5HAABQU1VUSUxfREVCVUcAAAAAcHN1dGlsLWRlYnVnPiAAAChpcykAAAAAYXNzdW1lIGFjY2VzcyBkZW5pZWQgKG9yaWdpbmF0ZWQgZnJvbSAlcykAAAAoaXMpAAAAAGkAAABhc3N1bWUgbm8gc3VjaCBwcm9jZXNzIChvcmlnaW5hdGVkIGZyb20gJXMpAGkAAAAob3JpZ2luYXRlZCBmcm9tICVzKQAAAABAEAGAAQAAAEgQAYABAAAAAAAAAAAAAABFUlJPUl9JTlZBTElEX05BTUUAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGB0BgAEAAAAAAAAAAAAAAAgAAAAAAAAAMB0BgAEAAAAAAAAAAAAAALA0AIABAAAAYDQAgAEAAAAAAAAAAAAAAFdJTkRPV1NfMTAAAGlpAABXSU5ET1dTXzhfMQBpAAAAV0lORE9XU184AAAAaQAAAFdJTkRPV1NfNwAAAGlpAABXSU5ET1dTX1ZJU1RBAAAARVJST1JfUFJJVklMRUdFX05PVF9IRUxEAAAAAGkAAABFUlJPUl9TRVJWSUNFX0RPRVNfTk9UX0VYSVNUAAAAAEVSUk9SX0FDQ0VTU19ERU5JRUQAaQAAAElORklOSVRFAAAAAE9PAABQU1VUSUxfQ09OTl9OT05FAAAAAGkAAABNSUJfVENQX1NUQVRFX0RFTEVURV9UQ0IAAAAAaQAAAE1JQl9UQ1BfU1RBVEVfVElNRV9XQUlUAE1JQl9UQ1BfU1RBVEVfVElNRV9XQUlUAE1JQl9UQ1BfU1RBVEVfTEFTVF9BQ0sAAE1JQl9UQ1BfU1RBVEVfRklOX1dBSVQyAE1JQl9UQ1BfU1RBVEVfRklOX1dBSVQxAE1JQl9UQ1BfU1RBVEVfU1lOX1JDVkQAAE1JQl9UQ1BfU1RBVEVfU1lOX1NFTlQAAE1JQl9UQ1BfU1RBVEVfRVNUQUIAa2RkAE1JQl9UQ1BfU1RBVEVfTElTVEVOAAAAAE1JQl9UQ1BfU1RBVEVfQ0xPU0VfV0FJVAAAAABpAAAATUlCX1RDUF9TVEFURV9DTE9TSU5HAAAATUlCX1RDUF9TVEFURV9DTE9TRUQAAAAAUkVBTFRJTUVfUFJJT1JJVFlfQ0xBU1MATk9STUFMX1BSSU9SSVRZX0NMQVNTAAAASURMRV9QUklPUklUWV9DTEFTUwBpTwAASElHSF9QUklPUklUWV9DTEFTUwBpAAAAQkVMT1dfTk9STUFMX1BSSU9SSVRZX0NMQVNTAEkAAABBQk9WRV9OT1JNQUxfUFJJT1JJVFlfQ0xBU1MAaQAAAHZlcnNpb24AVGltZW91dEFiYW5kb25lZAAAAABpAAAAX3BzdXRpbF93aW5kb3dzLlRpbWVvdXRBYmFuZG9uZWQAAAAAcwAAAFRpbWVvdXRFeHBpcmVkAABfcHN1dGlsX3dpbmRvd3MuVGltZW91dEV4cGlyZWQAAF9wc3V0aWxfd2luZG93cy5FcnJvcgAAAGlpaUkAAAAAV1RTUXVlcnlTZXNzaW9uSW5mb3JtYXRpb25XAGkAAAAldS4ldS4ldS4ldQBzAAAAV1RTUXVlcnlTZXNzaW9uSW5mb3JtYXRpb25XAGkAAABXVFNRdWVyeVNlc3Npb25JbmZvcm1hdGlvblcAW10AAFdUU0VudW1lcmF0ZVNlc3Npb25zVwAAAChLS0tLS0spAAAAAGl8TwBOdFNldEluZm9ybWF0aW9uUHJvY2VzcwBOdFF1ZXJ5SW5mb3JtYXRpb25Qcm9jZXNzAAAAaQAAAExvb2t1cEFjY291bnRTaWRXAAAAaWwAAExvb2t1cEFjY291bnRTaWRXIC0+IEVSUk9SX05PTkVfTUFQUEVEAABHZXRUb2tlbkluZm9ybWF0aW9uAGkAAABPcGVuUHJvY2Vzc1Rva2VuAAAAAChkZGQpAAAAaQAAAEdldFRocmVhZFRpbWVzAABUaHJlYWQzMkZpcnN0AAAAQ3JlYXRlVG9vbGhlbHAzMlNuYXBzaG90AAAAAGQAAABwc3V0aWxfcGlkX2lzX3J1bm5pbmcgLT4gMAAAa2sAAGZvcmNlZCBmb3IgUElEIDAAAAAASQAAAE50U3VzcGVuZHxSZXN1bWVQcm9jZXNzAHBzdXRpbF9waWRfaXNfcnVubmluZyAtPiAwAABJAAAAKExMTExMTCkAAAAAKGRkZCkAAABzAAAATnRRdWVyeVZpcnR1YWxNZW1vcnkoTWVtb3J5V29ya2luZ1NldEluZm9ybWF0aW9uKQAAAHMAAABwc3V0aWxfcGlkX2lzX3J1bm5pbmcgLT4gMAAAJWM6AE50UXVlcnlWaXJ0dWFsTWVtb3J5IC0+IFNUQVRVU19BQ0NFU1NfREVOSUVEAAAAAE50UXVlcnlWaXJ0dWFsTWVtb3J5IGJ1ZnNpemUgaXMgdG9vIGxhcmdlAAAAcwAAAChrS0tLS0tLS0tLKQAAAABOdFF1ZXJ5U3lzdGVtSW5mb3JtYXRpb24AAAAALAAAAHBzdXRpbF9waWRfaXNfcnVubmluZyAtPiAwAABydwAAYXV0b21hdGljYWxseSBzZXQgZm9yIFBJRCAwAHJvAABwc3V0aWxfcGlkX2lzX3J1bm5pbmcgLT4gMAAAQTpcAHBzdXRpbF9waWRfaXNfcnVubmluZyAtPiAwAABPAAAAR2V0UHJvY2Vzc1RpbWVzIC0+IEVSUk9SX0FDQ0VTU19ERU5JRUQAAEdldEV4aXRDb2RlUHJvY2VzcwAAdQAAAFdhaXRGb3JTaW5nbGVPYmplY3QoKSByZXR1cm5lZCBXQUlUX0FCQU5ET05FRAAAAFdhaXRGb3JTaW5nbGVPYmplY3QoKSAtPiBXQUlUX0FCQU5ET05FRABXYWl0Rm9yU2luZ2xlT2JqZWN0KCkgcmV0dXJuZWQgV0FJVF9USU1FT1VUAD8AAABXYWl0Rm9yU2luZ2xlT2JqZWN0ACV3UwBPcGVuUHJvY2VzcwBzAAAAYXV0b21hdGljYWxseSBzZXQgZm9yIFBJRCAwAABAAABUZXJtaW5hdGVQcm9jZXNzAAAAAHJlbW90ZQAAaQAAAGF1dG9tYXRpY2FsbHkgc2V0IGZvciBQSUQgMABzAAAAQ2FsbE50UG93ZXJJbmZvcm1hdGlvbiBzeXNjYWxsIGZhaWxlZAAAAGtra2sAAAAATnRRdWVyeVN5c3RlbUluZm9ybWF0aW9uKFN5c3RlbVByb2Nlc3NvclBlcmZvcm1hbmNlSW5mb3JtYXRpb24pAE50UXVlcnlTeXN0ZW1JbmZvcm1hdGlvbihTeXN0ZW1JbnRlcnJ1cHRJbmZvcm1hdGlvbikAAAAATnRRdWVyeVN5c3RlbUluZm9ybWF0aW9uKFN5c3RlbVBlcmZvcm1hbmNlSW5mb3JtYXRpb24pAABHZXRMb2dpY2FsUHJvY2Vzc29ySW5mb3JtYXRpb25FeCgpIGNvdW50IHdhcyAwAABHZXRMb2dpY2FsUHJvY2Vzc29ySW5mb3JtYXRpb25FeCgpIHJldHVybmVkIAAAAABXaW4gPCA3OyBjcHVfY291bnRfcGh5cygpIGZvcmNlZCB0byBOb25lAAAAAGNkcm9tAAAAKE9pa2spAABzAAAAKGRkZGRkKQBcXC5cUGh5c2ljYWxEcml2ZSVkAAAAAABOdFF1ZXJ5U3lzdGVtSW5mb3JtYXRpb24oU3lzdGVtUHJvY2Vzc29yUGVyZm9ybWFuY2VJbmZvcm1hdGlvbikAR2V0U3lzdGVtSW5mbygpIGZhaWxlZCB0byByZXRyaWV2ZSBDUFUgY291bnQAAAAAR2V0QWN0aXZlUHJvY2Vzc29yQ291bnQoKSBub3QgYXZhaWxhYmxlOyB1c2luZyBHZXRTeXN0ZW1JbmZvKCkAAChzc3NzSWkpAAAAAGZpeGVkAAAAcwAAAChzc3NzSWkpAAAAACUuMlgtAAAAcwAAACxyZWFkb25seQAAAHMAAAAsY29tcHJlc3NlZABzAAAAKElJTExLSykAAAAAJS4yWAoAAABzAAAAUGh5c2ljYWxEcml2ZSVpAERldmljZUlvQ29udHJvbCAtPiBFUlJPUl9OT1RfU1VQUE9SVEVEOyBpZ25vcmUgUGh5c2ljYWxEcml2ZSVpAAAoTEwpAAAAAERldmljZUlvQ29udHJvbCAtPiBFUlJPUl9JTlZBTElEX0ZVTkNUSU9OOyBpZ25vcmUgUGh5c2ljYWxEcml2ZSVpAAAAKE9PT3MpAABzAAAAcmFtZGlzawB1bm1vdW50ZWQAAABwYXVzZWQAAGlPTwB1bmtub3duAHJlbW92YWJsZQAAAG1hbnVhbAAAAAAAAEdldElmVGFibGUoKSBzeXNjYWxsIGZhaWxlZAAAAAAAKE9pT09PTykAAAAAAAAAAChPaU9PT08pAAAAAAAAAAAoS0tLS0tLS0spAAAAAAAAR2V0SWZFbnRyeSgpIG9yIEdldElmRW50cnkyKCkgc3lzY2FsbHMgZmFpbGVkLgAAR2V0QWRhcHRlcnNBZGRyZXNzZXMoKSBzeXNjYWxsIGZhaWxlZC4AAEdldEFkYXB0ZXJzQWRkcmVzc2VzKCkgc3lzY2FsbCBmYWlsZWQuAABHZXRFeGl0Q29kZVRocmVhZAAAAAAAAABHZXRFeGl0Q29kZVRocmVhZCAoZmFpbGVkKSAtPiBUZXJtaW5hdGVUaHJlYWQAAABXYWl0Rm9yU2luZ2xlT2JqZWN0AAAAAABXYWl0Rm9yU2luZ2xlT2JqZWN0IC0+IFdBSVRfRkFJTEVEIC0+IFRlcm1pbmF0ZVRocmVhZAAAAFdhaXRGb3JTaW5nbGVPYmplY3QgLT4gV0FJVF9GQUlMRUQAAAAAAABUZXJtaW5hdGVUaHJlYWQAZ2V0IGhhbmRsZSBuYW1lIHRocmVhZCB0aW1lZCBvdXQgYWZ0ZXIgJWkgbXMAAAAAQ3JlYXRlVGhyZWFkAAAAAE50UXVlcnlTeXN0ZW1JbmZvcm1hdGlvbgAAAAAAAAAATnRRdWVyeVN5c3RlbUluZm9ybWF0aW9uAAAAAAAAAABTeXN0ZW1FeHRlbmRlZEhhbmRsZUluZm9ybWF0aW9uIGJ1ZmZlciB0b28gYmlnAABra2RkZGtLS0tLS0trS0tLS0tLS0tLAABOdFF1ZXJ5U3lzdGVtSW5mb3JtYXRpb24gKG5vIFBJRCBmb3VuZCkATnRRdWVyeVN5c3RlbUluZm9ybWF0aW9uKFN5c3RlbVByb2Nlc3NJbmZvcm1hdGlvbikAAAAAAABDb21tYW5kTGluZVRvQXJndlcAAAAAAABOdFF1ZXJ5SW5mb3JtYXRpb25Qcm9jZXNzKFByb2Nlc3NDb21tYW5kTGluZUluZm9ybWF0aW9uKQAAAAAAAAAATnRRdWVyeUluZm9ybWF0aW9uUHJvY2VzcyhQcm9jZXNzQmFzaWNJbmZvcm1hdGlvbikAAAAAAAByZXF1aXJlcyBXaW5kb3dzIDguMSsAAABOdFF1ZXJ5SW5mb3JtYXRpb25Qcm9jZXNzKFByb2Nlc3NCYXNpY0luZm9ybWF0aW9uKSAtPiBTVEFUVVNfTk9UX0ZPVU5EAABSZWFkUHJvY2Vzc01lbW9yeQAAAAAAAABSZWFkUHJvY2Vzc01lbW9yeQAAAAAAAABSZWFkUHJvY2Vzc01lbW9yeQAAAAAAAABOdFF1ZXJ5SW5mb3JtYXRpb25Qcm9jZXNzKFByb2Nlc3NCYXNpY0luZm9ybWF0aW9uKQAAAAAAAFJlYWRQcm9jZXNzTWVtb3J5AAAAAAAAAFJlYWRQcm9jZXNzTWVtb3J5AAAAAAAAAE50UXVlcnlJbmZvcm1hdGlvblByb2Nlc3MoUHJvY2Vzc1dvdzY0SW5mb3JtYXRpb24pAAAAAAAAJXMgLT4gRVJST1JfTk9BQ0NFU1MAAAAAVmlydHVhbFF1ZXJ5RXgAAE9wZW5Qcm9jZXNzAAAAAABhdXRvbWF0aWNhbGx5IHNldCBmb3IgUElEIDAAAAAAAEdldEV4aXRDb2RlUHJvY2VzcwAAAAAAAEdldEV4aXRDb2RlUHJvY2VzcyAtPiBFUlJPUl9BQ0NFU1NfREVOSUVEIChpZ25vcmVkKQAAAAAAR2V0RXhpdENvZGVQcm9jZXNzICE9IFNUSUxMX0FDVElWRQAAAAAAAE9wZW5Qcm9jZXNzAAAAAABPcGVuUHJvY2VzcyAtPiBFUlJPUl9TVUNDRVNTAAAAAE9wZW5Qcm9jZXNzIC0+IEVSUk9SX1NVQ0NFU1MgdHVybmVkIGludG8gTlNQAAAAAE9wZW5Qcm9jZXNzIC0+IEVSUk9SX1NVQ0NFU1MAAAAAT3BlblByb2Nlc3MgLT4gRVJST1JfU1VDQ0VTUyB0dXJuZWQgaW50byBBRAAAAAAAT3BlblByb2Nlc3MgLT4gRVJST1JfSU5WQUxJRF9QQVJBTUVURVIAAHBzdXRpbF9nZXRfcGlkcygpIGZhaWxlZAAAAAAAAAAAU2VEZWJ1Z1ByaXZpbGVnZQAAAAAAAAAAcHN1dGlsIG1vZHVsZSBjb3VsZG4ndCBzZXQgU0UgREVCVUcgbW9kZSBmb3IgdGhpcyBwcm9jZXNzOyBwbGVhc2UgZmlsZSBhbiBpc3N1ZSBhZ2FpbnN0IHBzdXRpbCBidWcgdHJhY2tlcgAAAAAAAE9wZW5Qcm9jZXNzVG9rZW4AAAAAAAAAAE9wZW5Qcm9jZXNzVG9rZW4AAAAAAAAAAEltcGVyc29uYXRlU2VsZgBBZGp1c3RUb2tlblByaXZpbGVnZXMAAABBZGp1c3RUb2tlblByaXZpbGVnZXMAAABMb29rdXBQcml2aWxlZ2VWYWx1ZQAAAABDb250cm9sU2VydmljZQAAU3RhcnRTZXJ2aWNlAAAAAFF1ZXJ5U2VydmljZUNvbmZpZzJXAAAAAFF1ZXJ5U2VydmljZUNvbmZpZzJXAAAAAChzaykAAAAAUXVlcnlTZXJ2aWNlU3RhdHVzRXgAAAAAUXVlcnlTZXJ2aWNlU3RhdHVzRXgAAAAAUXVlcnlTZXJ2aWNlQ29uZmlnVwAAAAAAUXVlcnlTZXJ2aWNlQ29uZmlnVwAoT08pAAAAAAAAAABPcGVuU0NNYW5hZ2VyAAAAdW5rbm93bgBzdG9wcGVkAHN0b3BfcGVuZGluZwAAAABjb250aW51ZV9wZW5kaW5nAAAAAAAAAABwYXVzZV9wZW5kaW5nAAAAc3RhcnRfcGVuZGluZwAAAHJ1bm5pbmcAdW5rbm93bgBkaXNhYmxlZAAAAAAAAAAAYXV0b21hdGljAAAAAAAAAE9wZW5TZXJ2aWNlAAAAAABPcGVuU0NNYW5hZ2VyAAAAKGlpaU5OaUkpAAAAKHNpKQAAAAAAAAAAKGlpaU5OaUkpAAAAKHNpKQAAAAAAAAAAKGlpaU5OaUkpAAAAKHNpKQAAAAAoc2kpAAAAAAAAAAAoaWlpTk5pSSkAAAAoc2kpAAAAAChzaSkAAAAAAAAAAHBzdXRpbF9waWRfaXNfcnVubmluZwAAAGFyZyAyIG9yIDMgaXMgbm90IGEgc2VxdWVuY2UAAAAAR2V0RXh0ZW5kZWRVZHBUYWJsZSBmYWlsZWQAAAAAAABHZXRFeHRlbmRlZFVkcFRhYmxlOiByZXRyeSB3aXRoIGRpZmZlcmVudCBidWZzaXplAAAAAAAAAEdldEV4dGVuZGVkVGNwVGFibGUgZmFpbGVkAAAAAAAAR2V0RXh0ZW5kZWRUY3BUYWJsZTogcmV0cnkgd2l0aCBkaWZmZXJlbnQgYnVmc2l6ZQAAAChkZGQpAAAAAAAAAEwAbwBhAGQAVQBwAGQAYQB0AGUARQB2AGUAbgB0AAAAXABTAHkAcwB0AGUAbQBcAFAAcgBvAGMAZQBzAHMAbwByACAAUQB1AGUAdQBlACAATABlAG4AZwB0AGgAAAAAAHWYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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"
            },
            "_pswindows": {
                "type": "module",
                "extension": "py",
                "code": "# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Windows platform implementation.\"\"\"\n\nimport contextlib\nimport errno\nimport functools\nimport os\nimport signal\nimport sys\nimport time\nfrom collections import namedtuple\n\nfrom . import _common\nfrom ._common import AccessDenied\nfrom ._common import conn_tmap\nfrom ._common import conn_to_ntuple\nfrom ._common import debug\nfrom ._common import ENCODING\nfrom ._common import ENCODING_ERRS\nfrom ._common import isfile_strict\nfrom ._common import memoize\nfrom ._common import memoize_when_activated\nfrom ._common import NoSuchProcess\nfrom ._common import parse_environ_block\nfrom ._common import TimeoutExpired\nfrom ._common import usage_percent\nfrom ._compat import long\nfrom ._compat import lru_cache\nfrom ._compat import PY3\nfrom ._compat import range\nfrom ._compat import unicode\nfrom ._psutil_windows import ABOVE_NORMAL_PRIORITY_CLASS\nfrom ._psutil_windows import BELOW_NORMAL_PRIORITY_CLASS\nfrom ._psutil_windows import HIGH_PRIORITY_CLASS\nfrom ._psutil_windows import IDLE_PRIORITY_CLASS\nfrom ._psutil_windows import NORMAL_PRIORITY_CLASS\nfrom ._psutil_windows import REALTIME_PRIORITY_CLASS\n\ntry:\n    from . import _psutil_windows as cext\nexcept ImportError as err:\n    if str(err).lower().startswith(\"dll load failed\") and \\\n            sys.getwindowsversion()[0] < 6:\n        # We may get here if:\n        # 1) we are on an old Windows version\n        # 2) psutil was installed via pip + wheel\n        # See: https://github.com/giampaolo/psutil/issues/811\n        msg = \"this Windows version is too old (< Windows Vista); \"\n        msg += \"psutil 3.4.2 is the latest version which supports Windows \"\n        msg += \"2000, XP and 2003 server\"\n        raise RuntimeError(msg)\n    else:\n        raise\n\nif sys.version_info >= (3, 4):\n    import enum\nelse:\n    enum = None\n\n# process priority constants, import from __init__.py:\n# http://msdn.microsoft.com/en-us/library/ms686219(v=vs.85).aspx\n__extra__all__ = [\n    \"win_service_iter\", \"win_service_get\",\n    # Process priority\n    \"ABOVE_NORMAL_PRIORITY_CLASS\", \"BELOW_NORMAL_PRIORITY_CLASS\",\n    \"HIGH_PRIORITY_CLASS\", \"IDLE_PRIORITY_CLASS\", \"NORMAL_PRIORITY_CLASS\",\n    \"REALTIME_PRIORITY_CLASS\",\n    # IO priority\n    \"IOPRIO_VERYLOW\", \"IOPRIO_LOW\", \"IOPRIO_NORMAL\", \"IOPRIO_HIGH\",\n    # others\n    \"CONN_DELETE_TCB\", \"AF_LINK\",\n]\n\n\n# =====================================================================\n# --- globals\n# =====================================================================\n\nCONN_DELETE_TCB = \"DELETE_TCB\"\nERROR_PARTIAL_COPY = 299\nPYPY = '__pypy__' in sys.builtin_module_names\n\nif enum is None:\n    AF_LINK = -1\nelse:\n    AddressFamily = enum.IntEnum('AddressFamily', {'AF_LINK': -1})\n    AF_LINK = AddressFamily.AF_LINK\n\nTCP_STATUSES = {\n    cext.MIB_TCP_STATE_ESTAB: _common.CONN_ESTABLISHED,\n    cext.MIB_TCP_STATE_SYN_SENT: _common.CONN_SYN_SENT,\n    cext.MIB_TCP_STATE_SYN_RCVD: _common.CONN_SYN_RECV,\n    cext.MIB_TCP_STATE_FIN_WAIT1: _common.CONN_FIN_WAIT1,\n    cext.MIB_TCP_STATE_FIN_WAIT2: _common.CONN_FIN_WAIT2,\n    cext.MIB_TCP_STATE_TIME_WAIT: _common.CONN_TIME_WAIT,\n    cext.MIB_TCP_STATE_CLOSED: _common.CONN_CLOSE,\n    cext.MIB_TCP_STATE_CLOSE_WAIT: _common.CONN_CLOSE_WAIT,\n    cext.MIB_TCP_STATE_LAST_ACK: _common.CONN_LAST_ACK,\n    cext.MIB_TCP_STATE_LISTEN: _common.CONN_LISTEN,\n    cext.MIB_TCP_STATE_CLOSING: _common.CONN_CLOSING,\n    cext.MIB_TCP_STATE_DELETE_TCB: CONN_DELETE_TCB,\n    cext.PSUTIL_CONN_NONE: _common.CONN_NONE,\n}\n\nif enum is not None:\n    class Priority(enum.IntEnum):\n        ABOVE_NORMAL_PRIORITY_CLASS = ABOVE_NORMAL_PRIORITY_CLASS\n        BELOW_NORMAL_PRIORITY_CLASS = BELOW_NORMAL_PRIORITY_CLASS\n        HIGH_PRIORITY_CLASS = HIGH_PRIORITY_CLASS\n        IDLE_PRIORITY_CLASS = IDLE_PRIORITY_CLASS\n        NORMAL_PRIORITY_CLASS = NORMAL_PRIORITY_CLASS\n        REALTIME_PRIORITY_CLASS = REALTIME_PRIORITY_CLASS\n\n    globals().update(Priority.__members__)\n\nif enum is None:\n    IOPRIO_VERYLOW = 0\n    IOPRIO_LOW = 1\n    IOPRIO_NORMAL = 2\n    IOPRIO_HIGH = 3\nelse:\n    class IOPriority(enum.IntEnum):\n        IOPRIO_VERYLOW = 0\n        IOPRIO_LOW = 1\n        IOPRIO_NORMAL = 2\n        IOPRIO_HIGH = 3\n    globals().update(IOPriority.__members__)\n\npinfo_map = dict(\n    num_handles=0,\n    ctx_switches=1,\n    user_time=2,\n    kernel_time=3,\n    create_time=4,\n    num_threads=5,\n    io_rcount=6,\n    io_wcount=7,\n    io_rbytes=8,\n    io_wbytes=9,\n    io_count_others=10,\n    io_bytes_others=11,\n    num_page_faults=12,\n    peak_wset=13,\n    wset=14,\n    peak_paged_pool=15,\n    paged_pool=16,\n    peak_non_paged_pool=17,\n    non_paged_pool=18,\n    pagefile=19,\n    peak_pagefile=20,\n    mem_private=21,\n)\n\n\n# =====================================================================\n# --- named tuples\n# =====================================================================\n\n\n# psutil.cpu_times()\nscputimes = namedtuple('scputimes',\n                       ['user', 'system', 'idle', 'interrupt', 'dpc'])\n# psutil.virtual_memory()\nsvmem = namedtuple('svmem', ['total', 'available', 'percent', 'used', 'free'])\n# psutil.Process.memory_info()\npmem = namedtuple(\n    'pmem', ['rss', 'vms',\n             'num_page_faults', 'peak_wset', 'wset', 'peak_paged_pool',\n             'paged_pool', 'peak_nonpaged_pool', 'nonpaged_pool',\n             'pagefile', 'peak_pagefile', 'private'])\n# psutil.Process.memory_full_info()\npfullmem = namedtuple('pfullmem', pmem._fields + ('uss', ))\n# psutil.Process.memory_maps(grouped=True)\npmmap_grouped = namedtuple('pmmap_grouped', ['path', 'rss'])\n# psutil.Process.memory_maps(grouped=False)\npmmap_ext = namedtuple(\n    'pmmap_ext', 'addr perms ' + ' '.join(pmmap_grouped._fields))\n# psutil.Process.io_counters()\npio = namedtuple('pio', ['read_count', 'write_count',\n                         'read_bytes', 'write_bytes',\n                         'other_count', 'other_bytes'])\n\n\n# =====================================================================\n# --- utils\n# =====================================================================\n\n\n@lru_cache(maxsize=512)\ndef convert_dos_path(s):\n    r\"\"\"Convert paths using native DOS format like:\n        \"\\Device\\HarddiskVolume1\\Windows\\systemew\\file.txt\"\n    into:\n        \"C:\\Windows\\systemew\\file.txt\"\n    \"\"\"\n    rawdrive = '\\\\'.join(s.split('\\\\')[:3])\n    driveletter = cext.win32_QueryDosDevice(rawdrive)\n    remainder = s[len(rawdrive):]\n    return os.path.join(driveletter, remainder)\n\n\ndef py2_strencode(s):\n    \"\"\"Encode a unicode string to a byte string by using the default fs\n    encoding + \"replace\" error handler.\n    \"\"\"\n    if PY3:\n        return s\n    else:\n        if isinstance(s, str):\n            return s\n        else:\n            return s.encode(ENCODING, ENCODING_ERRS)\n\n\n@memoize\ndef getpagesize():\n    return cext.getpagesize()\n\n\n# =====================================================================\n# --- memory\n# =====================================================================\n\n\ndef virtual_memory():\n    \"\"\"System virtual memory as a namedtuple.\"\"\"\n    mem = cext.virtual_mem()\n    totphys, availphys, totpagef, availpagef, totvirt, freevirt = mem\n    #\n    total = totphys\n    avail = availphys\n    free = availphys\n    used = total - avail\n    percent = usage_percent((total - avail), total, round_=1)\n    return svmem(total, avail, percent, used, free)\n\n\ndef swap_memory():\n    \"\"\"Swap system memory as a (total, used, free, sin, sout) tuple.\"\"\"\n    mem = cext.virtual_mem()\n    total = mem[2]\n    free = mem[3]\n    used = total - free\n    percent = usage_percent(used, total, round_=1)\n    return _common.sswap(total, used, free, percent, 0, 0)\n\n\n# =====================================================================\n# --- disk\n# =====================================================================\n\n\ndisk_io_counters = cext.disk_io_counters\n\n\ndef disk_usage(path):\n    \"\"\"Return disk usage associated with path.\"\"\"\n    if PY3 and isinstance(path, bytes):\n        # XXX: do we want to use \"strict\"? Probably yes, in order\n        # to fail immediately. After all we are accepting input here...\n        path = path.decode(ENCODING, errors=\"strict\")\n    total, free = cext.disk_usage(path)\n    used = total - free\n    percent = usage_percent(used, total, round_=1)\n    return _common.sdiskusage(total, used, free, percent)\n\n\ndef disk_partitions(all):\n    \"\"\"Return disk partitions.\"\"\"\n    rawlist = cext.disk_partitions(all)\n    return [_common.sdiskpart(*x) for x in rawlist]\n\n\n# =====================================================================\n# --- CPU\n# =====================================================================\n\n\ndef cpu_times():\n    \"\"\"Return system CPU times as a named tuple.\"\"\"\n    user, system, idle = cext.cpu_times()\n    # Internally, GetSystemTimes() is used, and it doesn't return\n    # interrupt and dpc times. cext.per_cpu_times() does, so we\n    # rely on it to get those only.\n    percpu_summed = scputimes(*[sum(n) for n in zip(*cext.per_cpu_times())])\n    return scputimes(user, system, idle,\n                     percpu_summed.interrupt, percpu_summed.dpc)\n\n\ndef per_cpu_times():\n    \"\"\"Return system per-CPU times as a list of named tuples.\"\"\"\n    ret = []\n    for user, system, idle, interrupt, dpc in cext.per_cpu_times():\n        item = scputimes(user, system, idle, interrupt, dpc)\n        ret.append(item)\n    return ret\n\n\ndef cpu_count_logical():\n    \"\"\"Return the number of logical CPUs in the system.\"\"\"\n    return cext.cpu_count_logical()\n\n\ndef cpu_count_physical():\n    \"\"\"Return the number of physical CPU cores in the system.\"\"\"\n    return cext.cpu_count_phys()\n\n\ndef cpu_stats():\n    \"\"\"Return CPU statistics.\"\"\"\n    ctx_switches, interrupts, dpcs, syscalls = cext.cpu_stats()\n    soft_interrupts = 0\n    return _common.scpustats(ctx_switches, interrupts, soft_interrupts,\n                             syscalls)\n\n\ndef cpu_freq():\n    \"\"\"Return CPU frequency.\n    On Windows per-cpu frequency is not supported.\n    \"\"\"\n    curr, max_ = cext.cpu_freq()\n    min_ = 0.0\n    return [_common.scpufreq(float(curr), min_, float(max_))]\n\n\n_loadavg_inititialized = False\n\n\ndef getloadavg():\n    \"\"\"Return the number of processes in the system run queue averaged\n    over the last 1, 5, and 15 minutes respectively as a tuple\"\"\"\n    global _loadavg_inititialized\n\n    if not _loadavg_inititialized:\n        cext.init_loadavg_counter()\n        _loadavg_inititialized = True\n\n    # Drop to 2 decimal points which is what Linux does\n    raw_loads = cext.getloadavg()\n    return tuple([round(load, 2) for load in raw_loads])\n\n\n# =====================================================================\n# --- network\n# =====================================================================\n\n\ndef net_connections(kind, _pid=-1):\n    \"\"\"Return socket connections.  If pid == -1 return system-wide\n    connections (as opposed to connections opened by one process only).\n    \"\"\"\n    if kind not in conn_tmap:\n        raise ValueError(\"invalid %r kind argument; choose between %s\"\n                         % (kind, ', '.join([repr(x) for x in conn_tmap])))\n    families, types = conn_tmap[kind]\n    rawlist = cext.net_connections(_pid, families, types)\n    ret = set()\n    for item in rawlist:\n        fd, fam, type, laddr, raddr, status, pid = item\n        nt = conn_to_ntuple(fd, fam, type, laddr, raddr, status, TCP_STATUSES,\n                            pid=pid if _pid == -1 else None)\n        ret.add(nt)\n    return list(ret)\n\n\ndef net_if_stats():\n    \"\"\"Get NIC stats (isup, duplex, speed, mtu).\"\"\"\n    ret = {}\n    rawdict = cext.net_if_stats()\n    for name, items in rawdict.items():\n        if not PY3:\n            assert isinstance(name, unicode), type(name)\n            name = py2_strencode(name)\n        isup, duplex, speed, mtu = items\n        if hasattr(_common, 'NicDuplex'):\n            duplex = _common.NicDuplex(duplex)\n        ret[name] = _common.snicstats(isup, duplex, speed, mtu)\n    return ret\n\n\ndef net_io_counters():\n    \"\"\"Return network I/O statistics for every network interface\n    installed on the system as a dict of raw tuples.\n    \"\"\"\n    ret = cext.net_io_counters()\n    return dict([(py2_strencode(k), v) for k, v in ret.items()])\n\n\ndef net_if_addrs():\n    \"\"\"Return the addresses associated to each NIC.\"\"\"\n    ret = []\n    for items in cext.net_if_addrs():\n        items = list(items)\n        items[0] = py2_strencode(items[0])\n        ret.append(items)\n    return ret\n\n\n# =====================================================================\n# --- sensors\n# =====================================================================\n\n\ndef sensors_battery():\n    \"\"\"Return battery information.\"\"\"\n    # For constants meaning see:\n    # https://msdn.microsoft.com/en-us/library/windows/desktop/\n    #     aa373232(v=vs.85).aspx\n    acline_status, flags, percent, secsleft = cext.sensors_battery()\n    power_plugged = acline_status == 1\n    no_battery = bool(flags & 128)\n    charging = bool(flags & 8)\n\n    if no_battery:\n        return None\n    if power_plugged or charging:\n        secsleft = _common.POWER_TIME_UNLIMITED\n    elif secsleft == -1:\n        secsleft = _common.POWER_TIME_UNKNOWN\n\n    return _common.sbattery(percent, secsleft, power_plugged)\n\n\n# =====================================================================\n# --- other system functions\n# =====================================================================\n\n\n_last_btime = 0\n\n\ndef boot_time():\n    \"\"\"The system boot time expressed in seconds since the epoch.\"\"\"\n    # This dirty hack is to adjust the precision of the returned\n    # value which may have a 1 second fluctuation, see:\n    # https://github.com/giampaolo/psutil/issues/1007\n    global _last_btime\n    ret = float(cext.boot_time())\n    if abs(ret - _last_btime) <= 1:\n        return _last_btime\n    else:\n        _last_btime = ret\n        return ret\n\n\ndef users():\n    \"\"\"Return currently connected users as a list of namedtuples.\"\"\"\n    retlist = []\n    rawlist = cext.users()\n    for item in rawlist:\n        user, hostname, tstamp = item\n        user = py2_strencode(user)\n        nt = _common.suser(user, None, hostname, tstamp, None)\n        retlist.append(nt)\n    return retlist\n\n\n# =====================================================================\n# --- Windows services\n# =====================================================================\n\n\ndef win_service_iter():\n    \"\"\"Yields a list of WindowsService instances.\"\"\"\n    for name, display_name in cext.winservice_enumerate():\n        yield WindowsService(py2_strencode(name), py2_strencode(display_name))\n\n\ndef win_service_get(name):\n    \"\"\"Open a Windows service and return it as a WindowsService instance.\"\"\"\n    service = WindowsService(name, None)\n    service._display_name = service._query_config()['display_name']\n    return service\n\n\nclass WindowsService(object):\n    \"\"\"Represents an installed Windows service.\"\"\"\n\n    def __init__(self, name, display_name):\n        self._name = name\n        self._display_name = display_name\n\n    def __str__(self):\n        details = \"(name=%r, display_name=%r)\" % (\n            self._name, self._display_name)\n        return \"%s%s\" % (self.__class__.__name__, details)\n\n    def __repr__(self):\n        return \"<%s at %s>\" % (self.__str__(), id(self))\n\n    def __eq__(self, other):\n        # Test for equality with another WindosService object based\n        # on name.\n        if not isinstance(other, WindowsService):\n            return NotImplemented\n        return self._name == other._name\n\n    def __ne__(self, other):\n        return not self == other\n\n    def _query_config(self):\n        with self._wrap_exceptions():\n            display_name, binpath, username, start_type = \\\n                cext.winservice_query_config(self._name)\n        # XXX - update _self.display_name?\n        return dict(\n            display_name=py2_strencode(display_name),\n            binpath=py2_strencode(binpath),\n            username=py2_strencode(username),\n            start_type=py2_strencode(start_type))\n\n    def _query_status(self):\n        with self._wrap_exceptions():\n            status, pid = cext.winservice_query_status(self._name)\n        if pid == 0:\n            pid = None\n        return dict(status=status, pid=pid)\n\n    @contextlib.contextmanager\n    def _wrap_exceptions(self):\n        \"\"\"Ctx manager which translates bare OSError and WindowsError\n        exceptions into NoSuchProcess and AccessDenied.\n        \"\"\"\n        try:\n            yield\n        except OSError as err:\n            if is_permission_err(err):\n                raise AccessDenied(\n                    pid=None, name=self._name,\n                    msg=\"service %r is not querable (not enough privileges)\" %\n                        self._name)\n            elif err.winerror in (cext.ERROR_INVALID_NAME,\n                                  cext.ERROR_SERVICE_DOES_NOT_EXIST):\n                raise NoSuchProcess(\n                    pid=None, name=self._name,\n                    msg=\"service %r does not exist)\" % self._name)\n            else:\n                raise\n\n    # config query\n\n    def name(self):\n        \"\"\"The service name. This string is how a service is referenced\n        and can be passed to win_service_get() to get a new\n        WindowsService instance.\n        \"\"\"\n        return self._name\n\n    def display_name(self):\n        \"\"\"The service display name. The value is cached when this class\n        is instantiated.\n        \"\"\"\n        return self._display_name\n\n    def binpath(self):\n        \"\"\"The fully qualified path to the service binary/exe file as\n        a string, including command line arguments.\n        \"\"\"\n        return self._query_config()['binpath']\n\n    def username(self):\n        \"\"\"The name of the user that owns this service.\"\"\"\n        return self._query_config()['username']\n\n    def start_type(self):\n        \"\"\"A string which can either be \"automatic\", \"manual\" or\n        \"disabled\".\n        \"\"\"\n        return self._query_config()['start_type']\n\n    # status query\n\n    def pid(self):\n        \"\"\"The process PID, if any, else None. This can be passed\n        to Process class to control the service's process.\n        \"\"\"\n        return self._query_status()['pid']\n\n    def status(self):\n        \"\"\"Service status as a string.\"\"\"\n        return self._query_status()['status']\n\n    def description(self):\n        \"\"\"Service long description.\"\"\"\n        return py2_strencode(cext.winservice_query_descr(self.name()))\n\n    # utils\n\n    def as_dict(self):\n        \"\"\"Utility method retrieving all the information above as a\n        dictionary.\n        \"\"\"\n        d = self._query_config()\n        d.update(self._query_status())\n        d['name'] = self.name()\n        d['display_name'] = self.display_name()\n        d['description'] = self.description()\n        return d\n\n    # actions\n    # XXX: the necessary C bindings for start() and stop() are\n    # implemented but for now I prefer not to expose them.\n    # I may change my mind in the future. Reasons:\n    # - they require Administrator privileges\n    # - can't implement a timeout for stop() (unless by using a thread,\n    #   which sucks)\n    # - would require adding ServiceAlreadyStarted and\n    #   ServiceAlreadyStopped exceptions, adding two new APIs.\n    # - we might also want to have modify(), which would basically mean\n    #   rewriting win32serviceutil.ChangeServiceConfig, which involves a\n    #   lot of stuff (and API constants which would pollute the API), see:\n    #   http://pyxr.sourceforge.net/PyXR/c/python24/lib/site-packages/\n    #       win32/lib/win32serviceutil.py.html#0175\n    # - psutil is typically about \"read only\" monitoring stuff;\n    #   win_service_* APIs should only be used to retrieve a service and\n    #   check whether it's running\n\n    # def start(self, timeout=None):\n    #     with self._wrap_exceptions():\n    #         cext.winservice_start(self.name())\n    #         if timeout:\n    #             giveup_at = time.time() + timeout\n    #             while True:\n    #                 if self.status() == \"running\":\n    #                     return\n    #                 else:\n    #                     if time.time() > giveup_at:\n    #                         raise TimeoutExpired(timeout)\n    #                     else:\n    #                         time.sleep(.1)\n\n    # def stop(self):\n    #     # Note: timeout is not implemented because it's just not\n    #     # possible, see:\n    #     # http://stackoverflow.com/questions/11973228/\n    #     with self._wrap_exceptions():\n    #         return cext.winservice_stop(self.name())\n\n\n# =====================================================================\n# --- processes\n# =====================================================================\n\n\npids = cext.pids\npid_exists = cext.pid_exists\nppid_map = cext.ppid_map  # used internally by Process.children()\n\n\ndef is_permission_err(exc):\n    \"\"\"Return True if this is a permission error.\"\"\"\n    assert isinstance(exc, OSError), exc\n    # On Python 2 OSError doesn't always have 'winerror'. Sometimes\n    # it does, in which case the original exception was WindowsError\n    # (which is a subclass of OSError).\n    return exc.errno in (errno.EPERM, errno.EACCES) or \\\n        getattr(exc, \"winerror\", -1) in (cext.ERROR_ACCESS_DENIED,\n                                         cext.ERROR_PRIVILEGE_NOT_HELD)\n\n\ndef convert_oserror(exc, pid=None, name=None):\n    \"\"\"Convert OSError into NoSuchProcess or AccessDenied.\"\"\"\n    assert isinstance(exc, OSError), exc\n    if is_permission_err(exc):\n        return AccessDenied(pid=pid, name=name)\n    if exc.errno == errno.ESRCH:\n        return NoSuchProcess(pid=pid, name=name)\n    raise exc\n\n\ndef wrap_exceptions(fun):\n    \"\"\"Decorator which converts OSError into NoSuchProcess or AccessDenied.\"\"\"\n    @functools.wraps(fun)\n    def wrapper(self, *args, **kwargs):\n        try:\n            return fun(self, *args, **kwargs)\n        except OSError as err:\n            raise convert_oserror(err, pid=self.pid, name=self._name)\n    return wrapper\n\n\ndef retry_error_partial_copy(fun):\n    \"\"\"Workaround for https://github.com/giampaolo/psutil/issues/875.\n    See: https://stackoverflow.com/questions/4457745#4457745\n    \"\"\"\n    @functools.wraps(fun)\n    def wrapper(self, *args, **kwargs):\n        delay = 0.0001\n        times = 33\n        for x in range(times):  # retries for roughly 1 second\n            try:\n                return fun(self, *args, **kwargs)\n            except WindowsError as _:\n                err = _\n                if err.winerror == ERROR_PARTIAL_COPY:\n                    time.sleep(delay)\n                    delay = min(delay * 2, 0.04)\n                    continue\n                else:\n                    raise\n        else:\n            msg = \"%s retried %s times, converted to AccessDenied as it's \" \\\n                \"still returning %r\" % (fun, times, err)\n            raise AccessDenied(pid=self.pid, name=self._name, msg=msg)\n    return wrapper\n\n\nclass Process(object):\n    \"\"\"Wrapper class around underlying C implementation.\"\"\"\n\n    __slots__ = [\"pid\", \"_name\", \"_ppid\", \"_cache\"]\n\n    def __init__(self, pid):\n        self.pid = pid\n        self._name = None\n        self._ppid = None\n\n    # --- oneshot() stuff\n\n    def oneshot_enter(self):\n        self._proc_info.cache_activate(self)\n        self.exe.cache_activate(self)\n\n    def oneshot_exit(self):\n        self._proc_info.cache_deactivate(self)\n        self.exe.cache_deactivate(self)\n\n    @memoize_when_activated\n    def _proc_info(self):\n        \"\"\"Return multiple information about this process as a\n        raw tuple.\n        \"\"\"\n        ret = cext.proc_info(self.pid)\n        assert len(ret) == len(pinfo_map)\n        return ret\n\n    def name(self):\n        \"\"\"Return process name, which on Windows is always the final\n        part of the executable.\n        \"\"\"\n        # This is how PIDs 0 and 4 are always represented in taskmgr\n        # and process-hacker.\n        if self.pid == 0:\n            return \"System Idle Process\"\n        if self.pid == 4:\n            return \"System\"\n        return os.path.basename(self.exe())\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def exe(self):\n        if PYPY:\n            try:\n                exe = cext.proc_exe(self.pid)\n            except WindowsError as err:\n                # 24 = ERROR_TOO_MANY_OPEN_FILES. Not sure why this happens\n                # (perhaps PyPy's JIT delaying garbage collection of files?).\n                if err.errno == 24:\n                    debug(\"%r forced into AccessDenied\" % err)\n                    raise AccessDenied(self.pid, self._name)\n                raise\n        else:\n            exe = cext.proc_exe(self.pid)\n        if not PY3:\n            exe = py2_strencode(exe)\n        if exe.startswith('\\\\'):\n            return convert_dos_path(exe)\n        return exe  # May be \"Registry\", \"MemCompression\", ...\n\n    @wrap_exceptions\n    @retry_error_partial_copy\n    def cmdline(self):\n        if cext.WINVER >= cext.WINDOWS_8_1:\n            # PEB method detects cmdline changes but requires more\n            # privileges: https://github.com/giampaolo/psutil/pull/1398\n            try:\n                ret = cext.proc_cmdline(self.pid, use_peb=True)\n            except OSError as err:\n                if is_permission_err(err):\n                    ret = cext.proc_cmdline(self.pid, use_peb=False)\n                else:\n                    raise\n        else:\n            ret = cext.proc_cmdline(self.pid, use_peb=True)\n        if PY3:\n            return ret\n        else:\n            return [py2_strencode(s) for s in ret]\n\n    @wrap_exceptions\n    @retry_error_partial_copy\n    def environ(self):\n        ustr = cext.proc_environ(self.pid)\n        if ustr and not PY3:\n            assert isinstance(ustr, unicode), type(ustr)\n        return parse_environ_block(py2_strencode(ustr))\n\n    def ppid(self):\n        try:\n            return ppid_map()[self.pid]\n        except KeyError:\n            raise NoSuchProcess(self.pid, self._name)\n\n    def _get_raw_meminfo(self):\n        try:\n            return cext.proc_memory_info(self.pid)\n        except OSError as err:\n            if is_permission_err(err):\n                # TODO: the C ext can probably be refactored in order\n                # to get this from cext.proc_info()\n                info = self._proc_info()\n                return (\n                    info[pinfo_map['num_page_faults']],\n                    info[pinfo_map['peak_wset']],\n                    info[pinfo_map['wset']],\n                    info[pinfo_map['peak_paged_pool']],\n                    info[pinfo_map['paged_pool']],\n                    info[pinfo_map['peak_non_paged_pool']],\n                    info[pinfo_map['non_paged_pool']],\n                    info[pinfo_map['pagefile']],\n                    info[pinfo_map['peak_pagefile']],\n                    info[pinfo_map['mem_private']],\n                )\n            raise\n\n    @wrap_exceptions\n    def memory_info(self):\n        # on Windows RSS == WorkingSetSize and VSM == PagefileUsage.\n        # Underlying C function returns fields of PROCESS_MEMORY_COUNTERS\n        # struct.\n        t = self._get_raw_meminfo()\n        rss = t[2]  # wset\n        vms = t[7]  # pagefile\n        return pmem(*(rss, vms, ) + t)\n\n    @wrap_exceptions\n    def memory_full_info(self):\n        basic_mem = self.memory_info()\n        uss = cext.proc_memory_uss(self.pid)\n        uss *= getpagesize()\n        return pfullmem(*basic_mem + (uss, ))\n\n    def memory_maps(self):\n        try:\n            raw = cext.proc_memory_maps(self.pid)\n        except OSError as err:\n            # XXX - can't use wrap_exceptions decorator as we're\n            # returning a generator; probably needs refactoring.\n            raise convert_oserror(err, self.pid, self._name)\n        else:\n            for addr, perm, path, rss in raw:\n                path = convert_dos_path(path)\n                if not PY3:\n                    path = py2_strencode(path)\n                addr = hex(addr)\n                yield (addr, perm, path, rss)\n\n    @wrap_exceptions\n    def kill(self):\n        return cext.proc_kill(self.pid)\n\n    @wrap_exceptions\n    def send_signal(self, sig):\n        if sig == signal.SIGTERM:\n            cext.proc_kill(self.pid)\n        # py >= 2.7\n        elif sig in (getattr(signal, \"CTRL_C_EVENT\", object()),\n                     getattr(signal, \"CTRL_BREAK_EVENT\", object())):\n            os.kill(self.pid, sig)\n        else:\n            raise ValueError(\n                \"only SIGTERM, CTRL_C_EVENT and CTRL_BREAK_EVENT signals \"\n                \"are supported on Windows\")\n\n    @wrap_exceptions\n    def wait(self, timeout=None):\n        if timeout is None:\n            cext_timeout = cext.INFINITE\n        else:\n            # WaitForSingleObject() expects time in milliseconds.\n            cext_timeout = int(timeout * 1000)\n\n        timer = getattr(time, 'monotonic', time.time)\n        stop_at = timer() + timeout if timeout is not None else None\n\n        try:\n            # Exit code is supposed to come from GetExitCodeProcess().\n            # May also be None if OpenProcess() failed with\n            # ERROR_INVALID_PARAMETER, meaning PID is already gone.\n            exit_code = cext.proc_wait(self.pid, cext_timeout)\n        except cext.TimeoutExpired:\n            # WaitForSingleObject() returned WAIT_TIMEOUT. Just raise.\n            raise TimeoutExpired(timeout, self.pid, self._name)\n        except cext.TimeoutAbandoned:\n            # WaitForSingleObject() returned WAIT_ABANDONED, see:\n            # https://github.com/giampaolo/psutil/issues/1224\n            # We'll just rely on the internal polling and return None\n            # when the PID disappears. Subprocess module does the same\n            # (return None):\n            # https://github.com/python/cpython/blob/\n            #     be50a7b627d0aa37e08fa8e2d5568891f19903ce/\n            #     Lib/subprocess.py#L1193-L1194\n            exit_code = None\n\n        # At this point WaitForSingleObject() returned WAIT_OBJECT_0,\n        # meaning the process is gone. Stupidly there are cases where\n        # its PID may still stick around so we do a further internal\n        # polling.\n        delay = 0.0001\n        while True:\n            if not pid_exists(self.pid):\n                return exit_code\n            if stop_at and timer() >= stop_at:\n                raise TimeoutExpired(timeout, pid=self.pid, name=self._name)\n            time.sleep(delay)\n            delay = min(delay * 2, 0.04)  # incremental delay\n\n    @wrap_exceptions\n    def username(self):\n        if self.pid in (0, 4):\n            return 'NT AUTHORITY\\\\SYSTEM'\n        domain, user = cext.proc_username(self.pid)\n        return py2_strencode(domain) + '\\\\' + py2_strencode(user)\n\n    @wrap_exceptions\n    def create_time(self):\n        # Note: proc_times() not put under oneshot() 'cause create_time()\n        # is already cached by the main Process class.\n        try:\n            user, system, created = cext.proc_times(self.pid)\n            return created\n        except OSError as err:\n            if is_permission_err(err):\n                return self._proc_info()[pinfo_map['create_time']]\n            raise\n\n    @wrap_exceptions\n    def num_threads(self):\n        return self._proc_info()[pinfo_map['num_threads']]\n\n    @wrap_exceptions\n    def threads(self):\n        rawlist = cext.proc_threads(self.pid)\n        retlist = []\n        for thread_id, utime, stime in rawlist:\n            ntuple = _common.pthread(thread_id, utime, stime)\n            retlist.append(ntuple)\n        return retlist\n\n    @wrap_exceptions\n    def cpu_times(self):\n        try:\n            user, system, created = cext.proc_times(self.pid)\n        except OSError as err:\n            if not is_permission_err(err):\n                raise\n            info = self._proc_info()\n            user = info[pinfo_map['user_time']]\n            system = info[pinfo_map['kernel_time']]\n        # Children user/system times are not retrievable (set to 0).\n        return _common.pcputimes(user, system, 0.0, 0.0)\n\n    @wrap_exceptions\n    def suspend(self):\n        cext.proc_suspend_or_resume(self.pid, True)\n\n    @wrap_exceptions\n    def resume(self):\n        cext.proc_suspend_or_resume(self.pid, False)\n\n    @wrap_exceptions\n    @retry_error_partial_copy\n    def cwd(self):\n        if self.pid in (0, 4):\n            raise AccessDenied(self.pid, self._name)\n        # return a normalized pathname since the native C function appends\n        # \"\\\\\" at the and of the path\n        path = cext.proc_cwd(self.pid)\n        return py2_strencode(os.path.normpath(path))\n\n    @wrap_exceptions\n    def open_files(self):\n        if self.pid in (0, 4):\n            return []\n        ret = set()\n        # Filenames come in in native format like:\n        # \"\\Device\\HarddiskVolume1\\Windows\\systemew\\file.txt\"\n        # Convert the first part in the corresponding drive letter\n        # (e.g. \"C:\\\") by using Windows's QueryDosDevice()\n        raw_file_names = cext.proc_open_files(self.pid)\n        for _file in raw_file_names:\n            _file = convert_dos_path(_file)\n            if isfile_strict(_file):\n                if not PY3:\n                    _file = py2_strencode(_file)\n                ntuple = _common.popenfile(_file, -1)\n                ret.add(ntuple)\n        return list(ret)\n\n    @wrap_exceptions\n    def connections(self, kind='inet'):\n        return net_connections(kind, _pid=self.pid)\n\n    @wrap_exceptions\n    def nice_get(self):\n        value = cext.proc_priority_get(self.pid)\n        if enum is not None:\n            value = Priority(value)\n        return value\n\n    @wrap_exceptions\n    def nice_set(self, value):\n        return cext.proc_priority_set(self.pid, value)\n\n    @wrap_exceptions\n    def ionice_get(self):\n        ret = cext.proc_io_priority_get(self.pid)\n        if enum is not None:\n            ret = IOPriority(ret)\n        return ret\n\n    @wrap_exceptions\n    def ionice_set(self, ioclass, value):\n        if value:\n            raise TypeError(\"value argument not accepted on Windows\")\n        if ioclass not in (IOPRIO_VERYLOW, IOPRIO_LOW, IOPRIO_NORMAL,\n                           IOPRIO_HIGH):\n            raise ValueError(\"%s is not a valid priority\" % ioclass)\n        cext.proc_io_priority_set(self.pid, ioclass)\n\n    @wrap_exceptions\n    def io_counters(self):\n        try:\n            ret = cext.proc_io_counters(self.pid)\n        except OSError as err:\n            if not is_permission_err(err):\n                raise\n            info = self._proc_info()\n            ret = (\n                info[pinfo_map['io_rcount']],\n                info[pinfo_map['io_wcount']],\n                info[pinfo_map['io_rbytes']],\n                info[pinfo_map['io_wbytes']],\n                info[pinfo_map['io_count_others']],\n                info[pinfo_map['io_bytes_others']],\n            )\n        return pio(*ret)\n\n    @wrap_exceptions\n    def status(self):\n        suspended = cext.proc_is_suspended(self.pid)\n        if suspended:\n            return _common.STATUS_STOPPED\n        else:\n            return _common.STATUS_RUNNING\n\n    @wrap_exceptions\n    def cpu_affinity_get(self):\n        def from_bitmask(x):\n            return [i for i in range(64) if (1 << i) & x]\n        bitmask = cext.proc_cpu_affinity_get(self.pid)\n        return from_bitmask(bitmask)\n\n    @wrap_exceptions\n    def cpu_affinity_set(self, value):\n        def to_bitmask(ls):\n            if not ls:\n                raise ValueError(\"invalid argument %r\" % ls)\n            out = 0\n            for b in ls:\n                out |= 2 ** b\n            return out\n\n        # SetProcessAffinityMask() states that ERROR_INVALID_PARAMETER\n        # is returned for an invalid CPU but this seems not to be true,\n        # therefore we check CPUs validy beforehand.\n        allcpus = list(range(len(per_cpu_times())))\n        for cpu in value:\n            if cpu not in allcpus:\n                if not isinstance(cpu, (int, long)):\n                    raise TypeError(\n                        \"invalid CPU %r; an integer is required\" % cpu)\n                else:\n                    raise ValueError(\"invalid CPU %r\" % cpu)\n\n        bitmask = to_bitmask(value)\n        cext.proc_cpu_affinity_set(self.pid, bitmask)\n\n    @wrap_exceptions\n    def num_handles(self):\n        try:\n            return cext.proc_num_handles(self.pid)\n        except OSError as err:\n            if is_permission_err(err):\n                return self._proc_info()[pinfo_map['num_handles']]\n            raise\n\n    @wrap_exceptions\n    def num_ctx_switches(self):\n        ctx_switches = self._proc_info()[pinfo_map['ctx_switches']]\n        # only voluntary ctx switches are supported\n        return _common.pctxsw(ctx_switches, 0)\n"
            },
            "tests": {
                "type": "package",
                "extension": "py",
                "code": "# -*- coding: utf-8 -*-\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"\nTest utilities.\n\"\"\"\n\nfrom __future__ import print_function\nimport atexit\nimport contextlib\nimport ctypes\nimport errno\nimport functools\nimport gc\nimport inspect\nimport os\nimport random\nimport re\nimport select\nimport shutil\nimport signal\nimport socket\nimport stat\nimport subprocess\nimport sys\nimport tempfile\nimport textwrap\nimport threading\nimport time\nimport warnings\nfrom socket import AF_INET\nfrom socket import AF_INET6\nfrom socket import SOCK_STREAM\n\nimport psutil\nfrom psutil import AIX\nfrom psutil import FREEBSD\nfrom psutil import LINUX\nfrom psutil import MACOS\nfrom psutil import POSIX\nfrom psutil import SUNOS\nfrom psutil import WINDOWS\nfrom psutil._common import bytes2human\nfrom psutil._common import print_color\nfrom psutil._common import supports_ipv6\nfrom psutil._compat import FileExistsError\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import PY3\nfrom psutil._compat import range\nfrom psutil._compat import super\nfrom psutil._compat import u\nfrom psutil._compat import unicode\nfrom psutil._compat import which\n\nif PY3:\n    import unittest\nelse:\n    import unittest2 as unittest  # requires \"pip install unittest2\"\n\ntry:\n    from unittest import mock  # py3\nexcept ImportError:\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        import mock  # NOQA - requires \"pip install mock\"\n\nif sys.version_info >= (3, 4):\n    import enum\nelse:\n    enum = None\n\n\n__all__ = [\n    # constants\n    'APPVEYOR', 'DEVNULL', 'GLOBAL_TIMEOUT', 'TOLERANCE_SYS_MEM', 'NO_RETRIES',\n    'PYPY', 'PYTHON_EXE', 'ROOT_DIR', 'SCRIPTS_DIR', 'TESTFN_PREFIX',\n    'UNICODE_SUFFIX', 'INVALID_UNICODE_SUFFIX',\n    'CI_TESTING', 'VALID_PROC_STATUSES', 'TOLERANCE_DISK_USAGE', 'IS_64BIT',\n    \"HAS_CPU_AFFINITY\", \"HAS_CPU_FREQ\", \"HAS_ENVIRON\", \"HAS_PROC_IO_COUNTERS\",\n    \"HAS_IONICE\", \"HAS_MEMORY_MAPS\", \"HAS_PROC_CPU_NUM\", \"HAS_RLIMIT\",\n    \"HAS_SENSORS_BATTERY\", \"HAS_BATTERY\", \"HAS_SENSORS_FANS\",\n    \"HAS_SENSORS_TEMPERATURES\", \"HAS_MEMORY_FULL_INFO\",\n    # subprocesses\n    'pyrun', 'terminate', 'reap_children', 'spawn_testproc', 'spawn_zombie',\n    'spawn_children_pair',\n    # threads\n    'ThreadTask'\n    # test utils\n    'unittest', 'skip_on_access_denied', 'skip_on_not_implemented',\n    'retry_on_failure', 'TestMemoryLeak', 'PsutilTestCase',\n    'process_namespace', 'system_namespace', 'print_sysinfo',\n    # install utils\n    'install_pip', 'install_test_deps',\n    # fs utils\n    'chdir', 'safe_rmpath', 'create_exe', 'decode_path', 'encode_path',\n    'get_testfn',\n    # os\n    'get_winver', 'kernel_version',\n    # sync primitives\n    'call_until', 'wait_for_pid', 'wait_for_file',\n    # network\n    'check_net_address',\n    'get_free_port', 'bind_socket', 'bind_unix_socket', 'tcp_socketpair',\n    'unix_socketpair', 'create_sockets',\n    # compat\n    'reload_module', 'import_module_by_path',\n    # others\n    'warn', 'copyload_shared_lib', 'is_namedtuple',\n]\n\n\n# ===================================================================\n# --- constants\n# ===================================================================\n\n# --- platforms\n\nPYPY = '__pypy__' in sys.builtin_module_names\n# whether we're running this test suite on a Continuous Integration service\nAPPVEYOR = 'APPVEYOR' in os.environ\nGITHUB_ACTIONS = 'GITHUB_ACTIONS' in os.environ or 'CIBUILDWHEEL' in os.environ\nCI_TESTING = APPVEYOR or GITHUB_ACTIONS\n# are we a 64 bit process?\nIS_64BIT = sys.maxsize > 2 ** 32\n\n\n# --- configurable defaults\n\n# how many times retry_on_failure() decorator will retry\nNO_RETRIES = 10\n# bytes tolerance for system-wide related tests\nTOLERANCE_SYS_MEM = 5 * 1024 * 1024  # 5MB\nTOLERANCE_DISK_USAGE = 10 * 1024 * 1024  # 10MB\n# the timeout used in functions which have to wait\nGLOBAL_TIMEOUT = 5\n# be more tolerant if we're on CI in order to avoid false positives\nif CI_TESTING:\n    NO_RETRIES *= 3\n    GLOBAL_TIMEOUT *= 3\n    TOLERANCE_SYS_MEM *= 3\n    TOLERANCE_DISK_USAGE *= 3\n\n# --- file names\n\n# Disambiguate TESTFN for parallel testing.\nif os.name == 'java':\n    # Jython disallows @ in module names\n    TESTFN_PREFIX = '$psutil-%s-' % os.getpid()\nelse:\n    TESTFN_PREFIX = '@psutil-%s-' % os.getpid()\nUNICODE_SUFFIX = u(\"-\u0192\u0151\u0151\")\n# An invalid unicode string.\nif PY3:\n    INVALID_UNICODE_SUFFIX = b\"f\\xc0\\x80\".decode('utf8', 'surrogateescape')\nelse:\n    INVALID_UNICODE_SUFFIX = \"f\\xc0\\x80\"\nASCII_FS = sys.getfilesystemencoding().lower() in ('ascii', 'us-ascii')\n\n# --- paths\n\nROOT_DIR = os.path.realpath(\n    os.path.join(os.path.dirname(__file__), '..', '..'))\nSCRIPTS_DIR = os.path.join(ROOT_DIR, 'scripts')\nHERE = os.path.realpath(os.path.dirname(__file__))\n\n# --- support\n\nHAS_CONNECTIONS_UNIX = POSIX and not SUNOS\nHAS_CPU_AFFINITY = hasattr(psutil.Process, \"cpu_affinity\")\nHAS_CPU_FREQ = hasattr(psutil, \"cpu_freq\")\nHAS_GETLOADAVG = hasattr(psutil, \"getloadavg\")\nHAS_ENVIRON = hasattr(psutil.Process, \"environ\")\nHAS_IONICE = hasattr(psutil.Process, \"ionice\")\nHAS_MEMORY_MAPS = hasattr(psutil.Process, \"memory_maps\")\nHAS_NET_IO_COUNTERS = hasattr(psutil, \"net_io_counters\")\nHAS_PROC_CPU_NUM = hasattr(psutil.Process, \"cpu_num\")\nHAS_PROC_IO_COUNTERS = hasattr(psutil.Process, \"io_counters\")\nHAS_RLIMIT = hasattr(psutil.Process, \"rlimit\")\nHAS_SENSORS_BATTERY = hasattr(psutil, \"sensors_battery\")\ntry:\n    HAS_BATTERY = HAS_SENSORS_BATTERY and bool(psutil.sensors_battery())\nexcept Exception:\n    HAS_BATTERY = False\nHAS_SENSORS_FANS = hasattr(psutil, \"sensors_fans\")\nHAS_SENSORS_TEMPERATURES = hasattr(psutil, \"sensors_temperatures\")\nHAS_THREADS = hasattr(psutil.Process, \"threads\")\nSKIP_SYSCONS = (MACOS or AIX) and os.getuid() != 0\n\n# --- misc\n\n\ndef _get_py_exe():\n    def attempt(exe):\n        try:\n            subprocess.check_call(\n                [exe, \"-V\"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        except Exception:\n            return None\n        else:\n            return exe\n\n    if GITHUB_ACTIONS:\n        if PYPY:\n            return which(\"pypy3\") if PY3 else which(\"pypy\")\n        elif FREEBSD:\n            return os.path.realpath(sys.executable)\n        else:\n            return which('python')\n    elif MACOS:\n        exe = \\\n            attempt(sys.executable) or \\\n            attempt(os.path.realpath(sys.executable)) or \\\n            attempt(which(\"python%s.%s\" % sys.version_info[:2])) or \\\n            attempt(psutil.Process().exe())\n        if not exe:\n            raise ValueError(\"can't find python exe real abspath\")\n        return exe\n    else:\n        exe = os.path.realpath(sys.executable)\n        assert os.path.exists(exe), exe\n        return exe\n\n\nPYTHON_EXE = _get_py_exe()\nDEVNULL = open(os.devnull, 'r+')\natexit.register(DEVNULL.close)\n\nVALID_PROC_STATUSES = [getattr(psutil, x) for x in dir(psutil)\n                       if x.startswith('STATUS_')]\nAF_UNIX = getattr(socket, \"AF_UNIX\", object())\n\n_subprocesses_started = set()\n_pids_started = set()\n\n\n# ===================================================================\n# --- threads\n# ===================================================================\n\n\nclass ThreadTask(threading.Thread):\n    \"\"\"A thread task which does nothing expect staying alive.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._running = False\n        self._interval = 0.001\n        self._flag = threading.Event()\n\n    def __repr__(self):\n        name = self.__class__.__name__\n        return '<%s running=%s at %#x>' % (name, self._running, id(self))\n\n    def __enter__(self):\n        self.start()\n        return self\n\n    def __exit__(self, *args, **kwargs):\n        self.stop()\n\n    def start(self):\n        \"\"\"Start thread and keep it running until an explicit\n        stop() request. Polls for shutdown every 'timeout' seconds.\n        \"\"\"\n        if self._running:\n            raise ValueError(\"already started\")\n        threading.Thread.start(self)\n        self._flag.wait()\n\n    def run(self):\n        self._running = True\n        self._flag.set()\n        while self._running:\n            time.sleep(self._interval)\n\n    def stop(self):\n        \"\"\"Stop thread execution and and waits until it is stopped.\"\"\"\n        if not self._running:\n            raise ValueError(\"already stopped\")\n        self._running = False\n        self.join()\n\n\n# ===================================================================\n# --- subprocesses\n# ===================================================================\n\n\ndef _reap_children_on_err(fun):\n    @functools.wraps(fun)\n    def wrapper(*args, **kwargs):\n        try:\n            return fun(*args, **kwargs)\n        except Exception:\n            reap_children()\n            raise\n    return wrapper\n\n\n@_reap_children_on_err\ndef spawn_testproc(cmd=None, **kwds):\n    \"\"\"Creates a python subprocess which does nothing for 60 secs and\n    return it as a subprocess.Popen instance.\n    If \"cmd\" is specified that is used instead of python.\n    By default stdin and stdout are redirected to /dev/null.\n    It also attemps to make sure the process is in a reasonably\n    initialized state.\n    The process is registered for cleanup on reap_children().\n    \"\"\"\n    kwds.setdefault(\"stdin\", DEVNULL)\n    kwds.setdefault(\"stdout\", DEVNULL)\n    kwds.setdefault(\"cwd\", os.getcwd())\n    kwds.setdefault(\"env\", os.environ)\n    if WINDOWS:\n        # Prevents the subprocess to open error dialogs. This will also\n        # cause stderr to be suppressed, which is suboptimal in order\n        # to debug broken tests.\n        CREATE_NO_WINDOW = 0x8000000\n        kwds.setdefault(\"creationflags\", CREATE_NO_WINDOW)\n    if cmd is None:\n        testfn = get_testfn()\n        try:\n            safe_rmpath(testfn)\n            pyline = \"from time import sleep;\" \\\n                     \"open(r'%s', 'w').close();\" \\\n                     \"sleep(60);\" % testfn\n            cmd = [PYTHON_EXE, \"-c\", pyline]\n            sproc = subprocess.Popen(cmd, **kwds)\n            _subprocesses_started.add(sproc)\n            wait_for_file(testfn, delete=True, empty=True)\n        finally:\n            safe_rmpath(testfn)\n    else:\n        sproc = subprocess.Popen(cmd, **kwds)\n        _subprocesses_started.add(sproc)\n        wait_for_pid(sproc.pid)\n    return sproc\n\n\n@_reap_children_on_err\ndef spawn_children_pair():\n    \"\"\"Create a subprocess which creates another one as in:\n    A (us) -> B (child) -> C (grandchild).\n    Return a (child, grandchild) tuple.\n    The 2 processes are fully initialized and will live for 60 secs\n    and are registered for cleanup on reap_children().\n    \"\"\"\n    tfile = None\n    testfn = get_testfn(dir=os.getcwd())\n    try:\n        s = textwrap.dedent(\"\"\"\\\n            import subprocess, os, sys, time\n            s = \"import os, time;\"\n            s += \"f = open('%s', 'w');\"\n            s += \"f.write(str(os.getpid()));\"\n            s += \"f.close();\"\n            s += \"time.sleep(60);\"\n            p = subprocess.Popen([r'%s', '-c', s])\n            p.wait()\n            \"\"\" % (os.path.basename(testfn), PYTHON_EXE))\n        # On Windows if we create a subprocess with CREATE_NO_WINDOW flag\n        # set (which is the default) a \"conhost.exe\" extra process will be\n        # spawned as a child. We don't want that.\n        if WINDOWS:\n            subp, tfile = pyrun(s, creationflags=0)\n        else:\n            subp, tfile = pyrun(s)\n        child = psutil.Process(subp.pid)\n        grandchild_pid = int(wait_for_file(testfn, delete=True, empty=False))\n        _pids_started.add(grandchild_pid)\n        grandchild = psutil.Process(grandchild_pid)\n        return (child, grandchild)\n    finally:\n        safe_rmpath(testfn)\n        if tfile is not None:\n            safe_rmpath(tfile)\n\n\ndef spawn_zombie():\n    \"\"\"Create a zombie process and return a (parent, zombie) process tuple.\n    In order to kill the zombie parent must be terminate()d first, then\n    zombie must be wait()ed on.\n    \"\"\"\n    assert psutil.POSIX\n    unix_file = get_testfn()\n    src = textwrap.dedent(\"\"\"\\\n        import os, sys, time, socket, contextlib\n        child_pid = os.fork()\n        if child_pid > 0:\n            time.sleep(3000)\n        else:\n            # this is the zombie process\n            s = socket.socket(socket.AF_UNIX)\n            with contextlib.closing(s):\n                s.connect('%s')\n                if sys.version_info < (3, ):\n                    pid = str(os.getpid())\n                else:\n                    pid = bytes(str(os.getpid()), 'ascii')\n                s.sendall(pid)\n        \"\"\" % unix_file)\n    tfile = None\n    sock = bind_unix_socket(unix_file)\n    try:\n        sock.settimeout(GLOBAL_TIMEOUT)\n        parent, tfile = pyrun(src)\n        conn, _ = sock.accept()\n        try:\n            select.select([conn.fileno()], [], [], GLOBAL_TIMEOUT)\n            zpid = int(conn.recv(1024))\n            _pids_started.add(zpid)\n            zombie = psutil.Process(zpid)\n            call_until(lambda: zombie.status(), \"ret == psutil.STATUS_ZOMBIE\")\n            return (parent, zombie)\n        finally:\n            conn.close()\n    finally:\n        sock.close()\n        safe_rmpath(unix_file)\n        if tfile is not None:\n            safe_rmpath(tfile)\n\n\n@_reap_children_on_err\ndef pyrun(src, **kwds):\n    \"\"\"Run python 'src' code string in a separate interpreter.\n    Returns a subprocess.Popen instance and the test file where the source\n    code was written.\n    \"\"\"\n    kwds.setdefault(\"stdout\", None)\n    kwds.setdefault(\"stderr\", None)\n    srcfile = get_testfn()\n    try:\n        with open(srcfile, 'wt') as f:\n            f.write(src)\n        subp = spawn_testproc([PYTHON_EXE, f.name], **kwds)\n        wait_for_pid(subp.pid)\n        return (subp, srcfile)\n    except Exception:\n        safe_rmpath(srcfile)\n        raise\n\n\n@_reap_children_on_err\ndef sh(cmd, **kwds):\n    \"\"\"run cmd in a subprocess and return its output.\n    raises RuntimeError on error.\n    \"\"\"\n    shell = True if isinstance(cmd, (str, unicode)) else False\n    # Prevents subprocess to open error dialogs in case of error.\n    flags = 0x8000000 if WINDOWS and shell else 0\n    kwds.setdefault(\"shell\", shell)\n    kwds.setdefault(\"stdout\", subprocess.PIPE)\n    kwds.setdefault(\"stderr\", subprocess.PIPE)\n    kwds.setdefault(\"universal_newlines\", True)\n    kwds.setdefault(\"creationflags\", flags)\n    p = subprocess.Popen(cmd, **kwds)\n    _subprocesses_started.add(p)\n    if PY3:\n        stdout, stderr = p.communicate(timeout=GLOBAL_TIMEOUT)\n    else:\n        stdout, stderr = p.communicate()\n    if p.returncode != 0:\n        raise RuntimeError(stderr)\n    if stderr:\n        warn(stderr)\n    if stdout.endswith('\\n'):\n        stdout = stdout[:-1]\n    return stdout\n\n\ndef terminate(proc_or_pid, sig=signal.SIGTERM, wait_timeout=GLOBAL_TIMEOUT):\n    \"\"\"Terminate a process and wait() for it.\n    Process can be a PID or an instance of psutil.Process(),\n    subprocess.Popen() or psutil.Popen().\n    If it's a subprocess.Popen() or psutil.Popen() instance also closes\n    its stdin / stdout / stderr fds.\n    PID is wait()ed even if the process is already gone (kills zombies).\n    Does nothing if the process does not exist.\n    Return process exit status.\n    \"\"\"\n    if POSIX:\n        from psutil._psposix import wait_pid\n\n    def wait(proc, timeout):\n        if isinstance(proc, subprocess.Popen) and not PY3:\n            proc.wait()\n        else:\n            proc.wait(timeout)\n        if WINDOWS and isinstance(proc, subprocess.Popen):\n            # Otherwise PID may still hang around.\n            try:\n                return psutil.Process(proc.pid).wait(timeout)\n            except psutil.NoSuchProcess:\n                pass\n\n    def sendsig(proc, sig):\n        # XXX: otherwise the build hangs for some reason.\n        if MACOS and GITHUB_ACTIONS:\n            sig = signal.SIGKILL\n        # If the process received SIGSTOP, SIGCONT is necessary first,\n        # otherwise SIGTERM won't work.\n        if POSIX and sig != signal.SIGKILL:\n            proc.send_signal(signal.SIGCONT)\n        proc.send_signal(sig)\n\n    def term_subproc(proc, timeout):\n        try:\n            sendsig(proc, sig)\n        except OSError as err:\n            if WINDOWS and err.winerror == 6:  # \"invalid handle\"\n                pass\n            elif err.errno != errno.ESRCH:\n                raise\n        return wait(proc, timeout)\n\n    def term_psproc(proc, timeout):\n        try:\n            sendsig(proc, sig)\n        except psutil.NoSuchProcess:\n            pass\n        return wait(proc, timeout)\n\n    def term_pid(pid, timeout):\n        try:\n            proc = psutil.Process(pid)\n        except psutil.NoSuchProcess:\n            # Needed to kill zombies.\n            if POSIX:\n                return wait_pid(pid, timeout)\n        else:\n            return term_psproc(proc, timeout)\n\n    def flush_popen(proc):\n        if proc.stdout:\n            proc.stdout.close()\n        if proc.stderr:\n            proc.stderr.close()\n        # Flushing a BufferedWriter may raise an error.\n        if proc.stdin:\n            proc.stdin.close()\n\n    p = proc_or_pid\n    try:\n        if isinstance(p, int):\n            return term_pid(p, wait_timeout)\n        elif isinstance(p, (psutil.Process, psutil.Popen)):\n            return term_psproc(p, wait_timeout)\n        elif isinstance(p, subprocess.Popen):\n            return term_subproc(p, wait_timeout)\n        else:\n            raise TypeError(\"wrong type %r\" % p)\n    finally:\n        if isinstance(p, (subprocess.Popen, psutil.Popen)):\n            flush_popen(p)\n        pid = p if isinstance(p, int) else p.pid\n        assert not psutil.pid_exists(pid), pid\n\n\ndef reap_children(recursive=False):\n    \"\"\"Terminate and wait() any subprocess started by this test suite\n    and any children currently running, ensuring that no processes stick\n    around to hog resources.\n    If resursive is True it also tries to terminate and wait()\n    all grandchildren started by this process.\n    \"\"\"\n    # Get the children here before terminating them, as in case of\n    # recursive=True we don't want to lose the intermediate reference\n    # pointing to the grandchildren.\n    children = psutil.Process().children(recursive=recursive)\n\n    # Terminate subprocess.Popen.\n    while _subprocesses_started:\n        subp = _subprocesses_started.pop()\n        terminate(subp)\n\n    # Collect started pids.\n    while _pids_started:\n        pid = _pids_started.pop()\n        terminate(pid)\n\n    # Terminate children.\n    if children:\n        for p in children:\n            terminate(p, wait_timeout=None)\n        gone, alive = psutil.wait_procs(children, timeout=GLOBAL_TIMEOUT)\n        for p in alive:\n            warn(\"couldn't terminate process %r; attempting kill()\" % p)\n            terminate(p, sig=signal.SIGKILL)\n\n\n# ===================================================================\n# --- OS\n# ===================================================================\n\n\ndef kernel_version():\n    \"\"\"Return a tuple such as (2, 6, 36).\"\"\"\n    if not POSIX:\n        raise NotImplementedError(\"not POSIX\")\n    s = \"\"\n    uname = os.uname()[2]\n    for c in uname:\n        if c.isdigit() or c == '.':\n            s += c\n        else:\n            break\n    if not s:\n        raise ValueError(\"can't parse %r\" % uname)\n    minor = 0\n    micro = 0\n    nums = s.split('.')\n    major = int(nums[0])\n    if len(nums) >= 2:\n        minor = int(nums[1])\n    if len(nums) >= 3:\n        micro = int(nums[2])\n    return (major, minor, micro)\n\n\ndef get_winver():\n    if not WINDOWS:\n        raise NotImplementedError(\"not WINDOWS\")\n    wv = sys.getwindowsversion()\n    if hasattr(wv, 'service_pack_major'):  # python >= 2.7\n        sp = wv.service_pack_major or 0\n    else:\n        r = re.search(r\"\\s\\d$\", wv[4])\n        if r:\n            sp = int(r.group(0))\n        else:\n            sp = 0\n    return (wv[0], wv[1], sp)\n\n\n# ===================================================================\n# --- sync primitives\n# ===================================================================\n\n\nclass retry(object):\n    \"\"\"A retry decorator.\"\"\"\n\n    def __init__(self,\n                 exception=Exception,\n                 timeout=None,\n                 retries=None,\n                 interval=0.001,\n                 logfun=None,\n                 ):\n        if timeout and retries:\n            raise ValueError(\"timeout and retries args are mutually exclusive\")\n        self.exception = exception\n        self.timeout = timeout\n        self.retries = retries\n        self.interval = interval\n        self.logfun = logfun\n\n    def __iter__(self):\n        if self.timeout:\n            stop_at = time.time() + self.timeout\n            while time.time() < stop_at:\n                yield\n        elif self.retries:\n            for _ in range(self.retries):\n                yield\n        else:\n            while True:\n                yield\n\n    def sleep(self):\n        if self.interval is not None:\n            time.sleep(self.interval)\n\n    def __call__(self, fun):\n        @functools.wraps(fun)\n        def wrapper(*args, **kwargs):\n            exc = None\n            for _ in self:\n                try:\n                    return fun(*args, **kwargs)\n                except self.exception as _:  # NOQA\n                    exc = _\n                    if self.logfun is not None:\n                        self.logfun(exc)\n                    self.sleep()\n                    continue\n            if PY3:\n                raise exc\n            else:\n                raise\n\n        # This way the user of the decorated function can change config\n        # parameters.\n        wrapper.decorator = self\n        return wrapper\n\n\n@retry(exception=psutil.NoSuchProcess, logfun=None, timeout=GLOBAL_TIMEOUT,\n       interval=0.001)\ndef wait_for_pid(pid):\n    \"\"\"Wait for pid to show up in the process list then return.\n    Used in the test suite to give time the sub process to initialize.\n    \"\"\"\n    psutil.Process(pid)\n    if WINDOWS:\n        # give it some more time to allow better initialization\n        time.sleep(0.01)\n\n\n@retry(exception=(FileNotFoundError, AssertionError), logfun=None,\n       timeout=GLOBAL_TIMEOUT, interval=0.001)\ndef wait_for_file(fname, delete=True, empty=False):\n    \"\"\"Wait for a file to be written on disk with some content.\"\"\"\n    with open(fname, \"rb\") as f:\n        data = f.read()\n    if not empty:\n        assert data\n    if delete:\n        safe_rmpath(fname)\n    return data\n\n\n@retry(exception=AssertionError, logfun=None, timeout=GLOBAL_TIMEOUT,\n       interval=0.001)\ndef call_until(fun, expr):\n    \"\"\"Keep calling function for timeout secs and exit if eval()\n    expression is True.\n    \"\"\"\n    ret = fun()\n    assert eval(expr)\n    return ret\n\n\n# ===================================================================\n# --- fs\n# ===================================================================\n\n\ndef safe_rmpath(path):\n    \"Convenience function for removing temporary test files or dirs\"\n    def retry_fun(fun):\n        # On Windows it could happen that the file or directory has\n        # open handles or references preventing the delete operation\n        # to succeed immediately, so we retry for a while. See:\n        # https://bugs.python.org/issue33240\n        stop_at = time.time() + GLOBAL_TIMEOUT\n        while time.time() < stop_at:\n            try:\n                return fun()\n            except FileNotFoundError:\n                pass\n            except WindowsError as _:\n                err = _\n                warn(\"ignoring %s\" % (str(err)))\n            time.sleep(0.01)\n        raise err\n\n    try:\n        st = os.stat(path)\n        if stat.S_ISDIR(st.st_mode):\n            fun = functools.partial(shutil.rmtree, path)\n        else:\n            fun = functools.partial(os.remove, path)\n        if POSIX:\n            fun()\n        else:\n            retry_fun(fun)\n    except FileNotFoundError:\n        pass\n\n\ndef safe_mkdir(dir):\n    \"Convenience function for creating a directory\"\n    try:\n        os.mkdir(dir)\n    except FileExistsError:\n        pass\n\n\n@contextlib.contextmanager\ndef chdir(dirname):\n    \"Context manager which temporarily changes the current directory.\"\n    curdir = os.getcwd()\n    try:\n        os.chdir(dirname)\n        yield\n    finally:\n        os.chdir(curdir)\n\n\ndef create_exe(outpath, c_code=None):\n    \"\"\"Creates an executable file in the given location.\"\"\"\n    assert not os.path.exists(outpath), outpath\n    if c_code:\n        if not which(\"gcc\"):\n            raise ValueError(\"gcc is not installed\")\n        if isinstance(c_code, bool):        # c_code is True\n            c_code = textwrap.dedent(\n                \"\"\"\n                #include <unistd.h>\n                int main() {\n                    pause();\n                    return 1;\n                }\n                \"\"\")\n        assert isinstance(c_code, str), c_code\n        with open(get_testfn(suffix='.c'), 'wt') as f:\n            f.write(c_code)\n        try:\n            subprocess.check_call([\"gcc\", f.name, \"-o\", outpath])\n        finally:\n            safe_rmpath(f.name)\n    else:\n        # copy python executable\n        shutil.copyfile(PYTHON_EXE, outpath)\n        if POSIX:\n            st = os.stat(outpath)\n            os.chmod(outpath, st.st_mode | stat.S_IEXEC)\n\n\ndef get_testfn(suffix=\"\", dir=None):\n    \"\"\"Return an absolute pathname of a file or dir that did not\n    exist at the time this call is made. Also schedule it for safe\n    deletion at interpreter exit. It's technically racy but probably\n    not really due to the time variant.\n    \"\"\"\n    while True:\n        name = tempfile.mktemp(prefix=TESTFN_PREFIX, suffix=suffix, dir=dir)\n        if not os.path.exists(name):  # also include dirs\n            return os.path.realpath(name)  # needed for OSX\n\n\n# ===================================================================\n# --- testing\n# ===================================================================\n\n\nclass TestCase(unittest.TestCase):\n\n    # Print a full path representation of the single unit tests\n    # being run.\n    def __str__(self):\n        fqmod = self.__class__.__module__\n        if not fqmod.startswith('psutil.'):\n            fqmod = 'psutil.tests.' + fqmod\n        return \"%s.%s.%s\" % (\n            fqmod, self.__class__.__name__, self._testMethodName)\n\n    # assertRaisesRegexp renamed to assertRaisesRegex in 3.3;\n    # add support for the new name.\n    if not hasattr(unittest.TestCase, 'assertRaisesRegex'):\n        assertRaisesRegex = unittest.TestCase.assertRaisesRegexp\n\n    # ...otherwise multiprocessing.Pool complains\n    if not PY3:\n        def runTest(self):\n            pass\n\n\n# monkey patch default unittest.TestCase\nunittest.TestCase = TestCase\n\n\nclass PsutilTestCase(TestCase):\n    \"\"\"Test class providing auto-cleanup wrappers on top of process\n    test utilities.\n    \"\"\"\n\n    def get_testfn(self, suffix=\"\", dir=None):\n        fname = get_testfn(suffix=suffix, dir=dir)\n        self.addCleanup(safe_rmpath, fname)\n        return fname\n\n    def spawn_testproc(self, *args, **kwds):\n        sproc = spawn_testproc(*args, **kwds)\n        self.addCleanup(terminate, sproc)\n        return sproc\n\n    def spawn_children_pair(self):\n        child1, child2 = spawn_children_pair()\n        self.addCleanup(terminate, child2)\n        self.addCleanup(terminate, child1)  # executed first\n        return (child1, child2)\n\n    def spawn_zombie(self):\n        parent, zombie = spawn_zombie()\n        self.addCleanup(terminate, zombie)\n        self.addCleanup(terminate, parent)  # executed first\n        return (parent, zombie)\n\n    def pyrun(self, *args, **kwds):\n        sproc, srcfile = pyrun(*args, **kwds)\n        self.addCleanup(safe_rmpath, srcfile)\n        self.addCleanup(terminate, sproc)  # executed first\n        return sproc\n\n    def assertProcessGone(self, proc):\n        self.assertRaises(psutil.NoSuchProcess, psutil.Process, proc.pid)\n        if isinstance(proc, (psutil.Process, psutil.Popen)):\n            assert not proc.is_running()\n            try:\n                status = proc.status()\n            except psutil.NoSuchProcess:\n                pass\n            else:\n                raise AssertionError(\"Process.status() didn't raise exception \"\n                                     \"(status=%s)\" % status)\n            proc.wait(timeout=0)  # assert not raise TimeoutExpired\n        assert not psutil.pid_exists(proc.pid), proc.pid\n        self.assertNotIn(proc.pid, psutil.pids())\n\n\n@unittest.skipIf(PYPY, \"unreliable on PYPY\")\nclass TestMemoryLeak(PsutilTestCase):\n    \"\"\"Test framework class for detecting function memory leaks,\n    typically functions implemented in C which forgot to free() memory\n    from the heap. It does so by checking whether the process memory\n    usage increased before and after calling the function many times.\n\n    Note that this is hard (probably impossible) to do reliably, due\n    to how the OS handles memory, the GC and so on (memory can even\n    decrease!). In order to avoid false positives, in case of failure\n    (mem > 0) we retry the test for up to 5 times, increasing call\n    repetitions each time. If the memory keeps increasing then it's a\n    failure.\n\n    If available (Linux, OSX, Windows), USS memory is used for comparison,\n    since it's supposed to be more precise, see:\n    https://gmpy.dev/blog/2016/real-process-memory-and-environ-in-python\n    If not, RSS memory is used. mallinfo() on Linux and _heapwalk() on\n    Windows may give even more precision, but at the moment are not\n    implemented.\n\n    PyPy appears to be completely unstable for this framework, probably\n    because of its JIT, so tests on PYPY are skipped.\n\n    Usage:\n\n        class TestLeaks(psutil.tests.TestMemoryLeak):\n\n            def test_fun(self):\n                self.execute(some_function)\n    \"\"\"\n    # Configurable class attrs.\n    times = 200\n    warmup_times = 10\n    tolerance = 0  # memory\n    retries = 10 if CI_TESTING else 5\n    verbose = True\n    _thisproc = psutil.Process()\n\n    def _get_mem(self):\n        # USS is the closest thing we have to \"real\" memory usage and it\n        # should be less likely to produce false positives.\n        mem = self._thisproc.memory_full_info()\n        return getattr(mem, \"uss\", mem.rss)\n\n    def _get_num_fds(self):\n        if POSIX:\n            return self._thisproc.num_fds()\n        else:\n            return self._thisproc.num_handles()\n\n    def _log(self, msg):\n        if self.verbose:\n            print_color(msg, color=\"yellow\", file=sys.stderr)\n\n    def _check_fds(self, fun):\n        \"\"\"Makes sure num_fds() (POSIX) or num_handles() (Windows) does\n        not increase after calling a function.  Used to discover forgotten\n        close(2) and CloseHandle syscalls.\n        \"\"\"\n        before = self._get_num_fds()\n        self.call(fun)\n        after = self._get_num_fds()\n        diff = after - before\n        if diff < 0:\n            raise self.fail(\"negative diff %r (gc probably collected a \"\n                            \"resource from a previous test)\" % diff)\n        if diff > 0:\n            type_ = \"fd\" if POSIX else \"handle\"\n            if diff > 1:\n                type_ += \"s\"\n            msg = \"%s unclosed %s after calling %r\" % (diff, type_, fun)\n            raise self.fail(msg)\n\n    def _call_ntimes(self, fun, times):\n        \"\"\"Get 2 distinct memory samples, before and after having\n        called fun repeadetly, and return the memory difference.\n        \"\"\"\n        gc.collect(generation=1)\n        mem1 = self._get_mem()\n        for x in range(times):\n            ret = self.call(fun)\n            del x, ret\n        gc.collect(generation=1)\n        mem2 = self._get_mem()\n        self.assertEqual(gc.garbage, [])\n        diff = mem2 - mem1  # can also be negative\n        return diff\n\n    def _check_mem(self, fun, times, warmup_times, retries, tolerance):\n        messages = []\n        prev_mem = 0\n        increase = times\n        for idx in range(1, retries + 1):\n            mem = self._call_ntimes(fun, times)\n            msg = \"Run #%s: extra-mem=%s, per-call=%s, calls=%s\" % (\n                idx, bytes2human(mem), bytes2human(mem / times), times)\n            messages.append(msg)\n            success = mem <= tolerance or mem <= prev_mem\n            if success:\n                if idx > 1:\n                    self._log(msg)\n                return\n            else:\n                if idx == 1:\n                    print()  # NOQA\n                self._log(msg)\n                times += increase\n                prev_mem = mem\n        raise self.fail(\". \".join(messages))\n\n    # ---\n\n    def call(self, fun):\n        return fun()\n\n    def execute(self, fun, times=None, warmup_times=None, retries=None,\n                tolerance=None):\n        \"\"\"Test a callable.\"\"\"\n        times = times if times is not None else self.times\n        warmup_times = warmup_times if warmup_times is not None \\\n            else self.warmup_times\n        retries = retries if retries is not None else self.retries\n        tolerance = tolerance if tolerance is not None else self.tolerance\n        try:\n            assert times >= 1, \"times must be >= 1\"\n            assert warmup_times >= 0, \"warmup_times must be >= 0\"\n            assert retries >= 0, \"retries must be >= 0\"\n            assert tolerance >= 0, \"tolerance must be >= 0\"\n        except AssertionError as err:\n            raise ValueError(str(err))\n\n        self._call_ntimes(fun, warmup_times)  # warm up\n        self._check_fds(fun)\n        self._check_mem(fun, times=times, warmup_times=warmup_times,\n                        retries=retries, tolerance=tolerance)\n\n    def execute_w_exc(self, exc, fun, **kwargs):\n        \"\"\"Convenience method to test a callable while making sure it\n        raises an exception on every call.\n        \"\"\"\n        def call():\n            self.assertRaises(exc, fun)\n\n        self.execute(call, **kwargs)\n\n\ndef print_sysinfo():\n    import collections\n    import datetime\n    import getpass\n    import locale\n    import platform\n    import pprint\n    try:\n        import pip\n    except ImportError:\n        pip = None\n    try:\n        import wheel\n    except ImportError:\n        wheel = None\n\n    info = collections.OrderedDict()\n\n    # OS\n    if psutil.LINUX and which('lsb_release'):\n        info['OS'] = sh('lsb_release -d -s')\n    elif psutil.OSX:\n        info['OS'] = 'Darwin %s' % platform.mac_ver()[0]\n    elif psutil.WINDOWS:\n        info['OS'] = \"Windows \" + ' '.join(\n            map(str, platform.win32_ver()))\n        if hasattr(platform, 'win32_edition'):\n            info['OS'] += \", \" + platform.win32_edition()\n    else:\n        info['OS'] = \"%s %s\" % (platform.system(), platform.version())\n    info['arch'] = ', '.join(\n        list(platform.architecture()) + [platform.machine()])\n    if psutil.POSIX:\n        info['kernel'] = platform.uname()[2]\n\n    # python\n    info['python'] = ', '.join([\n        platform.python_implementation(),\n        platform.python_version(),\n        platform.python_compiler()])\n    info['pip'] = getattr(pip, '__version__', 'not installed')\n    if wheel is not None:\n        info['pip'] += \" (wheel=%s)\" % wheel.__version__\n\n    # UNIX\n    if psutil.POSIX:\n        if which('gcc'):\n            out = sh(['gcc', '--version'])\n            info['gcc'] = str(out).split('\\n')[0]\n        else:\n            info['gcc'] = 'not installed'\n        s = platform.libc_ver()[1]\n        if s:\n            info['glibc'] = s\n\n    # system\n    info['fs-encoding'] = sys.getfilesystemencoding()\n    lang = locale.getlocale()\n    info['lang'] = '%s, %s' % (lang[0], lang[1])\n    info['boot-time'] = datetime.datetime.fromtimestamp(\n        psutil.boot_time()).strftime(\"%Y-%m-%d %H:%M:%S\")\n    info['time'] = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    info['user'] = getpass.getuser()\n    info['home'] = os.path.expanduser(\"~\")\n    info['cwd'] = os.getcwd()\n    info['pyexe'] = PYTHON_EXE\n    info['hostname'] = platform.node()\n    info['PID'] = os.getpid()\n\n    # metrics\n    info['cpus'] = psutil.cpu_count()\n    info['loadavg'] = \"%.1f%%, %.1f%%, %.1f%%\" % (\n        tuple([x / psutil.cpu_count() * 100 for x in psutil.getloadavg()]))\n    mem = psutil.virtual_memory()\n    info['memory'] = \"%s%%, used=%s, total=%s\" % (\n        int(mem.percent), bytes2human(mem.used), bytes2human(mem.total))\n    swap = psutil.swap_memory()\n    info['swap'] = \"%s%%, used=%s, total=%s\" % (\n        int(swap.percent), bytes2human(swap.used), bytes2human(swap.total))\n    info['pids'] = len(psutil.pids())\n    pinfo = psutil.Process().as_dict()\n    pinfo.pop('memory_maps', None)\n    info['proc'] = pprint.pformat(pinfo)\n\n    print(\"=\" * 70, file=sys.stderr)  # NOQA\n    for k, v in info.items():\n        print(\"%-17s %s\" % (k + ':', v), file=sys.stderr)  # NOQA\n    print(\"=\" * 70, file=sys.stderr)  # NOQA\n    sys.stdout.flush()\n\n\ndef _get_eligible_cpu():\n    p = psutil.Process()\n    if hasattr(p, \"cpu_num\"):\n        return p.cpu_num()\n    elif hasattr(p, \"cpu_affinity\"):\n        return random.choice(p.cpu_affinity())\n    return 0\n\n\nclass process_namespace:\n    \"\"\"A container that lists all Process class method names + some\n    reasonable parameters to be called with. Utility methods (parent(),\n    children(), ...) are excluded.\n\n    >>> ns = process_namespace(psutil.Process())\n    >>> for fun, name in ns.iter(ns.getters):\n    ...    fun()\n    \"\"\"\n    utils = [\n        ('cpu_percent', (), {}),\n        ('memory_percent', (), {}),\n    ]\n\n    ignored = [\n        ('as_dict', (), {}),\n        ('children', (), {'recursive': True}),\n        ('is_running', (), {}),\n        ('memory_info_ex', (), {}),\n        ('oneshot', (), {}),\n        ('parent', (), {}),\n        ('parents', (), {}),\n        ('pid', (), {}),\n        ('wait', (0, ), {}),\n    ]\n\n    getters = [\n        ('cmdline', (), {}),\n        ('connections', (), {'kind': 'all'}),\n        ('cpu_times', (), {}),\n        ('create_time', (), {}),\n        ('cwd', (), {}),\n        ('exe', (), {}),\n        ('memory_full_info', (), {}),\n        ('memory_info', (), {}),\n        ('name', (), {}),\n        ('nice', (), {}),\n        ('num_ctx_switches', (), {}),\n        ('num_threads', (), {}),\n        ('open_files', (), {}),\n        ('ppid', (), {}),\n        ('status', (), {}),\n        ('threads', (), {}),\n        ('username', (), {}),\n    ]\n    if POSIX:\n        getters += [('uids', (), {})]\n        getters += [('gids', (), {})]\n        getters += [('terminal', (), {})]\n        getters += [('num_fds', (), {})]\n    if HAS_PROC_IO_COUNTERS:\n        getters += [('io_counters', (), {})]\n    if HAS_IONICE:\n        getters += [('ionice', (), {})]\n    if HAS_RLIMIT:\n        getters += [('rlimit', (psutil.RLIMIT_NOFILE, ), {})]\n    if HAS_CPU_AFFINITY:\n        getters += [('cpu_affinity', (), {})]\n    if HAS_PROC_CPU_NUM:\n        getters += [('cpu_num', (), {})]\n    if HAS_ENVIRON:\n        getters += [('environ', (), {})]\n    if WINDOWS:\n        getters += [('num_handles', (), {})]\n    if HAS_MEMORY_MAPS:\n        getters += [('memory_maps', (), {'grouped': False})]\n\n    setters = []\n    if POSIX:\n        setters += [('nice', (0, ), {})]\n    else:\n        setters += [('nice', (psutil.NORMAL_PRIORITY_CLASS, ), {})]\n    if HAS_RLIMIT:\n        setters += [('rlimit', (psutil.RLIMIT_NOFILE, (1024, 4096)), {})]\n    if HAS_IONICE:\n        if LINUX:\n            setters += [('ionice', (psutil.IOPRIO_CLASS_NONE, 0), {})]\n        else:\n            setters += [('ionice', (psutil.IOPRIO_NORMAL, ), {})]\n    if HAS_CPU_AFFINITY:\n        setters += [('cpu_affinity', ([_get_eligible_cpu()], ), {})]\n\n    killers = [\n        ('send_signal', (signal.SIGTERM, ), {}),\n        ('suspend', (), {}),\n        ('resume', (), {}),\n        ('terminate', (), {}),\n        ('kill', (), {}),\n    ]\n    if WINDOWS:\n        killers += [('send_signal', (signal.CTRL_C_EVENT, ), {})]\n        killers += [('send_signal', (signal.CTRL_BREAK_EVENT, ), {})]\n\n    all = utils + getters + setters + killers\n\n    def __init__(self, proc):\n        self._proc = proc\n\n    def iter(self, ls, clear_cache=True):\n        \"\"\"Given a list of tuples yields a set of (fun, fun_name) tuples\n        in random order.\n        \"\"\"\n        ls = list(ls)\n        random.shuffle(ls)\n        for fun_name, args, kwds in ls:\n            if clear_cache:\n                self.clear_cache()\n            fun = getattr(self._proc, fun_name)\n            fun = functools.partial(fun, *args, **kwds)\n            yield (fun, fun_name)\n\n    def clear_cache(self):\n        \"\"\"Clear the cache of a Process instance.\"\"\"\n        self._proc._init(self._proc.pid, _ignore_nsp=True)\n\n    @classmethod\n    def test_class_coverage(cls, test_class, ls):\n        \"\"\"Given a TestCase instance and a list of tuples checks that\n        the class defines the required test method names.\n        \"\"\"\n        for fun_name, _, _ in ls:\n            meth_name = 'test_' + fun_name\n            if not hasattr(test_class, meth_name):\n                msg = \"%r class should define a '%s' method\" % (\n                    test_class.__class__.__name__, meth_name)\n                raise AttributeError(msg)\n\n    @classmethod\n    def test(cls):\n        this = set([x[0] for x in cls.all])\n        ignored = set([x[0] for x in cls.ignored])\n        klass = set([x for x in dir(psutil.Process) if x[0] != '_'])\n        leftout = (this | ignored) ^ klass\n        if leftout:\n            raise ValueError(\"uncovered Process class names: %r\" % leftout)\n\n\nclass system_namespace:\n    \"\"\"A container that lists all the module-level, system-related APIs.\n    Utilities such as cpu_percent() are excluded. Usage:\n\n    >>> ns = system_namespace\n    >>> for fun, name in ns.iter(ns.getters):\n    ...    fun()\n    \"\"\"\n    getters = [\n        ('boot_time', (), {}),\n        ('cpu_count', (), {'logical': False}),\n        ('cpu_count', (), {'logical': True}),\n        ('cpu_stats', (), {}),\n        ('cpu_times', (), {'percpu': False}),\n        ('cpu_times', (), {'percpu': True}),\n        ('disk_io_counters', (), {'perdisk': True}),\n        ('disk_partitions', (), {'all': True}),\n        ('disk_usage', (os.getcwd(), ), {}),\n        ('net_connections', (), {'kind': 'all'}),\n        ('net_if_addrs', (), {}),\n        ('net_if_stats', (), {}),\n        ('net_io_counters', (), {'pernic': True}),\n        ('pid_exists', (os.getpid(), ), {}),\n        ('pids', (), {}),\n        ('swap_memory', (), {}),\n        ('users', (), {}),\n        ('virtual_memory', (), {}),\n    ]\n    if HAS_CPU_FREQ:\n        getters += [('cpu_freq', (), {'percpu': True})]\n    if HAS_GETLOADAVG:\n        getters += [('getloadavg', (), {})]\n    if HAS_SENSORS_TEMPERATURES:\n        getters += [('sensors_temperatures', (), {})]\n    if HAS_SENSORS_FANS:\n        getters += [('sensors_fans', (), {})]\n    if HAS_SENSORS_BATTERY:\n        getters += [('sensors_battery', (), {})]\n    if WINDOWS:\n        getters += [('win_service_iter', (), {})]\n        getters += [('win_service_get', ('alg', ), {})]\n\n    ignored = [\n        ('process_iter', (), {}),\n        ('wait_procs', ([psutil.Process()], ), {}),\n        ('cpu_percent', (), {}),\n        ('cpu_times_percent', (), {}),\n    ]\n\n    all = getters\n\n    @staticmethod\n    def iter(ls):\n        \"\"\"Given a list of tuples yields a set of (fun, fun_name) tuples\n        in random order.\n        \"\"\"\n        ls = list(ls)\n        random.shuffle(ls)\n        for fun_name, args, kwds in ls:\n            fun = getattr(psutil, fun_name)\n            fun = functools.partial(fun, *args, **kwds)\n            yield (fun, fun_name)\n\n    test_class_coverage = process_namespace.test_class_coverage\n\n\ndef serialrun(klass):\n    \"\"\"A decorator to mark a TestCase class. When running parallel tests,\n    class' unit tests will be run serially (1 process).\n    \"\"\"\n    # assert issubclass(klass, unittest.TestCase), klass\n    assert inspect.isclass(klass), klass\n    klass._serialrun = True\n    return klass\n\n\ndef retry_on_failure(retries=NO_RETRIES):\n    \"\"\"Decorator which runs a test function and retries N times before\n    actually failing.\n    \"\"\"\n    def logfun(exc):\n        print(\"%r, retrying\" % exc, file=sys.stderr)  # NOQA\n\n    return retry(exception=AssertionError, timeout=None, retries=retries,\n                 logfun=logfun)\n\n\ndef skip_on_access_denied(only_if=None):\n    \"\"\"Decorator to Ignore AccessDenied exceptions.\"\"\"\n    def decorator(fun):\n        @functools.wraps(fun)\n        def wrapper(*args, **kwargs):\n            try:\n                return fun(*args, **kwargs)\n            except psutil.AccessDenied:\n                if only_if is not None:\n                    if not only_if:\n                        raise\n                raise unittest.SkipTest(\"raises AccessDenied\")\n        return wrapper\n    return decorator\n\n\ndef skip_on_not_implemented(only_if=None):\n    \"\"\"Decorator to Ignore NotImplementedError exceptions.\"\"\"\n    def decorator(fun):\n        @functools.wraps(fun)\n        def wrapper(*args, **kwargs):\n            try:\n                return fun(*args, **kwargs)\n            except NotImplementedError:\n                if only_if is not None:\n                    if not only_if:\n                        raise\n                msg = \"%r was skipped because it raised NotImplementedError\" \\\n                      % fun.__name__\n                raise unittest.SkipTest(msg)\n        return wrapper\n    return decorator\n\n\n# ===================================================================\n# --- network\n# ===================================================================\n\n\n# XXX: no longer used\ndef get_free_port(host='127.0.0.1'):\n    \"\"\"Return an unused TCP port. Subject to race conditions.\"\"\"\n    with contextlib.closing(socket.socket()) as sock:\n        sock.bind((host, 0))\n        return sock.getsockname()[1]\n\n\ndef bind_socket(family=AF_INET, type=SOCK_STREAM, addr=None):\n    \"\"\"Binds a generic socket.\"\"\"\n    if addr is None and family in (AF_INET, AF_INET6):\n        addr = (\"\", 0)\n    sock = socket.socket(family, type)\n    try:\n        if os.name not in ('nt', 'cygwin'):\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        sock.bind(addr)\n        if type == socket.SOCK_STREAM:\n            sock.listen(5)\n        return sock\n    except Exception:\n        sock.close()\n        raise\n\n\ndef bind_unix_socket(name, type=socket.SOCK_STREAM):\n    \"\"\"Bind a UNIX socket.\"\"\"\n    assert psutil.POSIX\n    assert not os.path.exists(name), name\n    sock = socket.socket(socket.AF_UNIX, type)\n    try:\n        sock.bind(name)\n        if type == socket.SOCK_STREAM:\n            sock.listen(5)\n    except Exception:\n        sock.close()\n        raise\n    return sock\n\n\ndef tcp_socketpair(family, addr=(\"\", 0)):\n    \"\"\"Build a pair of TCP sockets connected to each other.\n    Return a (server, client) tuple.\n    \"\"\"\n    with contextlib.closing(socket.socket(family, SOCK_STREAM)) as ll:\n        ll.bind(addr)\n        ll.listen(5)\n        addr = ll.getsockname()\n        c = socket.socket(family, SOCK_STREAM)\n        try:\n            c.connect(addr)\n            caddr = c.getsockname()\n            while True:\n                a, addr = ll.accept()\n                # check that we've got the correct client\n                if addr == caddr:\n                    return (a, c)\n                a.close()\n        except OSError:\n            c.close()\n            raise\n\n\ndef unix_socketpair(name):\n    \"\"\"Build a pair of UNIX sockets connected to each other through\n    the same UNIX file name.\n    Return a (server, client) tuple.\n    \"\"\"\n    assert psutil.POSIX\n    server = client = None\n    try:\n        server = bind_unix_socket(name, type=socket.SOCK_STREAM)\n        server.setblocking(0)\n        client = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n        client.setblocking(0)\n        client.connect(name)\n        # new = server.accept()\n    except Exception:\n        if server is not None:\n            server.close()\n        if client is not None:\n            client.close()\n        raise\n    return (server, client)\n\n\n@contextlib.contextmanager\ndef create_sockets():\n    \"\"\"Open as many socket families / types as possible.\"\"\"\n    socks = []\n    fname1 = fname2 = None\n    try:\n        socks.append(bind_socket(socket.AF_INET, socket.SOCK_STREAM))\n        socks.append(bind_socket(socket.AF_INET, socket.SOCK_DGRAM))\n        if supports_ipv6():\n            socks.append(bind_socket(socket.AF_INET6, socket.SOCK_STREAM))\n            socks.append(bind_socket(socket.AF_INET6, socket.SOCK_DGRAM))\n        if POSIX and HAS_CONNECTIONS_UNIX:\n            fname1 = get_testfn()\n            fname2 = get_testfn()\n            s1, s2 = unix_socketpair(fname1)\n            s3 = bind_unix_socket(fname2, type=socket.SOCK_DGRAM)\n            for s in (s1, s2, s3):\n                socks.append(s)\n        yield socks\n    finally:\n        for s in socks:\n            s.close()\n        for fname in (fname1, fname2):\n            if fname is not None:\n                safe_rmpath(fname)\n\n\ndef check_net_address(addr, family):\n    \"\"\"Check a net address validity. Supported families are IPv4,\n    IPv6 and MAC addresses.\n    \"\"\"\n    import ipaddress  # python >= 3.3 / requires \"pip install ipaddress\"\n    if enum and PY3 and not PYPY:\n        assert isinstance(family, enum.IntEnum), family\n    if family == socket.AF_INET:\n        octs = [int(x) for x in addr.split('.')]\n        assert len(octs) == 4, addr\n        for num in octs:\n            assert 0 <= num <= 255, addr\n        if not PY3:\n            addr = unicode(addr)\n        ipaddress.IPv4Address(addr)\n    elif family == socket.AF_INET6:\n        assert isinstance(addr, str), addr\n        if not PY3:\n            addr = unicode(addr)\n        ipaddress.IPv6Address(addr)\n    elif family == psutil.AF_LINK:\n        assert re.match(r'([a-fA-F0-9]{2}[:|\\-]?){6}', addr) is not None, addr\n    else:\n        raise ValueError(\"unknown family %r\", family)\n\n\ndef check_connection_ntuple(conn):\n    \"\"\"Check validity of a connection namedtuple.\"\"\"\n    def check_ntuple(conn):\n        has_pid = len(conn) == 7\n        assert len(conn) in (6, 7), len(conn)\n        assert conn[0] == conn.fd, conn.fd\n        assert conn[1] == conn.family, conn.family\n        assert conn[2] == conn.type, conn.type\n        assert conn[3] == conn.laddr, conn.laddr\n        assert conn[4] == conn.raddr, conn.raddr\n        assert conn[5] == conn.status, conn.status\n        if has_pid:\n            assert conn[6] == conn.pid, conn.pid\n\n    def check_family(conn):\n        assert conn.family in (AF_INET, AF_INET6, AF_UNIX), conn.family\n        if enum is not None:\n            assert isinstance(conn.family, enum.IntEnum), conn\n        else:\n            assert isinstance(conn.family, int), conn\n        if conn.family == AF_INET:\n            # actually try to bind the local socket; ignore IPv6\n            # sockets as their address might be represented as\n            # an IPv4-mapped-address (e.g. \"::127.0.0.1\")\n            # and that's rejected by bind()\n            s = socket.socket(conn.family, conn.type)\n            with contextlib.closing(s):\n                try:\n                    s.bind((conn.laddr[0], 0))\n                except socket.error as err:\n                    if err.errno != errno.EADDRNOTAVAIL:\n                        raise\n        elif conn.family == AF_UNIX:\n            assert conn.status == psutil.CONN_NONE, conn.status\n\n    def check_type(conn):\n        # SOCK_SEQPACKET may happen in case of AF_UNIX socks\n        SOCK_SEQPACKET = getattr(socket, \"SOCK_SEQPACKET\", object())\n        assert conn.type in (socket.SOCK_STREAM, socket.SOCK_DGRAM,\n                             SOCK_SEQPACKET), conn.type\n        if enum is not None:\n            assert isinstance(conn.type, enum.IntEnum), conn\n        else:\n            assert isinstance(conn.type, int), conn\n        if conn.type == socket.SOCK_DGRAM:\n            assert conn.status == psutil.CONN_NONE, conn.status\n\n    def check_addrs(conn):\n        # check IP address and port sanity\n        for addr in (conn.laddr, conn.raddr):\n            if conn.family in (AF_INET, AF_INET6):\n                assert isinstance(addr, tuple), type(addr)\n                if not addr:\n                    continue\n                assert isinstance(addr.port, int), type(addr.port)\n                assert 0 <= addr.port <= 65535, addr.port\n                check_net_address(addr.ip, conn.family)\n            elif conn.family == AF_UNIX:\n                assert isinstance(addr, str), type(addr)\n\n    def check_status(conn):\n        assert isinstance(conn.status, str), conn.status\n        valids = [getattr(psutil, x) for x in dir(psutil)\n                  if x.startswith('CONN_')]\n        assert conn.status in valids, conn.status\n        if conn.family in (AF_INET, AF_INET6) and conn.type == SOCK_STREAM:\n            assert conn.status != psutil.CONN_NONE, conn.status\n        else:\n            assert conn.status == psutil.CONN_NONE, conn.status\n\n    check_ntuple(conn)\n    check_family(conn)\n    check_type(conn)\n    check_addrs(conn)\n    check_status(conn)\n\n\n# ===================================================================\n# --- compatibility\n# ===================================================================\n\n\ndef reload_module(module):\n    \"\"\"Backport of importlib.reload of Python 3.3+.\"\"\"\n    try:\n        import importlib\n        if not hasattr(importlib, 'reload'):  # python <=3.3\n            raise ImportError\n    except ImportError:\n        import imp\n        return imp.reload(module)\n    else:\n        return importlib.reload(module)\n\n\ndef import_module_by_path(path):\n    name = os.path.splitext(os.path.basename(path))[0]\n    if sys.version_info[0] == 2:\n        import imp\n        return imp.load_source(name, path)\n    elif sys.version_info[:2] <= (3, 4):\n        from importlib.machinery import SourceFileLoader\n        return SourceFileLoader(name, path).load_module()\n    else:\n        import importlib.util\n        spec = importlib.util.spec_from_file_location(name, path)\n        mod = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(mod)\n        return mod\n\n\n# ===================================================================\n# --- others\n# ===================================================================\n\n\ndef warn(msg):\n    \"\"\"Raise a warning msg.\"\"\"\n    warnings.warn(msg, UserWarning)\n\n\ndef is_namedtuple(x):\n    \"\"\"Check if object is an instance of namedtuple.\"\"\"\n    t = type(x)\n    b = t.__bases__\n    if len(b) != 1 or b[0] != tuple:\n        return False\n    f = getattr(t, '_fields', None)\n    if not isinstance(f, tuple):\n        return False\n    return all(type(n) == str for n in f)\n\n\nif POSIX:\n    @contextlib.contextmanager\n    def copyload_shared_lib(suffix=\"\"):\n        \"\"\"Ctx manager which picks up a random shared CO lib used\n        by this process, copies it in another location and loads it\n        in memory via ctypes. Return the new absolutized path.\n        \"\"\"\n        exe = 'pypy' if PYPY else 'python'\n        ext = \".so\"\n        dst = get_testfn(suffix=suffix + ext)\n        libs = [x.path for x in psutil.Process().memory_maps() if\n                os.path.splitext(x.path)[1] == ext and\n                exe in x.path.lower()]\n        src = random.choice(libs)\n        shutil.copyfile(src, dst)\n        try:\n            ctypes.CDLL(dst)\n            yield dst\n        finally:\n            safe_rmpath(dst)\nelse:\n    @contextlib.contextmanager\n    def copyload_shared_lib(suffix=\"\"):\n        \"\"\"Ctx manager which picks up a random shared DLL lib used\n        by this process, copies it in another location and loads it\n        in memory via ctypes.\n        Return the new absolutized, normcased path.\n        \"\"\"\n        from ctypes import wintypes\n        from ctypes import WinError\n        ext = \".dll\"\n        dst = get_testfn(suffix=suffix + ext)\n        libs = [x.path for x in psutil.Process().memory_maps() if\n                x.path.lower().endswith(ext) and\n                'python' in os.path.basename(x.path).lower() and\n                'wow64' not in x.path.lower()]\n        if PYPY and not libs:\n            libs = [x.path for x in psutil.Process().memory_maps() if\n                    'pypy' in os.path.basename(x.path).lower()]\n        src = random.choice(libs)\n        shutil.copyfile(src, dst)\n        cfile = None\n        try:\n            cfile = ctypes.WinDLL(dst)\n            yield dst\n        finally:\n            # Work around OverflowError:\n            # - https://ci.appveyor.com/project/giampaolo/psutil/build/1207/\n            #       job/o53330pbnri9bcw7\n            # - http://bugs.python.org/issue30286\n            # - http://stackoverflow.com/questions/23522055\n            if cfile is not None:\n                FreeLibrary = ctypes.windll.kernel32.FreeLibrary\n                FreeLibrary.argtypes = [wintypes.HMODULE]\n                ret = FreeLibrary(cfile._handle)\n                if ret == 0:\n                    WinError()\n            safe_rmpath(dst)\n\n\n# ===================================================================\n# --- Exit funs (first is executed last)\n# ===================================================================\n\n\n# this is executed first\n@atexit.register\ndef cleanup_test_procs():\n    reap_children(recursive=True)\n\n\n# atexit module does not execute exit functions in case of SIGTERM, which\n# gets sent to test subprocesses, which is a problem if they import this\n# module. With this it will. See:\n# https://gmpy.dev/blog/2016/how-to-always-execute-exit-functions-in-python\nif POSIX:\n    signal.signal(signal.SIGTERM, lambda sig, frame: sys.exit(sig))\n",
                "modules": {
                    "runner": {
                        "type": "module",
                        "extension": "py",
                        "code": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"\nUnit test runner, providing new features on top of unittest module:\n- colourized output\n- parallel run (UNIX only)\n- print failures/tracebacks on CTRL+C\n- re-run failed tests only (make test-failed)\n\nInvocation examples:\n- make test\n- make test-failed\n\nParallel:\n- make test-parallel\n- make test-process ARGS=--parallel\n\"\"\"\n\nfrom __future__ import print_function\nimport atexit\nimport optparse\nimport os\nimport sys\nimport textwrap\nimport time\nimport unittest\ntry:\n    import ctypes\nexcept ImportError:\n    ctypes = None\n\ntry:\n    import concurrencytest  # pip install concurrencytest\nexcept ImportError:\n    concurrencytest = None\n\nimport psutil\nfrom psutil._common import hilite\nfrom psutil._common import print_color\nfrom psutil._common import term_supports_colors\nfrom psutil._compat import super\nfrom psutil.tests import CI_TESTING\nfrom psutil.tests import import_module_by_path\nfrom psutil.tests import print_sysinfo\nfrom psutil.tests import reap_children\nfrom psutil.tests import safe_rmpath\n\n\nVERBOSITY = 2\nFAILED_TESTS_FNAME = '.failed-tests.txt'\nNWORKERS = psutil.cpu_count() or 1\nUSE_COLORS = not CI_TESTING and term_supports_colors()\n\nHERE = os.path.abspath(os.path.dirname(__file__))\nloadTestsFromTestCase = unittest.defaultTestLoader.loadTestsFromTestCase\n\n\ndef cprint(msg, color, bold=False, file=None):\n    if file is None:\n        file = sys.stderr if color == 'red' else sys.stdout\n    if USE_COLORS:\n        print_color(msg, color, bold=bold, file=file)\n    else:\n        print(msg, file=file)\n\n\nclass TestLoader:\n\n    testdir = HERE\n    skip_files = ['test_memleaks.py']\n    if \"WHEELHOUSE_UPLOADER_USERNAME\" in os.environ:\n        skip_files.extend(['test_osx.py', 'test_linux.py', 'test_posix.py'])\n\n    def _get_testmods(self):\n        return [os.path.join(self.testdir, x)\n                for x in os.listdir(self.testdir)\n                if x.startswith('test_') and x.endswith('.py') and\n                x not in self.skip_files]\n\n    def _iter_testmod_classes(self):\n        \"\"\"Iterate over all test files in this directory and return\n        all TestCase classes in them.\n        \"\"\"\n        for path in self._get_testmods():\n            mod = import_module_by_path(path)\n            for name in dir(mod):\n                obj = getattr(mod, name)\n                if isinstance(obj, type) and \\\n                        issubclass(obj, unittest.TestCase):\n                    yield obj\n\n    def all(self):\n        suite = unittest.TestSuite()\n        for obj in self._iter_testmod_classes():\n            test = loadTestsFromTestCase(obj)\n            suite.addTest(test)\n        return suite\n\n    def last_failed(self):\n        # ...from previously failed test run\n        suite = unittest.TestSuite()\n        if not os.path.isfile(FAILED_TESTS_FNAME):\n            return suite\n        with open(FAILED_TESTS_FNAME, 'rt') as f:\n            names = f.read().split()\n        for n in names:\n            test = unittest.defaultTestLoader.loadTestsFromName(n)\n            suite.addTest(test)\n        return suite\n\n    def from_name(self, name):\n        if name.endswith('.py'):\n            name = os.path.splitext(os.path.basename(name))[0]\n        return unittest.defaultTestLoader.loadTestsFromName(name)\n\n\nclass ColouredResult(unittest.TextTestResult):\n\n    def addSuccess(self, test):\n        unittest.TestResult.addSuccess(self, test)\n        cprint(\"OK\", \"green\")\n\n    def addError(self, test, err):\n        unittest.TestResult.addError(self, test, err)\n        cprint(\"ERROR\", \"red\", bold=True)\n\n    def addFailure(self, test, err):\n        unittest.TestResult.addFailure(self, test, err)\n        cprint(\"FAIL\", \"red\")\n\n    def addSkip(self, test, reason):\n        unittest.TestResult.addSkip(self, test, reason)\n        cprint(\"skipped: %s\" % reason.strip(), \"brown\")\n\n    def printErrorList(self, flavour, errors):\n        flavour = hilite(flavour, \"red\", bold=flavour == 'ERROR')\n        super().printErrorList(flavour, errors)\n\n\nclass ColouredTextRunner(unittest.TextTestRunner):\n    \"\"\"\n    A coloured text runner which also prints failed tests on KeyboardInterrupt\n    and save failed tests in a file so that they can be re-run.\n    \"\"\"\n    resultclass = ColouredResult if USE_COLORS else unittest.TextTestResult\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.failed_tnames = set()\n\n    def _makeResult(self):\n        # Store result instance so that it can be accessed on\n        # KeyboardInterrupt.\n        self.result = super()._makeResult()\n        return self.result\n\n    def _write_last_failed(self):\n        if self.failed_tnames:\n            with open(FAILED_TESTS_FNAME, 'wt') as f:\n                for tname in self.failed_tnames:\n                    f.write(tname + '\\n')\n\n    def _save_result(self, result):\n        if not result.wasSuccessful():\n            for t in result.errors + result.failures:\n                tname = t[0].id()\n                self.failed_tnames.add(tname)\n\n    def _run(self, suite):\n        try:\n            result = super().run(suite)\n        except (KeyboardInterrupt, SystemExit):\n            result = self.runner.result\n            result.printErrors()\n            raise sys.exit(1)\n        else:\n            self._save_result(result)\n            return result\n\n    def _exit(self, success):\n        if success:\n            cprint(\"SUCCESS\", \"green\", bold=True)\n            safe_rmpath(FAILED_TESTS_FNAME)\n            sys.exit(0)\n        else:\n            cprint(\"FAILED\", \"red\", bold=True)\n            self._write_last_failed()\n            sys.exit(1)\n\n    def run(self, suite):\n        result = self._run(suite)\n        self._exit(result.wasSuccessful())\n\n\nclass ParallelRunner(ColouredTextRunner):\n\n    @staticmethod\n    def _parallelize(suite):\n        def fdopen(fd, mode, *kwds):\n            stream = orig_fdopen(fd, mode)\n            atexit.register(stream.close)\n            return stream\n\n        # Monkey patch concurrencytest lib bug (fdopen() stream not closed).\n        # https://github.com/cgoldberg/concurrencytest/issues/11\n        orig_fdopen = os.fdopen\n        concurrencytest.os.fdopen = fdopen\n        forker = concurrencytest.fork_for_tests(NWORKERS)\n        return concurrencytest.ConcurrentTestSuite(suite, forker)\n\n    @staticmethod\n    def _split_suite(suite):\n        serial = unittest.TestSuite()\n        parallel = unittest.TestSuite()\n        for test in suite:\n            if test.countTestCases() == 0:\n                continue\n            elif isinstance(test, unittest.TestSuite):\n                test_class = test._tests[0].__class__\n            elif isinstance(test, unittest.TestCase):\n                test_class = test\n            else:\n                raise TypeError(\"can't recognize type %r\" % test)\n\n            if getattr(test_class, '_serialrun', False):\n                serial.addTest(test)\n            else:\n                parallel.addTest(test)\n        return (serial, parallel)\n\n    def run(self, suite):\n        ser_suite, par_suite = self._split_suite(suite)\n        par_suite = self._parallelize(par_suite)\n\n        # run parallel\n        cprint(\"starting parallel tests using %s workers\" % NWORKERS,\n               \"green\", bold=True)\n        t = time.time()\n        par = self._run(par_suite)\n        par_elapsed = time.time() - t\n\n        # At this point we should have N zombies (the workers), which\n        # will disappear with wait().\n        orphans = psutil.Process().children()\n        gone, alive = psutil.wait_procs(orphans, timeout=1)\n        if alive:\n            cprint(\"alive processes %s\" % alive, \"red\")\n            reap_children()\n\n        # run serial\n        t = time.time()\n        ser = self._run(ser_suite)\n        ser_elapsed = time.time() - t\n\n        # print\n        if not par.wasSuccessful() and ser_suite.countTestCases() > 0:\n            par.printErrors()  # print them again at the bottom\n        par_fails, par_errs, par_skips = map(len, (par.failures,\n                                                   par.errors,\n                                                   par.skipped))\n        ser_fails, ser_errs, ser_skips = map(len, (ser.failures,\n                                                   ser.errors,\n                                                   ser.skipped))\n        print(textwrap.dedent(\"\"\"\n            +----------+----------+----------+----------+----------+----------+\n            |          |    total | failures |   errors |  skipped |     time |\n            +----------+----------+----------+----------+----------+----------+\n            | parallel |      %3s |      %3s |      %3s |      %3s |    %.2fs |\n            +----------+----------+----------+----------+----------+----------+\n            | serial   |      %3s |      %3s |      %3s |      %3s |    %.2fs |\n            +----------+----------+----------+----------+----------+----------+\n            \"\"\" % (par.testsRun, par_fails, par_errs, par_skips, par_elapsed,\n                   ser.testsRun, ser_fails, ser_errs, ser_skips, ser_elapsed)))\n        print(\"Ran %s tests in %.3fs using %s workers\" % (\n            par.testsRun + ser.testsRun, par_elapsed + ser_elapsed, NWORKERS))\n        ok = par.wasSuccessful() and ser.wasSuccessful()\n        self._exit(ok)\n\n\ndef get_runner(parallel=False):\n    def warn(msg):\n        cprint(msg + \" Running serial tests instead.\", \"red\")\n    if parallel:\n        if psutil.WINDOWS:\n            warn(\"Can't run parallel tests on Windows.\")\n        elif concurrencytest is None:\n            warn(\"concurrencytest module is not installed.\")\n        elif NWORKERS == 1:\n            warn(\"Only 1 CPU available.\")\n        else:\n            return ParallelRunner(verbosity=VERBOSITY)\n    return ColouredTextRunner(verbosity=VERBOSITY)\n\n\n# Used by test_*,py modules.\ndef run_from_name(name):\n    suite = TestLoader().from_name(name)\n    runner = get_runner()\n    runner.run(suite)\n\n\ndef setup():\n    # Note: doc states that altering os.environment may cause memory\n    # leaks on some platforms.\n    # Sets PSUTIL_TESTING and PSUTIL_DEBUG in the C module.\n    psutil._psplatform.cext.set_testing()\n\n\ndef main():\n    setup()\n    usage = \"python3 -m psutil.tests [opts] [test-name]\"\n    parser = optparse.OptionParser(usage=usage, description=\"run unit tests\")\n    parser.add_option(\"--last-failed\",\n                      action=\"store_true\", default=False,\n                      help=\"only run last failed tests\")\n    parser.add_option(\"--parallel\",\n                      action=\"store_true\", default=False,\n                      help=\"run tests in parallel\")\n    opts, args = parser.parse_args()\n\n    if not opts.last_failed:\n        safe_rmpath(FAILED_TESTS_FNAME)\n\n    # loader\n    loader = TestLoader()\n    if args:\n        if len(args) > 1:\n            parser.print_usage()\n            return sys.exit(1)\n        else:\n            suite = loader.from_name(args[0])\n    elif opts.last_failed:\n        suite = loader.last_failed()\n    else:\n        suite = loader.all()\n\n    if CI_TESTING:\n        print_sysinfo()\n    runner = get_runner(opts.parallel)\n    runner.run(suite)\n\n\nif __name__ == '__main__':\n    main()\n"
                    },
                    "test_aix": {
                        "type": "module",
                        "extension": "py",
                        "code": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'\n# Copyright (c) 2017, Arnon Yaari\n# All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"AIX specific tests.\"\"\"\n\nimport re\n\nfrom psutil import AIX\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import sh\nfrom psutil.tests import unittest\nimport psutil\n\n\n@unittest.skipIf(not AIX, \"AIX only\")\nclass AIXSpecificTestCase(PsutilTestCase):\n\n    def test_virtual_memory(self):\n        out = sh('/usr/bin/svmon -O unit=KB')\n        re_pattern = r\"memory\\s*\"\n        for field in (\"size inuse free pin virtual available mmode\").split():\n            re_pattern += r\"(?P<%s>\\S+)\\s+\" % (field,)\n        matchobj = re.search(re_pattern, out)\n\n        self.assertIsNotNone(\n            matchobj, \"svmon command returned unexpected output\")\n\n        KB = 1024\n        total = int(matchobj.group(\"size\")) * KB\n        available = int(matchobj.group(\"available\")) * KB\n        used = int(matchobj.group(\"inuse\")) * KB\n        free = int(matchobj.group(\"free\")) * KB\n\n        psutil_result = psutil.virtual_memory()\n\n        # TOLERANCE_SYS_MEM from psutil.tests is not enough. For some reason\n        # we're seeing differences of ~1.2 MB. 2 MB is still a good tolerance\n        # when compared to GBs.\n        TOLERANCE_SYS_MEM = 2 * KB * KB   # 2 MB\n        self.assertEqual(psutil_result.total, total)\n        self.assertAlmostEqual(\n            psutil_result.used, used, delta=TOLERANCE_SYS_MEM)\n        self.assertAlmostEqual(\n            psutil_result.available, available, delta=TOLERANCE_SYS_MEM)\n        self.assertAlmostEqual(\n            psutil_result.free, free, delta=TOLERANCE_SYS_MEM)\n\n    def test_swap_memory(self):\n        out = sh('/usr/sbin/lsps -a')\n        # From the man page, \"The size is given in megabytes\" so we assume\n        # we'll always have 'MB' in the result\n        # TODO maybe try to use \"swap -l\" to check \"used\" too, but its units\n        # are not guaranteed to be \"MB\" so parsing may not be consistent\n        matchobj = re.search(r\"(?P<space>\\S+)\\s+\"\n                             r\"(?P<vol>\\S+)\\s+\"\n                             r\"(?P<vg>\\S+)\\s+\"\n                             r\"(?P<size>\\d+)MB\", out)\n\n        self.assertIsNotNone(\n            matchobj, \"lsps command returned unexpected output\")\n\n        total_mb = int(matchobj.group(\"size\"))\n        MB = 1024 ** 2\n        psutil_result = psutil.swap_memory()\n        # we divide our result by MB instead of multiplying the lsps value by\n        # MB because lsps may round down, so we round down too\n        self.assertEqual(int(psutil_result.total / MB), total_mb)\n\n    def test_cpu_stats(self):\n        out = sh('/usr/bin/mpstat -a')\n\n        re_pattern = r\"ALL\\s*\"\n        for field in (\"min maj mpcs mpcr dev soft dec ph cs ics bound rq \"\n                      \"push S3pull S3grd S0rd S1rd S2rd S3rd S4rd S5rd \"\n                      \"sysc\").split():\n            re_pattern += r\"(?P<%s>\\S+)\\s+\" % (field,)\n        matchobj = re.search(re_pattern, out)\n\n        self.assertIsNotNone(\n            matchobj, \"mpstat command returned unexpected output\")\n\n        # numbers are usually in the millions so 1000 is ok for tolerance\n        CPU_STATS_TOLERANCE = 1000\n        psutil_result = psutil.cpu_stats()\n        self.assertAlmostEqual(\n            psutil_result.ctx_switches,\n            int(matchobj.group(\"cs\")),\n            delta=CPU_STATS_TOLERANCE)\n        self.assertAlmostEqual(\n            psutil_result.syscalls,\n            int(matchobj.group(\"sysc\")),\n            delta=CPU_STATS_TOLERANCE)\n        self.assertAlmostEqual(\n            psutil_result.interrupts,\n            int(matchobj.group(\"dev\")),\n            delta=CPU_STATS_TOLERANCE)\n        self.assertAlmostEqual(\n            psutil_result.soft_interrupts,\n            int(matchobj.group(\"soft\")),\n            delta=CPU_STATS_TOLERANCE)\n\n    def test_cpu_count_logical(self):\n        out = sh('/usr/bin/mpstat -a')\n        mpstat_lcpu = int(re.search(r\"lcpu=(\\d+)\", out).group(1))\n        psutil_lcpu = psutil.cpu_count(logical=True)\n        self.assertEqual(mpstat_lcpu, psutil_lcpu)\n\n    def test_net_if_addrs_names(self):\n        out = sh('/etc/ifconfig -l')\n        ifconfig_names = set(out.split())\n        psutil_names = set(psutil.net_if_addrs().keys())\n        self.assertSetEqual(ifconfig_names, psutil_names)\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n    run_from_name(__file__)\n"
                    },
                    "test_bsd": {
                        "type": "module",
                        "extension": "py",
                        "code": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n# TODO: (FreeBSD) add test for comparing connections with 'sockstat' cmd.\n\n\n\"\"\"Tests specific to all BSD platforms.\"\"\"\n\n\nimport datetime\nimport os\nimport re\nimport time\n\nimport psutil\nfrom psutil import BSD\nfrom psutil import FREEBSD\nfrom psutil import NETBSD\nfrom psutil import OPENBSD\nfrom psutil.tests import spawn_testproc\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import sh\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import terminate\nfrom psutil.tests import unittest\nfrom psutil.tests import which\n\n\nif BSD:\n    from psutil._psutil_posix import getpagesize\n\n    PAGESIZE = getpagesize()\n    # muse requires root privileges\n    MUSE_AVAILABLE = True if os.getuid() == 0 and which('muse') else False\nelse:\n    PAGESIZE = None\n    MUSE_AVAILABLE = False\n\n\ndef sysctl(cmdline):\n    \"\"\"Expects a sysctl command with an argument and parse the result\n    returning only the value of interest.\n    \"\"\"\n    result = sh(\"sysctl \" + cmdline)\n    if FREEBSD:\n        result = result[result.find(\": \") + 2:]\n    elif OPENBSD or NETBSD:\n        result = result[result.find(\"=\") + 1:]\n    try:\n        return int(result)\n    except ValueError:\n        return result\n\n\ndef muse(field):\n    \"\"\"Thin wrapper around 'muse' cmdline utility.\"\"\"\n    out = sh('muse')\n    for line in out.split('\\n'):\n        if line.startswith(field):\n            break\n    else:\n        raise ValueError(\"line not found\")\n    return int(line.split()[1])\n\n\n# =====================================================================\n# --- All BSD*\n# =====================================================================\n\n\n@unittest.skipIf(not BSD, \"BSD only\")\nclass BSDTestCase(PsutilTestCase):\n    \"\"\"Generic tests common to all BSD variants.\"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        cls.pid = spawn_testproc().pid\n\n    @classmethod\n    def tearDownClass(cls):\n        terminate(cls.pid)\n\n    @unittest.skipIf(NETBSD, \"-o lstart doesn't work on NETBSD\")\n    def test_process_create_time(self):\n        output = sh(\"ps -o lstart -p %s\" % self.pid)\n        start_ps = output.replace('STARTED', '').strip()\n        start_psutil = psutil.Process(self.pid).create_time()\n        start_psutil = time.strftime(\"%a %b %e %H:%M:%S %Y\",\n                                     time.localtime(start_psutil))\n        self.assertEqual(start_ps, start_psutil)\n\n    def test_disks(self):\n        # test psutil.disk_usage() and psutil.disk_partitions()\n        # against \"df -a\"\n        def df(path):\n            out = sh('df -k \"%s\"' % path).strip()\n            lines = out.split('\\n')\n            lines.pop(0)\n            line = lines.pop(0)\n            dev, total, used, free = line.split()[:4]\n            if dev == 'none':\n                dev = ''\n            total = int(total) * 1024\n            used = int(used) * 1024\n            free = int(free) * 1024\n            return dev, total, used, free\n\n        for part in psutil.disk_partitions(all=False):\n            usage = psutil.disk_usage(part.mountpoint)\n            dev, total, used, free = df(part.mountpoint)\n            self.assertEqual(part.device, dev)\n            self.assertEqual(usage.total, total)\n            # 10 MB tollerance\n            if abs(usage.free - free) > 10 * 1024 * 1024:\n                self.fail(\"psutil=%s, df=%s\" % (usage.free, free))\n            if abs(usage.used - used) > 10 * 1024 * 1024:\n                self.fail(\"psutil=%s, df=%s\" % (usage.used, used))\n\n    @unittest.skipIf(not which('sysctl'), \"sysctl cmd not available\")\n    def test_cpu_count_logical(self):\n        syst = sysctl(\"hw.ncpu\")\n        self.assertEqual(psutil.cpu_count(logical=True), syst)\n\n    @unittest.skipIf(not which('sysctl'), \"sysctl cmd not available\")\n    def test_virtual_memory_total(self):\n        num = sysctl('hw.physmem')\n        self.assertEqual(num, psutil.virtual_memory().total)\n\n    def test_net_if_stats(self):\n        for name, stats in psutil.net_if_stats().items():\n            try:\n                out = sh(\"ifconfig %s\" % name)\n            except RuntimeError:\n                pass\n            else:\n                self.assertEqual(stats.isup, 'RUNNING' in out, msg=out)\n                if \"mtu\" in out:\n                    self.assertEqual(stats.mtu,\n                                     int(re.findall(r'mtu (\\d+)', out)[0]))\n\n\n# =====================================================================\n# --- FreeBSD\n# =====================================================================\n\n\n@unittest.skipIf(not FREEBSD, \"FREEBSD only\")\nclass FreeBSDPsutilTestCase(PsutilTestCase):\n\n    @classmethod\n    def setUpClass(cls):\n        cls.pid = spawn_testproc().pid\n\n    @classmethod\n    def tearDownClass(cls):\n        terminate(cls.pid)\n\n    @retry_on_failure()\n    def test_memory_maps(self):\n        out = sh('procstat -v %s' % self.pid)\n        maps = psutil.Process(self.pid).memory_maps(grouped=False)\n        lines = out.split('\\n')[1:]\n        while lines:\n            line = lines.pop()\n            fields = line.split()\n            _, start, stop, perms, res = fields[:5]\n            map = maps.pop()\n            self.assertEqual(\"%s-%s\" % (start, stop), map.addr)\n            self.assertEqual(int(res), map.rss)\n            if not map.path.startswith('['):\n                self.assertEqual(fields[10], map.path)\n\n    def test_exe(self):\n        out = sh('procstat -b %s' % self.pid)\n        self.assertEqual(psutil.Process(self.pid).exe(),\n                         out.split('\\n')[1].split()[-1])\n\n    def test_cmdline(self):\n        out = sh('procstat -c %s' % self.pid)\n        self.assertEqual(' '.join(psutil.Process(self.pid).cmdline()),\n                         ' '.join(out.split('\\n')[1].split()[2:]))\n\n    def test_uids_gids(self):\n        out = sh('procstat -s %s' % self.pid)\n        euid, ruid, suid, egid, rgid, sgid = out.split('\\n')[1].split()[2:8]\n        p = psutil.Process(self.pid)\n        uids = p.uids()\n        gids = p.gids()\n        self.assertEqual(uids.real, int(ruid))\n        self.assertEqual(uids.effective, int(euid))\n        self.assertEqual(uids.saved, int(suid))\n        self.assertEqual(gids.real, int(rgid))\n        self.assertEqual(gids.effective, int(egid))\n        self.assertEqual(gids.saved, int(sgid))\n\n    @retry_on_failure()\n    def test_ctx_switches(self):\n        tested = []\n        out = sh('procstat -r %s' % self.pid)\n        p = psutil.Process(self.pid)\n        for line in out.split('\\n'):\n            line = line.lower().strip()\n            if ' voluntary context' in line:\n                pstat_value = int(line.split()[-1])\n                psutil_value = p.num_ctx_switches().voluntary\n                self.assertEqual(pstat_value, psutil_value)\n                tested.append(None)\n            elif ' involuntary context' in line:\n                pstat_value = int(line.split()[-1])\n                psutil_value = p.num_ctx_switches().involuntary\n                self.assertEqual(pstat_value, psutil_value)\n                tested.append(None)\n        if len(tested) != 2:\n            raise RuntimeError(\"couldn't find lines match in procstat out\")\n\n    @retry_on_failure()\n    def test_cpu_times(self):\n        tested = []\n        out = sh('procstat -r %s' % self.pid)\n        p = psutil.Process(self.pid)\n        for line in out.split('\\n'):\n            line = line.lower().strip()\n            if 'user time' in line:\n                pstat_value = float('0.' + line.split()[-1].split('.')[-1])\n                psutil_value = p.cpu_times().user\n                self.assertEqual(pstat_value, psutil_value)\n                tested.append(None)\n            elif 'system time' in line:\n                pstat_value = float('0.' + line.split()[-1].split('.')[-1])\n                psutil_value = p.cpu_times().system\n                self.assertEqual(pstat_value, psutil_value)\n                tested.append(None)\n        if len(tested) != 2:\n            raise RuntimeError(\"couldn't find lines match in procstat out\")\n\n\n@unittest.skipIf(not FREEBSD, \"FREEBSD only\")\nclass FreeBSDSystemTestCase(PsutilTestCase):\n\n    @staticmethod\n    def parse_swapinfo():\n        # the last line is always the total\n        output = sh(\"swapinfo -k\").splitlines()[-1]\n        parts = re.split(r'\\s+', output)\n\n        if not parts:\n            raise ValueError(\"Can't parse swapinfo: %s\" % output)\n\n        # the size is in 1k units, so multiply by 1024\n        total, used, free = (int(p) * 1024 for p in parts[1:4])\n        return total, used, free\n\n    def test_cpu_frequency_against_sysctl(self):\n        # Currently only cpu 0 is frequency is supported in FreeBSD\n        # All other cores use the same frequency.\n        sensor = \"dev.cpu.0.freq\"\n        try:\n            sysctl_result = int(sysctl(sensor))\n        except RuntimeError:\n            self.skipTest(\"frequencies not supported by kernel\")\n        self.assertEqual(psutil.cpu_freq().current, sysctl_result)\n\n        sensor = \"dev.cpu.0.freq_levels\"\n        sysctl_result = sysctl(sensor)\n        # sysctl returns a string of the format:\n        # <freq_level_1>/<voltage_level_1> <freq_level_2>/<voltage_level_2>...\n        # Ordered highest available to lowest available.\n        max_freq = int(sysctl_result.split()[0].split(\"/\")[0])\n        min_freq = int(sysctl_result.split()[-1].split(\"/\")[0])\n        self.assertEqual(psutil.cpu_freq().max, max_freq)\n        self.assertEqual(psutil.cpu_freq().min, min_freq)\n\n    # --- virtual_memory(); tests against sysctl\n\n    @retry_on_failure()\n    def test_vmem_active(self):\n        syst = sysctl(\"vm.stats.vm.v_active_count\") * PAGESIZE\n        self.assertAlmostEqual(psutil.virtual_memory().active, syst,\n                               delta=TOLERANCE_SYS_MEM)\n\n    @retry_on_failure()\n    def test_vmem_inactive(self):\n        syst = sysctl(\"vm.stats.vm.v_inactive_count\") * PAGESIZE\n        self.assertAlmostEqual(psutil.virtual_memory().inactive, syst,\n                               delta=TOLERANCE_SYS_MEM)\n\n    @retry_on_failure()\n    def test_vmem_wired(self):\n        syst = sysctl(\"vm.stats.vm.v_wire_count\") * PAGESIZE\n        self.assertAlmostEqual(psutil.virtual_memory().wired, syst,\n                               delta=TOLERANCE_SYS_MEM)\n\n    @retry_on_failure()\n    def test_vmem_cached(self):\n        syst = sysctl(\"vm.stats.vm.v_cache_count\") * PAGESIZE\n        self.assertAlmostEqual(psutil.virtual_memory().cached, syst,\n                               delta=TOLERANCE_SYS_MEM)\n\n    @retry_on_failure()\n    def test_vmem_free(self):\n        syst = sysctl(\"vm.stats.vm.v_free_count\") * PAGESIZE\n        self.assertAlmostEqual(psutil.virtual_memory().free, syst,\n                               delta=TOLERANCE_SYS_MEM)\n\n    @retry_on_failure()\n    def test_vmem_buffers(self):\n        syst = sysctl(\"vfs.bufspace\")\n        self.assertAlmostEqual(psutil.virtual_memory().buffers, syst,\n                               delta=TOLERANCE_SYS_MEM)\n\n    # --- virtual_memory(); tests against muse\n\n    @unittest.skipIf(not MUSE_AVAILABLE, \"muse not installed\")\n    def test_muse_vmem_total(self):\n        num = muse('Total')\n        self.assertEqual(psutil.virtual_memory().total, num)\n\n    @unittest.skipIf(not MUSE_AVAILABLE, \"muse not installed\")\n    @retry_on_failure()\n    def test_muse_vmem_active(self):\n        num = muse('Active')\n        self.assertAlmostEqual(psutil.virtual_memory().active, num,\n                               delta=TOLERANCE_SYS_MEM)\n\n    @unittest.skipIf(not MUSE_AVAILABLE, \"muse not installed\")\n    @retry_on_failure()\n    def test_muse_vmem_inactive(self):\n        num = muse('Inactive')\n        self.assertAlmostEqual(psutil.virtual_memory().inactive, num,\n                               delta=TOLERANCE_SYS_MEM)\n\n    @unittest.skipIf(not MUSE_AVAILABLE, \"muse not installed\")\n    @retry_on_failure()\n    def test_muse_vmem_wired(self):\n        num = muse('Wired')\n        self.assertAlmostEqual(psutil.virtual_memory().wired, num,\n                               delta=TOLERANCE_SYS_MEM)\n\n    @unittest.skipIf(not MUSE_AVAILABLE, \"muse not installed\")\n    @retry_on_failure()\n    def test_muse_vmem_cached(self):\n        num = muse('Cache')\n        self.assertAlmostEqual(psutil.virtual_memory().cached, num,\n                               delta=TOLERANCE_SYS_MEM)\n\n    @unittest.skipIf(not MUSE_AVAILABLE, \"muse not installed\")\n    @retry_on_failure()\n    def test_muse_vmem_free(self):\n        num = muse('Free')\n        self.assertAlmostEqual(psutil.virtual_memory().free, num,\n                               delta=TOLERANCE_SYS_MEM)\n\n    @unittest.skipIf(not MUSE_AVAILABLE, \"muse not installed\")\n    @retry_on_failure()\n    def test_muse_vmem_buffers(self):\n        num = muse('Buffer')\n        self.assertAlmostEqual(psutil.virtual_memory().buffers, num,\n                               delta=TOLERANCE_SYS_MEM)\n\n    def test_cpu_stats_ctx_switches(self):\n        self.assertAlmostEqual(psutil.cpu_stats().ctx_switches,\n                               sysctl('vm.stats.sys.v_swtch'), delta=1000)\n\n    def test_cpu_stats_interrupts(self):\n        self.assertAlmostEqual(psutil.cpu_stats().interrupts,\n                               sysctl('vm.stats.sys.v_intr'), delta=1000)\n\n    def test_cpu_stats_soft_interrupts(self):\n        self.assertAlmostEqual(psutil.cpu_stats().soft_interrupts,\n                               sysctl('vm.stats.sys.v_soft'), delta=1000)\n\n    @retry_on_failure()\n    def test_cpu_stats_syscalls(self):\n        # pretty high tolerance but it looks like it's OK.\n        self.assertAlmostEqual(psutil.cpu_stats().syscalls,\n                               sysctl('vm.stats.sys.v_syscall'), delta=200000)\n\n    # def test_cpu_stats_traps(self):\n    #    self.assertAlmostEqual(psutil.cpu_stats().traps,\n    #                           sysctl('vm.stats.sys.v_trap'), delta=1000)\n\n    # --- swap memory\n\n    def test_swapmem_free(self):\n        total, used, free = self.parse_swapinfo()\n        self.assertAlmostEqual(\n            psutil.swap_memory().free, free, delta=TOLERANCE_SYS_MEM)\n\n    def test_swapmem_used(self):\n        total, used, free = self.parse_swapinfo()\n        self.assertAlmostEqual(\n            psutil.swap_memory().used, used, delta=TOLERANCE_SYS_MEM)\n\n    def test_swapmem_total(self):\n        total, used, free = self.parse_swapinfo()\n        self.assertAlmostEqual(\n            psutil.swap_memory().total, total, delta=TOLERANCE_SYS_MEM)\n\n    # --- others\n\n    def test_boot_time(self):\n        s = sysctl('sysctl kern.boottime')\n        s = s[s.find(\" sec = \") + 7:]\n        s = s[:s.find(',')]\n        btime = int(s)\n        self.assertEqual(btime, psutil.boot_time())\n\n    # --- sensors_battery\n\n    @unittest.skipIf(not HAS_BATTERY, \"no battery\")\n    def test_sensors_battery(self):\n        def secs2hours(secs):\n            m, s = divmod(secs, 60)\n            h, m = divmod(m, 60)\n            return \"%d:%02d\" % (h, m)\n\n        out = sh(\"acpiconf -i 0\")\n        fields = dict([(x.split('\\t')[0], x.split('\\t')[-1])\n                       for x in out.split(\"\\n\")])\n        metrics = psutil.sensors_battery()\n        percent = int(fields['Remaining capacity:'].replace('%', ''))\n        remaining_time = fields['Remaining time:']\n        self.assertEqual(metrics.percent, percent)\n        if remaining_time == 'unknown':\n            self.assertEqual(metrics.secsleft, psutil.POWER_TIME_UNLIMITED)\n        else:\n            self.assertEqual(secs2hours(metrics.secsleft), remaining_time)\n\n    @unittest.skipIf(not HAS_BATTERY, \"no battery\")\n    def test_sensors_battery_against_sysctl(self):\n        self.assertEqual(psutil.sensors_battery().percent,\n                         sysctl(\"hw.acpi.battery.life\"))\n        self.assertEqual(psutil.sensors_battery().power_plugged,\n                         sysctl(\"hw.acpi.acline\") == 1)\n        secsleft = psutil.sensors_battery().secsleft\n        if secsleft < 0:\n            self.assertEqual(sysctl(\"hw.acpi.battery.time\"), -1)\n        else:\n            self.assertEqual(secsleft, sysctl(\"hw.acpi.battery.time\") * 60)\n\n    @unittest.skipIf(HAS_BATTERY, \"has battery\")\n    def test_sensors_battery_no_battery(self):\n        # If no battery is present one of these calls is supposed\n        # to fail, see:\n        # https://github.com/giampaolo/psutil/issues/1074\n        with self.assertRaises(RuntimeError):\n            sysctl(\"hw.acpi.battery.life\")\n            sysctl(\"hw.acpi.battery.time\")\n            sysctl(\"hw.acpi.acline\")\n        self.assertIsNone(psutil.sensors_battery())\n\n    # --- sensors_temperatures\n\n    def test_sensors_temperatures_against_sysctl(self):\n        num_cpus = psutil.cpu_count(True)\n        for cpu in range(num_cpus):\n            sensor = \"dev.cpu.%s.temperature\" % cpu\n            # sysctl returns a string in the format 46.0C\n            try:\n                sysctl_result = int(float(sysctl(sensor)[:-1]))\n            except RuntimeError:\n                self.skipTest(\"temperatures not supported by kernel\")\n            self.assertAlmostEqual(\n                psutil.sensors_temperatures()[\"coretemp\"][cpu].current,\n                sysctl_result, delta=10)\n\n            sensor = \"dev.cpu.%s.coretemp.tjmax\" % cpu\n            sysctl_result = int(float(sysctl(sensor)[:-1]))\n            self.assertEqual(\n                psutil.sensors_temperatures()[\"coretemp\"][cpu].high,\n                sysctl_result)\n\n\n# =====================================================================\n# --- OpenBSD\n# =====================================================================\n\n\n@unittest.skipIf(not OPENBSD, \"OPENBSD only\")\nclass OpenBSDTestCase(PsutilTestCase):\n\n    def test_boot_time(self):\n        s = sysctl('kern.boottime')\n        sys_bt = datetime.datetime.strptime(s, \"%a %b %d %H:%M:%S %Y\")\n        psutil_bt = datetime.datetime.fromtimestamp(psutil.boot_time())\n        self.assertEqual(sys_bt, psutil_bt)\n\n\n# =====================================================================\n# --- NetBSD\n# =====================================================================\n\n\n@unittest.skipIf(not NETBSD, \"NETBSD only\")\nclass NetBSDTestCase(PsutilTestCase):\n\n    @staticmethod\n    def parse_meminfo(look_for):\n        with open('/proc/meminfo', 'rt') as f:\n            for line in f:\n                if line.startswith(look_for):\n                    return int(line.split()[1]) * 1024\n        raise ValueError(\"can't find %s\" % look_for)\n\n    def test_vmem_total(self):\n        self.assertEqual(\n            psutil.virtual_memory().total, self.parse_meminfo(\"MemTotal:\"))\n\n    def test_vmem_free(self):\n        self.assertAlmostEqual(\n            psutil.virtual_memory().free, self.parse_meminfo(\"MemFree:\"),\n            delta=TOLERANCE_SYS_MEM)\n\n    def test_vmem_buffers(self):\n        self.assertAlmostEqual(\n            psutil.virtual_memory().buffers, self.parse_meminfo(\"Buffers:\"),\n            delta=TOLERANCE_SYS_MEM)\n\n    def test_vmem_shared(self):\n        self.assertAlmostEqual(\n            psutil.virtual_memory().shared, self.parse_meminfo(\"MemShared:\"),\n            delta=TOLERANCE_SYS_MEM)\n\n    def test_swapmem_total(self):\n        self.assertAlmostEqual(\n            psutil.swap_memory().total, self.parse_meminfo(\"SwapTotal:\"),\n            delta=TOLERANCE_SYS_MEM)\n\n    def test_swapmem_free(self):\n        self.assertAlmostEqual(\n            psutil.swap_memory().free, self.parse_meminfo(\"SwapFree:\"),\n            delta=TOLERANCE_SYS_MEM)\n\n    def test_swapmem_used(self):\n        smem = psutil.swap_memory()\n        self.assertEqual(smem.used, smem.total - smem.free)\n\n    def test_cpu_stats_interrupts(self):\n        with open('/proc/stat', 'rb') as f:\n            for line in f:\n                if line.startswith(b'intr'):\n                    interrupts = int(line.split()[1])\n                    break\n            else:\n                raise ValueError(\"couldn't find line\")\n        self.assertAlmostEqual(\n            psutil.cpu_stats().interrupts, interrupts, delta=1000)\n\n    def test_cpu_stats_ctx_switches(self):\n        with open('/proc/stat', 'rb') as f:\n            for line in f:\n                if line.startswith(b'ctxt'):\n                    ctx_switches = int(line.split()[1])\n                    break\n            else:\n                raise ValueError(\"couldn't find line\")\n        self.assertAlmostEqual(\n            psutil.cpu_stats().ctx_switches, ctx_switches, delta=1000)\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n    run_from_name(__file__)\n"
                    },
                    "test_connections": {
                        "type": "module",
                        "extension": "py",
                        "code": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Tests for net_connections() and Process.connections() APIs.\"\"\"\n\nimport os\nimport socket\nimport sys\nimport textwrap\nfrom contextlib import closing\nfrom socket import AF_INET\nfrom socket import AF_INET6\nfrom socket import SOCK_DGRAM\nfrom socket import SOCK_STREAM\n\nimport psutil\nfrom psutil import FREEBSD\nfrom psutil import LINUX\nfrom psutil import MACOS\nfrom psutil import NETBSD\nfrom psutil import OPENBSD\nfrom psutil import POSIX\nfrom psutil import SUNOS\nfrom psutil import WINDOWS\nfrom psutil._common import supports_ipv6\nfrom psutil._compat import PY3\nfrom psutil.tests import AF_UNIX\nfrom psutil.tests import bind_socket\nfrom psutil.tests import bind_unix_socket\nfrom psutil.tests import check_connection_ntuple\nfrom psutil.tests import create_sockets\nfrom psutil.tests import HAS_CONNECTIONS_UNIX\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import reap_children\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import serialrun\nfrom psutil.tests import skip_on_access_denied\nfrom psutil.tests import SKIP_SYSCONS\nfrom psutil.tests import tcp_socketpair\nfrom psutil.tests import unittest\nfrom psutil.tests import unix_socketpair\nfrom psutil.tests import wait_for_file\n\n\nthisproc = psutil.Process()\nSOCK_SEQPACKET = getattr(socket, \"SOCK_SEQPACKET\", object())\nPYTHON_39 = sys.version_info[:2] == (3, 9)\n\n\n@serialrun\nclass ConnectionTestCase(PsutilTestCase):\n\n    def setUp(self):\n        if not (NETBSD or FREEBSD):\n            # process opens a UNIX socket to /var/log/run.\n            cons = thisproc.connections(kind='all')\n            assert not cons, cons\n\n    def tearDown(self):\n        if not (FREEBSD or NETBSD):\n            # Make sure we closed all resources.\n            # NetBSD opens a UNIX socket to /var/log/run.\n            cons = thisproc.connections(kind='all')\n            assert not cons, cons\n\n    def compare_procsys_connections(self, pid, proc_cons, kind='all'):\n        \"\"\"Given a process PID and its list of connections compare\n        those against system-wide connections retrieved via\n        psutil.net_connections.\n        \"\"\"\n        try:\n            sys_cons = psutil.net_connections(kind=kind)\n        except psutil.AccessDenied:\n            # On MACOS, system-wide connections are retrieved by iterating\n            # over all processes\n            if MACOS:\n                return\n            else:\n                raise\n        # Filter for this proc PID and exlucde PIDs from the tuple.\n        sys_cons = [c[:-1] for c in sys_cons if c.pid == pid]\n        sys_cons.sort()\n        proc_cons.sort()\n        self.assertEqual(proc_cons, sys_cons)\n\n\nclass TestBasicOperations(ConnectionTestCase):\n\n    @unittest.skipIf(SKIP_SYSCONS, \"requires root\")\n    def test_system(self):\n        with create_sockets():\n            for conn in psutil.net_connections(kind='all'):\n                check_connection_ntuple(conn)\n\n    def test_process(self):\n        with create_sockets():\n            for conn in psutil.Process().connections(kind='all'):\n                check_connection_ntuple(conn)\n\n    def test_invalid_kind(self):\n        self.assertRaises(ValueError, thisproc.connections, kind='???')\n        self.assertRaises(ValueError, psutil.net_connections, kind='???')\n\n\n@serialrun\nclass TestUnconnectedSockets(ConnectionTestCase):\n    \"\"\"Tests sockets which are open but not connected to anything.\"\"\"\n\n    def get_conn_from_sock(self, sock):\n        cons = thisproc.connections(kind='all')\n        smap = dict([(c.fd, c) for c in cons])\n        if NETBSD or FREEBSD:\n            # NetBSD opens a UNIX socket to /var/log/run\n            # so there may be more connections.\n            return smap[sock.fileno()]\n        else:\n            self.assertEqual(len(cons), 1)\n            if cons[0].fd != -1:\n                self.assertEqual(smap[sock.fileno()].fd, sock.fileno())\n            return cons[0]\n\n    def check_socket(self, sock):\n        \"\"\"Given a socket, makes sure it matches the one obtained\n        via psutil. It assumes this process created one connection\n        only (the one supposed to be checked).\n        \"\"\"\n        conn = self.get_conn_from_sock(sock)\n        check_connection_ntuple(conn)\n\n        # fd, family, type\n        if conn.fd != -1:\n            self.assertEqual(conn.fd, sock.fileno())\n        self.assertEqual(conn.family, sock.family)\n        # see: http://bugs.python.org/issue30204\n        self.assertEqual(\n            conn.type, sock.getsockopt(socket.SOL_SOCKET, socket.SO_TYPE))\n\n        # local address\n        laddr = sock.getsockname()\n        if not laddr and PY3 and isinstance(laddr, bytes):\n            # See: http://bugs.python.org/issue30205\n            laddr = laddr.decode()\n        if sock.family == AF_INET6:\n            laddr = laddr[:2]\n        if sock.family == AF_UNIX and OPENBSD:\n            # No addresses are set for UNIX sockets on OpenBSD.\n            pass\n        else:\n            self.assertEqual(conn.laddr, laddr)\n\n        # XXX Solaris can't retrieve system-wide UNIX sockets\n        if sock.family == AF_UNIX and HAS_CONNECTIONS_UNIX:\n            cons = thisproc.connections(kind='all')\n            self.compare_procsys_connections(os.getpid(), cons, kind='all')\n        return conn\n\n    def test_tcp_v4(self):\n        addr = (\"127.0.0.1\", 0)\n        with closing(bind_socket(AF_INET, SOCK_STREAM, addr=addr)) as sock:\n            conn = self.check_socket(sock)\n            assert not conn.raddr\n            self.assertEqual(conn.status, psutil.CONN_LISTEN)\n\n    @unittest.skipIf(not supports_ipv6(), \"IPv6 not supported\")\n    def test_tcp_v6(self):\n        addr = (\"::1\", 0)\n        with closing(bind_socket(AF_INET6, SOCK_STREAM, addr=addr)) as sock:\n            conn = self.check_socket(sock)\n            assert not conn.raddr\n            self.assertEqual(conn.status, psutil.CONN_LISTEN)\n\n    def test_udp_v4(self):\n        addr = (\"127.0.0.1\", 0)\n        with closing(bind_socket(AF_INET, SOCK_DGRAM, addr=addr)) as sock:\n            conn = self.check_socket(sock)\n            assert not conn.raddr\n            self.assertEqual(conn.status, psutil.CONN_NONE)\n\n    @unittest.skipIf(not supports_ipv6(), \"IPv6 not supported\")\n    def test_udp_v6(self):\n        addr = (\"::1\", 0)\n        with closing(bind_socket(AF_INET6, SOCK_DGRAM, addr=addr)) as sock:\n            conn = self.check_socket(sock)\n            assert not conn.raddr\n            self.assertEqual(conn.status, psutil.CONN_NONE)\n\n    @unittest.skipIf(not POSIX, 'POSIX only')\n    def test_unix_tcp(self):\n        testfn = self.get_testfn()\n        with closing(bind_unix_socket(testfn, type=SOCK_STREAM)) as sock:\n            conn = self.check_socket(sock)\n            assert not conn.raddr\n            self.assertEqual(conn.status, psutil.CONN_NONE)\n\n    @unittest.skipIf(not POSIX, 'POSIX only')\n    def test_unix_udp(self):\n        testfn = self.get_testfn()\n        with closing(bind_unix_socket(testfn, type=SOCK_STREAM)) as sock:\n            conn = self.check_socket(sock)\n            assert not conn.raddr\n            self.assertEqual(conn.status, psutil.CONN_NONE)\n\n\n@serialrun\nclass TestConnectedSocket(ConnectionTestCase):\n    \"\"\"Test socket pairs which are are actually connected to\n    each other.\n    \"\"\"\n\n    # On SunOS, even after we close() it, the server socket stays around\n    # in TIME_WAIT state.\n    @unittest.skipIf(SUNOS, \"unreliable on SUONS\")\n    def test_tcp(self):\n        addr = (\"127.0.0.1\", 0)\n        assert not thisproc.connections(kind='tcp4')\n        server, client = tcp_socketpair(AF_INET, addr=addr)\n        try:\n            cons = thisproc.connections(kind='tcp4')\n            self.assertEqual(len(cons), 2)\n            self.assertEqual(cons[0].status, psutil.CONN_ESTABLISHED)\n            self.assertEqual(cons[1].status, psutil.CONN_ESTABLISHED)\n            # May not be fast enough to change state so it stays\n            # commenteed.\n            # client.close()\n            # cons = thisproc.connections(kind='all')\n            # self.assertEqual(len(cons), 1)\n            # self.assertEqual(cons[0].status, psutil.CONN_CLOSE_WAIT)\n        finally:\n            server.close()\n            client.close()\n\n    @unittest.skipIf(not POSIX, 'POSIX only')\n    def test_unix(self):\n        testfn = self.get_testfn()\n        server, client = unix_socketpair(testfn)\n        try:\n            cons = thisproc.connections(kind='unix')\n            assert not (cons[0].laddr and cons[0].raddr)\n            assert not (cons[1].laddr and cons[1].raddr)\n            if NETBSD or FREEBSD:\n                # On NetBSD creating a UNIX socket will cause\n                # a UNIX connection to  /var/run/log.\n                cons = [c for c in cons if c.raddr != '/var/run/log']\n            self.assertEqual(len(cons), 2, msg=cons)\n            if LINUX or FREEBSD or SUNOS:\n                # remote path is never set\n                self.assertEqual(cons[0].raddr, \"\")\n                self.assertEqual(cons[1].raddr, \"\")\n                # one local address should though\n                self.assertEqual(testfn, cons[0].laddr or cons[1].laddr)\n            elif OPENBSD:\n                # No addresses whatsoever here.\n                for addr in (cons[0].laddr, cons[0].raddr,\n                             cons[1].laddr, cons[1].raddr):\n                    self.assertEqual(addr, \"\")\n            else:\n                # On other systems either the laddr or raddr\n                # of both peers are set.\n                self.assertEqual(cons[0].laddr or cons[1].laddr, testfn)\n                self.assertEqual(cons[0].raddr or cons[1].raddr, testfn)\n        finally:\n            server.close()\n            client.close()\n\n\nclass TestFilters(ConnectionTestCase):\n\n    def test_filters(self):\n        def check(kind, families, types):\n            for conn in thisproc.connections(kind=kind):\n                self.assertIn(conn.family, families)\n                self.assertIn(conn.type, types)\n            if not SKIP_SYSCONS:\n                for conn in psutil.net_connections(kind=kind):\n                    self.assertIn(conn.family, families)\n                    self.assertIn(conn.type, types)\n\n        with create_sockets():\n            check('all',\n                  [AF_INET, AF_INET6, AF_UNIX],\n                  [SOCK_STREAM, SOCK_DGRAM, SOCK_SEQPACKET])\n            check('inet',\n                  [AF_INET, AF_INET6],\n                  [SOCK_STREAM, SOCK_DGRAM])\n            check('inet4',\n                  [AF_INET],\n                  [SOCK_STREAM, SOCK_DGRAM])\n            check('tcp',\n                  [AF_INET, AF_INET6],\n                  [SOCK_STREAM])\n            check('tcp4',\n                  [AF_INET],\n                  [SOCK_STREAM])\n            check('tcp6',\n                  [AF_INET6],\n                  [SOCK_STREAM])\n            check('udp',\n                  [AF_INET, AF_INET6],\n                  [SOCK_DGRAM])\n            check('udp4',\n                  [AF_INET],\n                  [SOCK_DGRAM])\n            check('udp6',\n                  [AF_INET6],\n                  [SOCK_DGRAM])\n            if HAS_CONNECTIONS_UNIX:\n                check('unix',\n                      [AF_UNIX],\n                      [SOCK_STREAM, SOCK_DGRAM, SOCK_SEQPACKET])\n\n    @skip_on_access_denied(only_if=MACOS)\n    def test_combos(self):\n        reap_children()\n\n        def check_conn(proc, conn, family, type, laddr, raddr, status, kinds):\n            all_kinds = (\"all\", \"inet\", \"inet4\", \"inet6\", \"tcp\", \"tcp4\",\n                         \"tcp6\", \"udp\", \"udp4\", \"udp6\")\n            check_connection_ntuple(conn)\n            self.assertEqual(conn.family, family)\n            self.assertEqual(conn.type, type)\n            self.assertEqual(conn.laddr, laddr)\n            self.assertEqual(conn.raddr, raddr)\n            self.assertEqual(conn.status, status)\n            for kind in all_kinds:\n                cons = proc.connections(kind=kind)\n                if kind in kinds:\n                    assert cons\n                else:\n                    assert not cons, cons\n            # compare against system-wide connections\n            # XXX Solaris can't retrieve system-wide UNIX\n            # sockets.\n            if HAS_CONNECTIONS_UNIX:\n                self.compare_procsys_connections(proc.pid, [conn])\n\n        tcp_template = textwrap.dedent(\"\"\"\n            import socket, time\n            s = socket.socket({family}, socket.SOCK_STREAM)\n            s.bind(('{addr}', 0))\n            s.listen(5)\n            with open('{testfn}', 'w') as f:\n                f.write(str(s.getsockname()[:2]))\n            time.sleep(60)\n            \"\"\")\n\n        udp_template = textwrap.dedent(\"\"\"\n            import socket, time\n            s = socket.socket({family}, socket.SOCK_DGRAM)\n            s.bind(('{addr}', 0))\n            with open('{testfn}', 'w') as f:\n                f.write(str(s.getsockname()[:2]))\n            time.sleep(60)\n            \"\"\")\n\n        # must be relative on Windows\n        testfile = os.path.basename(self.get_testfn(dir=os.getcwd()))\n        tcp4_template = tcp_template.format(\n            family=int(AF_INET), addr=\"127.0.0.1\", testfn=testfile)\n        udp4_template = udp_template.format(\n            family=int(AF_INET), addr=\"127.0.0.1\", testfn=testfile)\n        tcp6_template = tcp_template.format(\n            family=int(AF_INET6), addr=\"::1\", testfn=testfile)\n        udp6_template = udp_template.format(\n            family=int(AF_INET6), addr=\"::1\", testfn=testfile)\n\n        # launch various subprocess instantiating a socket of various\n        # families and types to enrich psutil results\n        tcp4_proc = self.pyrun(tcp4_template)\n        tcp4_addr = eval(wait_for_file(testfile, delete=True))\n        udp4_proc = self.pyrun(udp4_template)\n        udp4_addr = eval(wait_for_file(testfile, delete=True))\n        if supports_ipv6():\n            tcp6_proc = self.pyrun(tcp6_template)\n            tcp6_addr = eval(wait_for_file(testfile, delete=True))\n            udp6_proc = self.pyrun(udp6_template)\n            udp6_addr = eval(wait_for_file(testfile, delete=True))\n        else:\n            tcp6_proc = None\n            udp6_proc = None\n            tcp6_addr = None\n            udp6_addr = None\n\n        for p in thisproc.children():\n            cons = p.connections()\n            self.assertEqual(len(cons), 1)\n            for conn in cons:\n                # TCP v4\n                if p.pid == tcp4_proc.pid:\n                    check_conn(p, conn, AF_INET, SOCK_STREAM, tcp4_addr, (),\n                               psutil.CONN_LISTEN,\n                               (\"all\", \"inet\", \"inet4\", \"tcp\", \"tcp4\"))\n                # UDP v4\n                elif p.pid == udp4_proc.pid:\n                    check_conn(p, conn, AF_INET, SOCK_DGRAM, udp4_addr, (),\n                               psutil.CONN_NONE,\n                               (\"all\", \"inet\", \"inet4\", \"udp\", \"udp4\"))\n                # TCP v6\n                elif p.pid == getattr(tcp6_proc, \"pid\", None):\n                    check_conn(p, conn, AF_INET6, SOCK_STREAM, tcp6_addr, (),\n                               psutil.CONN_LISTEN,\n                               (\"all\", \"inet\", \"inet6\", \"tcp\", \"tcp6\"))\n                # UDP v6\n                elif p.pid == getattr(udp6_proc, \"pid\", None):\n                    check_conn(p, conn, AF_INET6, SOCK_DGRAM, udp6_addr, (),\n                               psutil.CONN_NONE,\n                               (\"all\", \"inet\", \"inet6\", \"udp\", \"udp6\"))\n\n    def test_count(self):\n        with create_sockets():\n            # tcp\n            cons = thisproc.connections(kind='tcp')\n            self.assertEqual(len(cons), 2 if supports_ipv6() else 1)\n            for conn in cons:\n                self.assertIn(conn.family, (AF_INET, AF_INET6))\n                self.assertEqual(conn.type, SOCK_STREAM)\n            # tcp4\n            cons = thisproc.connections(kind='tcp4')\n            self.assertEqual(len(cons), 1)\n            self.assertEqual(cons[0].family, AF_INET)\n            self.assertEqual(cons[0].type, SOCK_STREAM)\n            # tcp6\n            if supports_ipv6():\n                cons = thisproc.connections(kind='tcp6')\n                self.assertEqual(len(cons), 1)\n                self.assertEqual(cons[0].family, AF_INET6)\n                self.assertEqual(cons[0].type, SOCK_STREAM)\n            # udp\n            cons = thisproc.connections(kind='udp')\n            self.assertEqual(len(cons), 2 if supports_ipv6() else 1)\n            for conn in cons:\n                self.assertIn(conn.family, (AF_INET, AF_INET6))\n                self.assertEqual(conn.type, SOCK_DGRAM)\n            # udp4\n            cons = thisproc.connections(kind='udp4')\n            self.assertEqual(len(cons), 1)\n            self.assertEqual(cons[0].family, AF_INET)\n            self.assertEqual(cons[0].type, SOCK_DGRAM)\n            # udp6\n            if supports_ipv6():\n                cons = thisproc.connections(kind='udp6')\n                self.assertEqual(len(cons), 1)\n                self.assertEqual(cons[0].family, AF_INET6)\n                self.assertEqual(cons[0].type, SOCK_DGRAM)\n            # inet\n            cons = thisproc.connections(kind='inet')\n            self.assertEqual(len(cons), 4 if supports_ipv6() else 2)\n            for conn in cons:\n                self.assertIn(conn.family, (AF_INET, AF_INET6))\n                self.assertIn(conn.type, (SOCK_STREAM, SOCK_DGRAM))\n            # inet6\n            if supports_ipv6():\n                cons = thisproc.connections(kind='inet6')\n                self.assertEqual(len(cons), 2)\n                for conn in cons:\n                    self.assertEqual(conn.family, AF_INET6)\n                    self.assertIn(conn.type, (SOCK_STREAM, SOCK_DGRAM))\n            # Skipped on BSD becayse by default the Python process\n            # creates a UNIX socket to '/var/run/log'.\n            if HAS_CONNECTIONS_UNIX and not (FREEBSD or NETBSD):\n                cons = thisproc.connections(kind='unix')\n                self.assertEqual(len(cons), 3)\n                for conn in cons:\n                    self.assertEqual(conn.family, AF_UNIX)\n                    self.assertIn(conn.type, (SOCK_STREAM, SOCK_DGRAM))\n\n\n@unittest.skipIf(SKIP_SYSCONS, \"requires root\")\nclass TestSystemWideConnections(ConnectionTestCase):\n    \"\"\"Tests for net_connections().\"\"\"\n\n    def test_it(self):\n        def check(cons, families, types_):\n            for conn in cons:\n                self.assertIn(conn.family, families, msg=conn)\n                if conn.family != AF_UNIX:\n                    self.assertIn(conn.type, types_, msg=conn)\n                check_connection_ntuple(conn)\n\n        with create_sockets():\n            from psutil._common import conn_tmap\n            for kind, groups in conn_tmap.items():\n                # XXX: SunOS does not retrieve UNIX sockets.\n                if kind == 'unix' and not HAS_CONNECTIONS_UNIX:\n                    continue\n                families, types_ = groups\n                cons = psutil.net_connections(kind)\n                self.assertEqual(len(cons), len(set(cons)))\n                check(cons, families, types_)\n\n    @retry_on_failure()\n    def test_multi_sockets_procs(self):\n        # Creates multiple sub processes, each creating different\n        # sockets. For each process check that proc.connections()\n        # and net_connections() return the same results.\n        # This is done mainly to check whether net_connections()'s\n        # pid is properly set, see:\n        # https://github.com/giampaolo/psutil/issues/1013\n        with create_sockets() as socks:\n            expected = len(socks)\n        pids = []\n        times = 10\n        fnames = []\n        for i in range(times):\n            fname = self.get_testfn()\n            fnames.append(fname)\n            src = textwrap.dedent(\"\"\"\\\n                import time, os\n                from psutil.tests import create_sockets\n                with create_sockets():\n                    with open(r'%s', 'w') as f:\n                        f.write(\"hello\")\n                    time.sleep(60)\n                \"\"\" % fname)\n            sproc = self.pyrun(src)\n            pids.append(sproc.pid)\n\n        # sync\n        for fname in fnames:\n            wait_for_file(fname)\n\n        syscons = [x for x in psutil.net_connections(kind='all') if x.pid\n                   in pids]\n        for pid in pids:\n            self.assertEqual(len([x for x in syscons if x.pid == pid]),\n                             expected)\n            p = psutil.Process(pid)\n            self.assertEqual(len(p.connections('all')), expected)\n\n\nclass TestMisc(PsutilTestCase):\n\n    def test_connection_constants(self):\n        ints = []\n        strs = []\n        for name in dir(psutil):\n            if name.startswith('CONN_'):\n                num = getattr(psutil, name)\n                str_ = str(num)\n                assert str_.isupper(), str_\n                self.assertNotIn(str, strs)\n                self.assertNotIn(num, ints)\n                ints.append(num)\n                strs.append(str_)\n        if SUNOS:\n            psutil.CONN_IDLE\n            psutil.CONN_BOUND\n        if WINDOWS:\n            psutil.CONN_DELETE_TCB\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n    run_from_name(__file__)\n"
                    },
                    "test_contracts": {
                        "type": "module",
                        "extension": "py",
                        "code": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Contracts tests. These tests mainly check API sanity in terms of\nreturned types and APIs availability.\nSome of these are duplicates of tests test_system.py and test_process.py\n\"\"\"\n\nimport errno\nimport multiprocessing\nimport os\nimport signal\nimport stat\nimport sys\nimport time\nimport traceback\n\nfrom psutil import AIX\nfrom psutil import BSD\nfrom psutil import FREEBSD\nfrom psutil import LINUX\nfrom psutil import MACOS\nfrom psutil import NETBSD\nfrom psutil import OPENBSD\nfrom psutil import OSX\nfrom psutil import POSIX\nfrom psutil import SUNOS\nfrom psutil import WINDOWS\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import long\nfrom psutil._compat import range\nfrom psutil.tests import APPVEYOR\nfrom psutil.tests import check_connection_ntuple\nfrom psutil.tests import CI_TESTING\nfrom psutil.tests import create_sockets\nfrom psutil.tests import enum\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_NET_IO_COUNTERS\nfrom psutil.tests import HAS_SENSORS_FANS\nfrom psutil.tests import HAS_SENSORS_TEMPERATURES\nfrom psutil.tests import is_namedtuple\nfrom psutil.tests import kernel_version\nfrom psutil.tests import process_namespace\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import PYPY\nfrom psutil.tests import serialrun\nfrom psutil.tests import SKIP_SYSCONS\nfrom psutil.tests import unittest\nfrom psutil.tests import VALID_PROC_STATUSES\nimport psutil\n\n\n# ===================================================================\n# --- APIs availability\n# ===================================================================\n\n# Make sure code reflects what doc promises in terms of APIs\n# availability.\n\nclass TestAvailConstantsAPIs(PsutilTestCase):\n\n    def test_PROCFS_PATH(self):\n        self.assertEqual(hasattr(psutil, \"PROCFS_PATH\"),\n                         LINUX or SUNOS or AIX)\n\n    def test_win_priority(self):\n        ae = self.assertEqual\n        ae(hasattr(psutil, \"ABOVE_NORMAL_PRIORITY_CLASS\"), WINDOWS)\n        ae(hasattr(psutil, \"BELOW_NORMAL_PRIORITY_CLASS\"), WINDOWS)\n        ae(hasattr(psutil, \"HIGH_PRIORITY_CLASS\"), WINDOWS)\n        ae(hasattr(psutil, \"IDLE_PRIORITY_CLASS\"), WINDOWS)\n        ae(hasattr(psutil, \"NORMAL_PRIORITY_CLASS\"), WINDOWS)\n        ae(hasattr(psutil, \"REALTIME_PRIORITY_CLASS\"), WINDOWS)\n\n    def test_linux_ioprio_linux(self):\n        ae = self.assertEqual\n        ae(hasattr(psutil, \"IOPRIO_CLASS_NONE\"), LINUX)\n        ae(hasattr(psutil, \"IOPRIO_CLASS_RT\"), LINUX)\n        ae(hasattr(psutil, \"IOPRIO_CLASS_BE\"), LINUX)\n        ae(hasattr(psutil, \"IOPRIO_CLASS_IDLE\"), LINUX)\n\n    def test_linux_ioprio_windows(self):\n        ae = self.assertEqual\n        ae(hasattr(psutil, \"IOPRIO_HIGH\"), WINDOWS)\n        ae(hasattr(psutil, \"IOPRIO_NORMAL\"), WINDOWS)\n        ae(hasattr(psutil, \"IOPRIO_LOW\"), WINDOWS)\n        ae(hasattr(psutil, \"IOPRIO_VERYLOW\"), WINDOWS)\n\n    @unittest.skipIf(GITHUB_ACTIONS and LINUX,\n                     \"unsupported on GITHUB_ACTIONS + LINUX\")\n    def test_rlimit(self):\n        ae = self.assertEqual\n        ae(hasattr(psutil, \"RLIM_INFINITY\"), LINUX or FREEBSD)\n        ae(hasattr(psutil, \"RLIMIT_AS\"), LINUX or FREEBSD)\n        ae(hasattr(psutil, \"RLIMIT_CORE\"), LINUX or FREEBSD)\n        ae(hasattr(psutil, \"RLIMIT_CPU\"), LINUX or FREEBSD)\n        ae(hasattr(psutil, \"RLIMIT_DATA\"), LINUX or FREEBSD)\n        ae(hasattr(psutil, \"RLIMIT_FSIZE\"), LINUX or FREEBSD)\n        ae(hasattr(psutil, \"RLIMIT_MEMLOCK\"), LINUX or FREEBSD)\n        ae(hasattr(psutil, \"RLIMIT_NOFILE\"), LINUX or FREEBSD)\n        ae(hasattr(psutil, \"RLIMIT_NPROC\"), LINUX or FREEBSD)\n        ae(hasattr(psutil, \"RLIMIT_RSS\"), LINUX or FREEBSD)\n        ae(hasattr(psutil, \"RLIMIT_STACK\"), LINUX or FREEBSD)\n\n        ae(hasattr(psutil, \"RLIMIT_LOCKS\"), LINUX)\n        if POSIX:\n            if kernel_version() >= (2, 6, 8):\n                ae(hasattr(psutil, \"RLIMIT_MSGQUEUE\"), LINUX)\n            if kernel_version() >= (2, 6, 12):\n                ae(hasattr(psutil, \"RLIMIT_NICE\"), LINUX)\n            if kernel_version() >= (2, 6, 12):\n                ae(hasattr(psutil, \"RLIMIT_RTPRIO\"), LINUX)\n            if kernel_version() >= (2, 6, 25):\n                ae(hasattr(psutil, \"RLIMIT_RTTIME\"), LINUX)\n            if kernel_version() >= (2, 6, 8):\n                ae(hasattr(psutil, \"RLIMIT_SIGPENDING\"), LINUX)\n\n        ae(hasattr(psutil, \"RLIMIT_SWAP\"), FREEBSD)\n        ae(hasattr(psutil, \"RLIMIT_SBSIZE\"), FREEBSD)\n        ae(hasattr(psutil, \"RLIMIT_NPTS\"), FREEBSD)\n\n\nclass TestAvailSystemAPIs(PsutilTestCase):\n\n    def test_win_service_iter(self):\n        self.assertEqual(hasattr(psutil, \"win_service_iter\"), WINDOWS)\n\n    def test_win_service_get(self):\n        self.assertEqual(hasattr(psutil, \"win_service_get\"), WINDOWS)\n\n    def test_cpu_freq(self):\n        self.assertEqual(hasattr(psutil, \"cpu_freq\"),\n                         LINUX or MACOS or WINDOWS or FREEBSD)\n\n    def test_sensors_temperatures(self):\n        self.assertEqual(\n            hasattr(psutil, \"sensors_temperatures\"), LINUX or FREEBSD)\n\n    def test_sensors_fans(self):\n        self.assertEqual(hasattr(psutil, \"sensors_fans\"), LINUX)\n\n    def test_battery(self):\n        self.assertEqual(hasattr(psutil, \"sensors_battery\"),\n                         LINUX or WINDOWS or FREEBSD or MACOS)\n\n\nclass TestAvailProcessAPIs(PsutilTestCase):\n\n    def test_environ(self):\n        self.assertEqual(hasattr(psutil.Process, \"environ\"),\n                         LINUX or MACOS or WINDOWS or AIX or SUNOS or\n                         FREEBSD or OPENBSD or NETBSD)\n\n    def test_uids(self):\n        self.assertEqual(hasattr(psutil.Process, \"uids\"), POSIX)\n\n    def test_gids(self):\n        self.assertEqual(hasattr(psutil.Process, \"uids\"), POSIX)\n\n    def test_terminal(self):\n        self.assertEqual(hasattr(psutil.Process, \"terminal\"), POSIX)\n\n    def test_ionice(self):\n        self.assertEqual(hasattr(psutil.Process, \"ionice\"), LINUX or WINDOWS)\n\n    @unittest.skipIf(GITHUB_ACTIONS and LINUX,\n                     \"unsupported on GITHUB_ACTIONS + LINUX\")\n    def test_rlimit(self):\n        self.assertEqual(hasattr(psutil.Process, \"rlimit\"), LINUX or FREEBSD)\n\n    def test_io_counters(self):\n        hasit = hasattr(psutil.Process, \"io_counters\")\n        self.assertEqual(hasit, False if MACOS or SUNOS else True)\n\n    def test_num_fds(self):\n        self.assertEqual(hasattr(psutil.Process, \"num_fds\"), POSIX)\n\n    def test_num_handles(self):\n        self.assertEqual(hasattr(psutil.Process, \"num_handles\"), WINDOWS)\n\n    def test_cpu_affinity(self):\n        self.assertEqual(hasattr(psutil.Process, \"cpu_affinity\"),\n                         LINUX or WINDOWS or FREEBSD)\n\n    def test_cpu_num(self):\n        self.assertEqual(hasattr(psutil.Process, \"cpu_num\"),\n                         LINUX or FREEBSD or SUNOS)\n\n    def test_memory_maps(self):\n        hasit = hasattr(psutil.Process, \"memory_maps\")\n        self.assertEqual(\n            hasit, False if OPENBSD or NETBSD or AIX or MACOS else True)\n\n\n# ===================================================================\n# --- API types\n# ===================================================================\n\n\nclass TestSystemAPITypes(PsutilTestCase):\n    \"\"\"Check the return types of system related APIs.\n    Mainly we want to test we never return unicode on Python 2, see:\n    https://github.com/giampaolo/psutil/issues/1039\n    \"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        cls.proc = psutil.Process()\n\n    def assert_ntuple_of_nums(self, nt, type_=float, gezero=True):\n        assert is_namedtuple(nt)\n        for n in nt:\n            self.assertIsInstance(n, type_)\n            if gezero:\n                self.assertGreaterEqual(n, 0)\n\n    def test_cpu_times(self):\n        self.assert_ntuple_of_nums(psutil.cpu_times())\n        for nt in psutil.cpu_times(percpu=True):\n            self.assert_ntuple_of_nums(nt)\n\n    def test_cpu_percent(self):\n        self.assertIsInstance(psutil.cpu_percent(interval=None), float)\n        self.assertIsInstance(psutil.cpu_percent(interval=0.00001), float)\n\n    def test_cpu_times_percent(self):\n        self.assert_ntuple_of_nums(psutil.cpu_times_percent(interval=None))\n        self.assert_ntuple_of_nums(psutil.cpu_times_percent(interval=0.0001))\n\n    def test_cpu_count(self):\n        self.assertIsInstance(psutil.cpu_count(), int)\n\n    @unittest.skipIf(not HAS_CPU_FREQ, \"not supported\")\n    def test_cpu_freq(self):\n        if psutil.cpu_freq() is None:\n            raise self.skipTest(\"cpu_freq() returns None\")\n        self.assert_ntuple_of_nums(psutil.cpu_freq(), type_=(float, int, long))\n\n    def test_disk_io_counters(self):\n        # Duplicate of test_system.py. Keep it anyway.\n        for k, v in psutil.disk_io_counters(perdisk=True).items():\n            self.assertIsInstance(k, str)\n            self.assert_ntuple_of_nums(v, type_=(int, long))\n\n    def test_disk_partitions(self):\n        # Duplicate of test_system.py. Keep it anyway.\n        for disk in psutil.disk_partitions():\n            self.assertIsInstance(disk.device, str)\n            self.assertIsInstance(disk.mountpoint, str)\n            self.assertIsInstance(disk.fstype, str)\n            self.assertIsInstance(disk.opts, str)\n            self.assertIsInstance(disk.maxfile, int)\n            self.assertIsInstance(disk.maxpath, int)\n\n    @unittest.skipIf(SKIP_SYSCONS, \"requires root\")\n    def test_net_connections(self):\n        with create_sockets():\n            ret = psutil.net_connections('all')\n            self.assertEqual(len(ret), len(set(ret)))\n            for conn in ret:\n                assert is_namedtuple(conn)\n\n    def test_net_if_addrs(self):\n        # Duplicate of test_system.py. Keep it anyway.\n        for ifname, addrs in psutil.net_if_addrs().items():\n            self.assertIsInstance(ifname, str)\n            for addr in addrs:\n                if enum is not None and not PYPY:\n                    self.assertIsInstance(addr.family, enum.IntEnum)\n                else:\n                    self.assertIsInstance(addr.family, int)\n                self.assertIsInstance(addr.address, str)\n                self.assertIsInstance(addr.netmask, (str, type(None)))\n                self.assertIsInstance(addr.broadcast, (str, type(None)))\n\n    def test_net_if_stats(self):\n        # Duplicate of test_system.py. Keep it anyway.\n        for ifname, info in psutil.net_if_stats().items():\n            self.assertIsInstance(ifname, str)\n            self.assertIsInstance(info.isup, bool)\n            if enum is not None:\n                self.assertIsInstance(info.duplex, enum.IntEnum)\n            else:\n                self.assertIsInstance(info.duplex, int)\n            self.assertIsInstance(info.speed, int)\n            self.assertIsInstance(info.mtu, int)\n\n    @unittest.skipIf(not HAS_NET_IO_COUNTERS, 'not supported')\n    def test_net_io_counters(self):\n        # Duplicate of test_system.py. Keep it anyway.\n        for ifname, _ in psutil.net_io_counters(pernic=True).items():\n            self.assertIsInstance(ifname, str)\n\n    @unittest.skipIf(not HAS_SENSORS_FANS, \"not supported\")\n    def test_sensors_fans(self):\n        # Duplicate of test_system.py. Keep it anyway.\n        for name, units in psutil.sensors_fans().items():\n            self.assertIsInstance(name, str)\n            for unit in units:\n                self.assertIsInstance(unit.label, str)\n                self.assertIsInstance(unit.current, (float, int, type(None)))\n\n    @unittest.skipIf(not HAS_SENSORS_TEMPERATURES, \"not supported\")\n    def test_sensors_temperatures(self):\n        # Duplicate of test_system.py. Keep it anyway.\n        for name, units in psutil.sensors_temperatures().items():\n            self.assertIsInstance(name, str)\n            for unit in units:\n                self.assertIsInstance(unit.label, str)\n                self.assertIsInstance(unit.current, (float, int, type(None)))\n                self.assertIsInstance(unit.high, (float, int, type(None)))\n                self.assertIsInstance(unit.critical, (float, int, type(None)))\n\n    def test_boot_time(self):\n        # Duplicate of test_system.py. Keep it anyway.\n        self.assertIsInstance(psutil.boot_time(), float)\n\n    def test_users(self):\n        # Duplicate of test_system.py. Keep it anyway.\n        for user in psutil.users():\n            self.assertIsInstance(user.name, str)\n            self.assertIsInstance(user.terminal, (str, type(None)))\n            self.assertIsInstance(user.host, (str, type(None)))\n            self.assertIsInstance(user.pid, (int, type(None)))\n\n\nclass TestProcessWaitType(PsutilTestCase):\n\n    @unittest.skipIf(not POSIX, \"not POSIX\")\n    def test_negative_signal(self):\n        p = psutil.Process(self.spawn_testproc().pid)\n        p.terminate()\n        code = p.wait()\n        self.assertEqual(code, -signal.SIGTERM)\n        if enum is not None:\n            self.assertIsInstance(code, enum.IntEnum)\n        else:\n            self.assertIsInstance(code, int)\n\n\n# ===================================================================\n# --- Featch all processes test\n# ===================================================================\n\n\ndef proc_info(pid):\n    tcase = PsutilTestCase()\n\n    def check_exception(exc, proc, name, ppid):\n        tcase.assertEqual(exc.pid, pid)\n        tcase.assertEqual(exc.name, name)\n        if isinstance(exc, psutil.ZombieProcess):\n            if exc.ppid is not None:\n                tcase.assertGreaterEqual(exc.ppid, 0)\n                tcase.assertEqual(exc.ppid, ppid)\n        elif isinstance(exc, psutil.NoSuchProcess):\n            tcase.assertProcessGone(proc)\n        str(exc)\n        assert exc.msg\n\n    def do_wait():\n        if pid != 0:\n            try:\n                proc.wait(0)\n            except psutil.Error as exc:\n                check_exception(exc, proc, name, ppid)\n\n    try:\n        proc = psutil.Process(pid)\n        d = proc.as_dict(['ppid', 'name'])\n    except psutil.NoSuchProcess:\n        return {}\n\n    name, ppid = d['name'], d['ppid']\n    info = {'pid': proc.pid}\n    ns = process_namespace(proc)\n    # We don't use oneshot() because in order not to fool\n    # check_exception() in case of NSP.\n    for fun, fun_name in ns.iter(ns.getters, clear_cache=False):\n        try:\n            info[fun_name] = fun()\n        except psutil.Error as exc:\n            check_exception(exc, proc, name, ppid)\n            continue\n    do_wait()\n    return info\n\n\n@serialrun\nclass TestFetchAllProcesses(PsutilTestCase):\n    \"\"\"Test which iterates over all running processes and performs\n    some sanity checks against Process API's returned values.\n    Uses a process pool to get info about all processes.\n    \"\"\"\n\n    def setUp(self):\n        self.pool = multiprocessing.Pool()\n\n    def tearDown(self):\n        self.pool.terminate()\n        self.pool.join()\n\n    def iter_proc_info(self):\n        # Fixes \"can't pickle <function proc_info>: it's not the\n        # same object as test_contracts.proc_info\".\n        from psutil.tests.test_contracts import proc_info\n        return self.pool.imap_unordered(proc_info, psutil.pids())\n\n    def test_all(self):\n        failures = []\n        for info in self.iter_proc_info():\n            for name, value in info.items():\n                meth = getattr(self, name)\n                try:\n                    meth(value, info)\n                except AssertionError:\n                    s = '\\n' + '=' * 70 + '\\n'\n                    s += \"FAIL: test_%s pid=%s, ret=%s\\n\" % (\n                        name, info['pid'], repr(value))\n                    s += '-' * 70\n                    s += \"\\n%s\" % traceback.format_exc()\n                    s = \"\\n\".join((\" \" * 4) + i for i in s.splitlines())\n                    s += '\\n'\n                    failures.append(s)\n                else:\n                    if value not in (0, 0.0, [], None, '', {}):\n                        assert value, value\n        if failures:\n            raise self.fail(''.join(failures))\n\n    def cmdline(self, ret, info):\n        self.assertIsInstance(ret, list)\n        for part in ret:\n            self.assertIsInstance(part, str)\n\n    def exe(self, ret, info):\n        self.assertIsInstance(ret, (str, type(None)))\n        if not ret:\n            self.assertEqual(ret, '')\n        else:\n            if WINDOWS and not ret.endswith('.exe'):\n                return  # May be \"Registry\", \"MemCompression\", ...\n            assert os.path.isabs(ret), ret\n            # Note: os.stat() may return False even if the file is there\n            # hence we skip the test, see:\n            # http://stackoverflow.com/questions/3112546/os-path-exists-lies\n            if POSIX and os.path.isfile(ret):\n                if hasattr(os, 'access') and hasattr(os, \"X_OK\"):\n                    # XXX: may fail on MACOS\n                    try:\n                        assert os.access(ret, os.X_OK)\n                    except AssertionError:\n                        if os.path.exists(ret) and not CI_TESTING:\n                            raise\n\n    def pid(self, ret, info):\n        self.assertIsInstance(ret, int)\n        self.assertGreaterEqual(ret, 0)\n\n    def ppid(self, ret, info):\n        self.assertIsInstance(ret, (int, long))\n        self.assertGreaterEqual(ret, 0)\n\n    def name(self, ret, info):\n        self.assertIsInstance(ret, str)\n        if APPVEYOR and not ret and info['status'] == 'stopped':\n            return\n        # on AIX, \"<exiting>\" processes don't have names\n        if not AIX:\n            assert ret\n\n    def create_time(self, ret, info):\n        self.assertIsInstance(ret, float)\n        try:\n            self.assertGreaterEqual(ret, 0)\n        except AssertionError:\n            # XXX\n            if OPENBSD and info['status'] == psutil.STATUS_ZOMBIE:\n                pass\n            else:\n                raise\n        # this can't be taken for granted on all platforms\n        # self.assertGreaterEqual(ret, psutil.boot_time())\n        # make sure returned value can be pretty printed\n        # with strftime\n        time.strftime(\"%Y %m %d %H:%M:%S\", time.localtime(ret))\n\n    def uids(self, ret, info):\n        assert is_namedtuple(ret)\n        for uid in ret:\n            self.assertIsInstance(uid, int)\n            self.assertGreaterEqual(uid, 0)\n\n    def gids(self, ret, info):\n        assert is_namedtuple(ret)\n        # note: testing all gids as above seems not to be reliable for\n        # gid == 30 (nodoby); not sure why.\n        for gid in ret:\n            self.assertIsInstance(gid, int)\n            if not MACOS and not NETBSD:\n                self.assertGreaterEqual(gid, 0)\n\n    def username(self, ret, info):\n        self.assertIsInstance(ret, str)\n        assert ret\n\n    def status(self, ret, info):\n        self.assertIsInstance(ret, str)\n        assert ret\n        self.assertNotEqual(ret, '?')  # XXX\n        self.assertIn(ret, VALID_PROC_STATUSES)\n\n    def io_counters(self, ret, info):\n        assert is_namedtuple(ret)\n        for field in ret:\n            self.assertIsInstance(field, (int, long))\n            if field != -1:\n                self.assertGreaterEqual(field, 0)\n\n    def ionice(self, ret, info):\n        if LINUX:\n            self.assertIsInstance(ret.ioclass, int)\n            self.assertIsInstance(ret.value, int)\n            self.assertGreaterEqual(ret.ioclass, 0)\n            self.assertGreaterEqual(ret.value, 0)\n        else:  # Windows, Cygwin\n            choices = [\n                psutil.IOPRIO_VERYLOW,\n                psutil.IOPRIO_LOW,\n                psutil.IOPRIO_NORMAL,\n                psutil.IOPRIO_HIGH]\n            self.assertIsInstance(ret, int)\n            self.assertGreaterEqual(ret, 0)\n            self.assertIn(ret, choices)\n\n    def num_threads(self, ret, info):\n        self.assertIsInstance(ret, int)\n        if APPVEYOR and not ret and info['status'] == 'stopped':\n            return\n        self.assertGreaterEqual(ret, 1)\n\n    def threads(self, ret, info):\n        self.assertIsInstance(ret, list)\n        for t in ret:\n            assert is_namedtuple(t)\n            self.assertGreaterEqual(t.id, 0)\n            self.assertGreaterEqual(t.user_time, 0)\n            self.assertGreaterEqual(t.system_time, 0)\n            for field in t:\n                self.assertIsInstance(field, (int, float))\n\n    def cpu_times(self, ret, info):\n        assert is_namedtuple(ret)\n        for n in ret:\n            self.assertIsInstance(n, float)\n            self.assertGreaterEqual(n, 0)\n        # TODO: check ntuple fields\n\n    def cpu_percent(self, ret, info):\n        self.assertIsInstance(ret, float)\n        assert 0.0 <= ret <= 100.0, ret\n\n    def cpu_num(self, ret, info):\n        self.assertIsInstance(ret, int)\n        if FREEBSD and ret == -1:\n            return\n        self.assertGreaterEqual(ret, 0)\n        if psutil.cpu_count() == 1:\n            self.assertEqual(ret, 0)\n        self.assertIn(ret, list(range(psutil.cpu_count())))\n\n    def memory_info(self, ret, info):\n        assert is_namedtuple(ret)\n        for value in ret:\n            self.assertIsInstance(value, (int, long))\n            self.assertGreaterEqual(value, 0)\n        if WINDOWS:\n            self.assertGreaterEqual(ret.peak_wset, ret.wset)\n            self.assertGreaterEqual(ret.peak_paged_pool, ret.paged_pool)\n            self.assertGreaterEqual(ret.peak_nonpaged_pool, ret.nonpaged_pool)\n            self.assertGreaterEqual(ret.peak_pagefile, ret.pagefile)\n\n    def memory_full_info(self, ret, info):\n        assert is_namedtuple(ret)\n        total = psutil.virtual_memory().total\n        for name in ret._fields:\n            value = getattr(ret, name)\n            self.assertIsInstance(value, (int, long))\n            self.assertGreaterEqual(value, 0, msg=(name, value))\n            if LINUX or OSX and name in ('vms', 'data'):\n                # On Linux there are processes (e.g. 'goa-daemon') whose\n                # VMS is incredibly high for some reason.\n                continue\n            self.assertLessEqual(value, total, msg=(name, value, total))\n\n        if LINUX:\n            self.assertGreaterEqual(ret.pss, ret.uss)\n\n    def open_files(self, ret, info):\n        self.assertIsInstance(ret, list)\n        for f in ret:\n            self.assertIsInstance(f.fd, int)\n            self.assertIsInstance(f.path, str)\n            if WINDOWS:\n                self.assertEqual(f.fd, -1)\n            elif LINUX:\n                self.assertIsInstance(f.position, int)\n                self.assertIsInstance(f.mode, str)\n                self.assertIsInstance(f.flags, int)\n                self.assertGreaterEqual(f.position, 0)\n                self.assertIn(f.mode, ('r', 'w', 'a', 'r+', 'a+'))\n                self.assertGreater(f.flags, 0)\n            elif BSD and not f.path:\n                # XXX see: https://github.com/giampaolo/psutil/issues/595\n                continue\n            assert os.path.isabs(f.path), f\n            try:\n                st = os.stat(f.path)\n            except FileNotFoundError:\n                pass\n            else:\n                assert stat.S_ISREG(st.st_mode), f\n\n    def num_fds(self, ret, info):\n        self.assertIsInstance(ret, int)\n        self.assertGreaterEqual(ret, 0)\n\n    def connections(self, ret, info):\n        with create_sockets():\n            self.assertEqual(len(ret), len(set(ret)))\n            for conn in ret:\n                assert is_namedtuple(conn)\n                check_connection_ntuple(conn)\n\n    def cwd(self, ret, info):\n        if ret:     # 'ret' can be None or empty\n            self.assertIsInstance(ret, str)\n            assert os.path.isabs(ret), ret\n            try:\n                st = os.stat(ret)\n            except OSError as err:\n                if WINDOWS and err.errno in \\\n                        psutil._psplatform.ACCESS_DENIED_SET:\n                    pass\n                # directory has been removed in mean time\n                elif err.errno != errno.ENOENT:\n                    raise\n            else:\n                assert stat.S_ISDIR(st.st_mode)\n\n    def memory_percent(self, ret, info):\n        self.assertIsInstance(ret, float)\n        assert 0 <= ret <= 100, ret\n\n    def is_running(self, ret, info):\n        self.assertIsInstance(ret, bool)\n\n    def cpu_affinity(self, ret, info):\n        self.assertIsInstance(ret, list)\n        assert ret != [], ret\n        cpus = list(range(psutil.cpu_count()))\n        for n in ret:\n            self.assertIsInstance(n, int)\n            self.assertIn(n, cpus)\n\n    def terminal(self, ret, info):\n        self.assertIsInstance(ret, (str, type(None)))\n        if ret is not None:\n            assert os.path.isabs(ret), ret\n            assert os.path.exists(ret), ret\n\n    def memory_maps(self, ret, info):\n        for nt in ret:\n            self.assertIsInstance(nt.addr, str)\n            self.assertIsInstance(nt.perms, str)\n            self.assertIsInstance(nt.path, str)\n            for fname in nt._fields:\n                value = getattr(nt, fname)\n                if fname == 'path':\n                    if not value.startswith('['):\n                        assert os.path.isabs(nt.path), nt.path\n                        # commented as on Linux we might get\n                        # '/foo/bar (deleted)'\n                        # assert os.path.exists(nt.path), nt.path\n                elif fname == 'addr':\n                    assert value, repr(value)\n                elif fname == 'perms':\n                    if not WINDOWS:\n                        assert value, repr(value)\n                else:\n                    self.assertIsInstance(value, (int, long))\n                    self.assertGreaterEqual(value, 0)\n\n    def num_handles(self, ret, info):\n        self.assertIsInstance(ret, int)\n        self.assertGreaterEqual(ret, 0)\n\n    def nice(self, ret, info):\n        self.assertIsInstance(ret, int)\n        if POSIX:\n            assert -20 <= ret <= 20, ret\n        else:\n            priorities = [getattr(psutil, x) for x in dir(psutil)\n                          if x.endswith('_PRIORITY_CLASS')]\n            self.assertIn(ret, priorities)\n            if sys.version_info > (3, 4):\n                self.assertIsInstance(ret, enum.IntEnum)\n            else:\n                self.assertIsInstance(ret, int)\n\n    def num_ctx_switches(self, ret, info):\n        assert is_namedtuple(ret)\n        for value in ret:\n            self.assertIsInstance(value, (int, long))\n            self.assertGreaterEqual(value, 0)\n\n    def rlimit(self, ret, info):\n        self.assertIsInstance(ret, tuple)\n        self.assertEqual(len(ret), 2)\n        self.assertGreaterEqual(ret[0], -1)\n        self.assertGreaterEqual(ret[1], -1)\n\n    def environ(self, ret, info):\n        self.assertIsInstance(ret, dict)\n        for k, v in ret.items():\n            self.assertIsInstance(k, str)\n            self.assertIsInstance(v, str)\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n    run_from_name(__file__)\n"
                    },
                    "test_linux": {
                        "type": "module",
                        "extension": "py",
                        "code": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Linux specific tests.\"\"\"\n\nfrom __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport warnings\n\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import basestring\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import PY3\nfrom psutil._compat import u\nfrom psutil.tests import call_until\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import mock\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import PYPY\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import unittest\nfrom psutil.tests import which\n\n\nHERE = os.path.abspath(os.path.dirname(__file__))\nSIOCGIFADDR = 0x8915\nSIOCGIFCONF = 0x8912\nSIOCGIFHWADDR = 0x8927\nSIOCGIFNETMASK = 0x891b\nSIOCGIFBRDADDR = 0x8919\nif LINUX:\n    SECTOR_SIZE = 512\nEMPTY_TEMPERATURES = not glob.glob('/sys/class/hwmon/hwmon*')\n\n# =====================================================================\n# --- utils\n# =====================================================================\n\n\ndef get_ipv4_address(ifname):\n    import fcntl\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        return socket.inet_ntoa(\n            fcntl.ioctl(s.fileno(),\n                        SIOCGIFADDR,\n                        struct.pack('256s', ifname))[20:24])\n\n\ndef get_ipv4_netmask(ifname):\n    import fcntl\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        return socket.inet_ntoa(\n            fcntl.ioctl(s.fileno(),\n                        SIOCGIFNETMASK,\n                        struct.pack('256s', ifname))[20:24])\n\n\ndef get_ipv4_broadcast(ifname):\n    import fcntl\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        return socket.inet_ntoa(\n            fcntl.ioctl(s.fileno(),\n                        SIOCGIFBRDADDR,\n                        struct.pack('256s', ifname))[20:24])\n\n\ndef get_ipv6_address(ifname):\n    with open(\"/proc/net/if_inet6\", 'rt') as f:\n        for line in f.readlines():\n            fields = line.split()\n            if fields[-1] == ifname:\n                break\n        else:\n            raise ValueError(\"could not find interface %r\" % ifname)\n    unformatted = fields[0]\n    groups = []\n    for i in range(0, len(unformatted), 4):\n        groups.append(unformatted[i:i + 4])\n    formatted = \":\".join(groups)\n    packed = socket.inet_pton(socket.AF_INET6, formatted)\n    return socket.inet_ntop(socket.AF_INET6, packed)\n\n\ndef get_mac_address(ifname):\n    import fcntl\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        info = fcntl.ioctl(\n            s.fileno(), SIOCGIFHWADDR, struct.pack('256s', ifname))\n        if PY3:\n            def ord(x):\n                return x\n        else:\n            import __builtin__\n            ord = __builtin__.ord\n        return ''.join(['%02x:' % ord(char) for char in info[18:24]])[:-1]\n\n\ndef free_swap():\n    \"\"\"Parse 'free' cmd and return swap memory's s total, used and free\n    values.\n    \"\"\"\n    out = sh('free -b', env={\"LANG\": \"C.UTF-8\"})\n    lines = out.split('\\n')\n    for line in lines:\n        if line.startswith('Swap'):\n            _, total, used, free = line.split()\n            nt = collections.namedtuple('free', 'total used free')\n            return nt(int(total), int(used), int(free))\n    raise ValueError(\n        \"can't find 'Swap' in 'free' output:\\n%s\" % '\\n'.join(lines))\n\n\ndef free_physmem():\n    \"\"\"Parse 'free' cmd and return physical memory's total, used\n    and free values.\n    \"\"\"\n    # Note: free can have 2 different formats, invalidating 'shared'\n    # and 'cached' memory which may have different positions so we\n    # do not return them.\n    # https://github.com/giampaolo/psutil/issues/538#issuecomment-57059946\n    out = sh('free -b', env={\"LANG\": \"C.UTF-8\"})\n    lines = out.split('\\n')\n    for line in lines:\n        if line.startswith('Mem'):\n            total, used, free, shared = \\\n                [int(x) for x in line.split()[1:5]]\n            nt = collections.namedtuple(\n                'free', 'total used free shared output')\n            return nt(total, used, free, shared, out)\n    raise ValueError(\n        \"can't find 'Mem' in 'free' output:\\n%s\" % '\\n'.join(lines))\n\n\ndef vmstat(stat):\n    out = sh(\"vmstat -s\", env={\"LANG\": \"C.UTF-8\"})\n    for line in out.split(\"\\n\"):\n        line = line.strip()\n        if stat in line:\n            return int(line.split(' ')[0])\n    raise ValueError(\"can't find %r in 'vmstat' output\" % stat)\n\n\ndef get_free_version_info():\n    out = sh(\"free -V\").strip()\n    if 'UNKNOWN' in out:\n        raise unittest.SkipTest(\"can't determine free version\")\n    return tuple(map(int, out.split()[-1].split('.')))\n\n\n@contextlib.contextmanager\ndef mock_open_content(for_path, content):\n    \"\"\"Mock open() builtin and forces it to return a certain `content`\n    on read() if the path being opened matches `for_path`.\n    \"\"\"\n    def open_mock(name, *args, **kwargs):\n        if name == for_path:\n            if PY3:\n                if isinstance(content, basestring):\n                    return io.StringIO(content)\n                else:\n                    return io.BytesIO(content)\n            else:\n                return io.BytesIO(content)\n        else:\n            return orig_open(name, *args, **kwargs)\n\n    orig_open = open\n    patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n    with mock.patch(patch_point, create=True, side_effect=open_mock) as m:\n        yield m\n\n\n@contextlib.contextmanager\ndef mock_open_exception(for_path, exc):\n    \"\"\"Mock open() builtin and raises `exc` if the path being opened\n    matches `for_path`.\n    \"\"\"\n    def open_mock(name, *args, **kwargs):\n        if name == for_path:\n            raise exc\n        else:\n            return orig_open(name, *args, **kwargs)\n\n    orig_open = open\n    patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n    with mock.patch(patch_point, create=True, side_effect=open_mock) as m:\n        yield m\n\n\n# =====================================================================\n# --- system virtual memory\n# =====================================================================\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemVirtualMemory(PsutilTestCase):\n\n    def test_total(self):\n        # free_value = free_physmem().total\n        # psutil_value = psutil.virtual_memory().total\n        # self.assertEqual(free_value, psutil_value)\n        vmstat_value = vmstat('total memory') * 1024\n        psutil_value = psutil.virtual_memory().total\n        self.assertAlmostEqual(vmstat_value, psutil_value)\n\n    @retry_on_failure()\n    def test_used(self):\n        # Older versions of procps used slab memory to calculate used memory.\n        # This got changed in:\n        # https://gitlab.com/procps-ng/procps/commit/\n        #     05d751c4f076a2f0118b914c5e51cfbb4762ad8e\n        if get_free_version_info() < (3, 3, 12):\n            raise self.skipTest(\"old free version\")\n        free = free_physmem()\n        free_value = free.used\n        psutil_value = psutil.virtual_memory().used\n        self.assertAlmostEqual(\n            free_value, psutil_value, delta=TOLERANCE_SYS_MEM,\n            msg='%s %s \\n%s' % (free_value, psutil_value, free.output))\n\n    @retry_on_failure()\n    def test_free(self):\n        vmstat_value = vmstat('free memory') * 1024\n        psutil_value = psutil.virtual_memory().free\n        self.assertAlmostEqual(\n            vmstat_value, psutil_value, delta=TOLERANCE_SYS_MEM)\n\n    @retry_on_failure()\n    def test_buffers(self):\n        vmstat_value = vmstat('buffer memory') * 1024\n        psutil_value = psutil.virtual_memory().buffers\n        self.assertAlmostEqual(\n            vmstat_value, psutil_value, delta=TOLERANCE_SYS_MEM)\n\n    @retry_on_failure()\n    def test_active(self):\n        vmstat_value = vmstat('active memory') * 1024\n        psutil_value = psutil.virtual_memory().active\n        self.assertAlmostEqual(\n            vmstat_value, psutil_value, delta=TOLERANCE_SYS_MEM)\n\n    @retry_on_failure()\n    def test_inactive(self):\n        vmstat_value = vmstat('inactive memory') * 1024\n        psutil_value = psutil.virtual_memory().inactive\n        self.assertAlmostEqual(\n            vmstat_value, psutil_value, delta=TOLERANCE_SYS_MEM)\n\n    @retry_on_failure()\n    def test_shared(self):\n        free = free_physmem()\n        free_value = free.shared\n        if free_value == 0:\n            raise unittest.SkipTest(\"free does not support 'shared' column\")\n        psutil_value = psutil.virtual_memory().shared\n        self.assertAlmostEqual(\n            free_value, psutil_value, delta=TOLERANCE_SYS_MEM,\n            msg='%s %s \\n%s' % (free_value, psutil_value, free.output))\n\n    @retry_on_failure()\n    def test_available(self):\n        # \"free\" output format has changed at some point:\n        # https://github.com/giampaolo/psutil/issues/538#issuecomment-147192098\n        out = sh(\"free -b\")\n        lines = out.split('\\n')\n        if 'available' not in lines[0]:\n            raise unittest.SkipTest(\"free does not support 'available' column\")\n        else:\n            free_value = int(lines[1].split()[-1])\n            psutil_value = psutil.virtual_memory().available\n            self.assertAlmostEqual(\n                free_value, psutil_value, delta=TOLERANCE_SYS_MEM,\n                msg='%s %s \\n%s' % (free_value, psutil_value, out))\n\n    def test_warnings_on_misses(self):\n        # Emulate a case where /proc/meminfo provides few info.\n        # psutil is supposed to set the missing fields to 0 and\n        # raise a warning.\n        with mock_open_content(\n            '/proc/meminfo',\n            textwrap.dedent(\"\"\"\\\n                Active(anon):    6145416 kB\n                Active(file):    2950064 kB\n                Inactive(anon):   574764 kB\n                Inactive(file):  1567648 kB\n                MemAvailable:         -1 kB\n                MemFree:         2057400 kB\n                MemTotal:       16325648 kB\n                SReclaimable:     346648 kB\n                \"\"\").encode()) as m:\n            with warnings.catch_warnings(record=True) as ws:\n                warnings.simplefilter(\"always\")\n                ret = psutil.virtual_memory()\n                assert m.called\n                self.assertEqual(len(ws), 1)\n                w = ws[0]\n                assert w.filename.endswith('psutil/_pslinux.py')\n                self.assertIn(\n                    \"memory stats couldn't be determined\", str(w.message))\n                self.assertIn(\"cached\", str(w.message))\n                self.assertIn(\"shared\", str(w.message))\n                self.assertIn(\"active\", str(w.message))\n                self.assertIn(\"inactive\", str(w.message))\n                self.assertIn(\"buffers\", str(w.message))\n                self.assertIn(\"available\", str(w.message))\n                self.assertEqual(ret.cached, 0)\n                self.assertEqual(ret.active, 0)\n                self.assertEqual(ret.inactive, 0)\n                self.assertEqual(ret.shared, 0)\n                self.assertEqual(ret.buffers, 0)\n                self.assertEqual(ret.available, 0)\n                self.assertEqual(ret.slab, 0)\n\n    @retry_on_failure()\n    def test_avail_old_percent(self):\n        # Make sure that our calculation of avail mem for old kernels\n        # is off by max 15%.\n        from psutil._pslinux import calculate_avail_vmem\n        from psutil._pslinux import open_binary\n\n        mems = {}\n        with open_binary('/proc/meminfo') as f:\n            for line in f:\n                fields = line.split()\n                mems[fields[0]] = int(fields[1]) * 1024\n\n        a = calculate_avail_vmem(mems)\n        if b'MemAvailable:' in mems:\n            b = mems[b'MemAvailable:']\n            diff_percent = abs(a - b) / a * 100\n            self.assertLess(diff_percent, 15)\n\n    def test_avail_old_comes_from_kernel(self):\n        # Make sure \"MemAvailable:\" coluimn is used instead of relying\n        # on our internal algorithm to calculate avail mem.\n        with mock_open_content(\n            '/proc/meminfo',\n            textwrap.dedent(\"\"\"\\\n                Active:          9444728 kB\n                Active(anon):    6145416 kB\n                Active(file):    2950064 kB\n                Buffers:          287952 kB\n                Cached:          4818144 kB\n                Inactive(file):  1578132 kB\n                Inactive(anon):   574764 kB\n                Inactive(file):  1567648 kB\n                MemAvailable:    6574984 kB\n                MemFree:         2057400 kB\n                MemTotal:       16325648 kB\n                Shmem:            577588 kB\n                SReclaimable:     346648 kB\n                \"\"\").encode()) as m:\n            with warnings.catch_warnings(record=True) as ws:\n                ret = psutil.virtual_memory()\n            assert m.called\n            self.assertEqual(ret.available, 6574984 * 1024)\n            w = ws[0]\n            self.assertIn(\n                \"inactive memory stats couldn't be determined\", str(w.message))\n\n    def test_avail_old_missing_fields(self):\n        # Remove Active(file), Inactive(file) and SReclaimable\n        # from /proc/meminfo and make sure the fallback is used\n        # (free + cached),\n        with mock_open_content(\n            \"/proc/meminfo\",\n            textwrap.dedent(\"\"\"\\\n                    Active:          9444728 kB\n                    Active(anon):    6145416 kB\n                    Buffers:          287952 kB\n                    Cached:          4818144 kB\n                    Inactive(file):  1578132 kB\n                    Inactive(anon):   574764 kB\n                    MemFree:         2057400 kB\n                    MemTotal:       16325648 kB\n                    Shmem:            577588 kB\n                    \"\"\").encode()) as m:\n            with warnings.catch_warnings(record=True) as ws:\n                ret = psutil.virtual_memory()\n            assert m.called\n            self.assertEqual(ret.available, 2057400 * 1024 + 4818144 * 1024)\n            w = ws[0]\n            self.assertIn(\n                \"inactive memory stats couldn't be determined\", str(w.message))\n\n    def test_avail_old_missing_zoneinfo(self):\n        # Remove /proc/zoneinfo file. Make sure fallback is used\n        # (free + cached).\n        with mock_open_content(\n                \"/proc/meminfo\",\n                textwrap.dedent(\"\"\"\\\n                    Active:          9444728 kB\n                    Active(anon):    6145416 kB\n                    Active(file):    2950064 kB\n                    Buffers:          287952 kB\n                    Cached:          4818144 kB\n                    Inactive(file):  1578132 kB\n                    Inactive(anon):   574764 kB\n                    Inactive(file):  1567648 kB\n                    MemFree:         2057400 kB\n                    MemTotal:       16325648 kB\n                    Shmem:            577588 kB\n                    SReclaimable:     346648 kB\n                    \"\"\").encode()):\n            with mock_open_exception(\n                    \"/proc/zoneinfo\",\n                    IOError(errno.ENOENT, 'no such file or directory')):\n                with warnings.catch_warnings(record=True) as ws:\n                    ret = psutil.virtual_memory()\n                    self.assertEqual(\n                        ret.available, 2057400 * 1024 + 4818144 * 1024)\n                    w = ws[0]\n                    self.assertIn(\n                        \"inactive memory stats couldn't be determined\",\n                        str(w.message))\n\n    def test_virtual_memory_mocked(self):\n        # Emulate /proc/meminfo because neither vmstat nor free return slab.\n        def open_mock(name, *args, **kwargs):\n            if name == '/proc/meminfo':\n                return io.BytesIO(textwrap.dedent(\"\"\"\\\n                    MemTotal:              100 kB\n                    MemFree:               2 kB\n                    MemAvailable:          3 kB\n                    Buffers:               4 kB\n                    Cached:                5 kB\n                    SwapCached:            6 kB\n                    Active:                7 kB\n                    Inactive:              8 kB\n                    Active(anon):          9 kB\n                    Inactive(anon):        10 kB\n                    Active(file):          11 kB\n                    Inactive(file):        12 kB\n                    Unevictable:           13 kB\n                    Mlocked:               14 kB\n                    SwapTotal:             15 kB\n                    SwapFree:              16 kB\n                    Dirty:                 17 kB\n                    Writeback:             18 kB\n                    AnonPages:             19 kB\n                    Mapped:                20 kB\n                    Shmem:                 21 kB\n                    Slab:                  22 kB\n                    SReclaimable:          23 kB\n                    SUnreclaim:            24 kB\n                    KernelStack:           25 kB\n                    PageTables:            26 kB\n                    NFS_Unstable:          27 kB\n                    Bounce:                28 kB\n                    WritebackTmp:          29 kB\n                    CommitLimit:           30 kB\n                    Committed_AS:          31 kB\n                    VmallocTotal:          32 kB\n                    VmallocUsed:           33 kB\n                    VmallocChunk:          34 kB\n                    HardwareCorrupted:     35 kB\n                    AnonHugePages:         36 kB\n                    ShmemHugePages:        37 kB\n                    ShmemPmdMapped:        38 kB\n                    CmaTotal:              39 kB\n                    CmaFree:               40 kB\n                    HugePages_Total:       41 kB\n                    HugePages_Free:        42 kB\n                    HugePages_Rsvd:        43 kB\n                    HugePages_Surp:        44 kB\n                    Hugepagesize:          45 kB\n                    DirectMap46k:          46 kB\n                    DirectMap47M:          47 kB\n                    DirectMap48G:          48 kB\n                    \"\"\").encode())\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, create=True, side_effect=open_mock) as m:\n            mem = psutil.virtual_memory()\n            assert m.called\n            self.assertEqual(mem.total, 100 * 1024)\n            self.assertEqual(mem.free, 2 * 1024)\n            self.assertEqual(mem.buffers, 4 * 1024)\n            # cached mem also includes reclaimable memory\n            self.assertEqual(mem.cached, (5 + 23) * 1024)\n            self.assertEqual(mem.shared, 21 * 1024)\n            self.assertEqual(mem.active, 7 * 1024)\n            self.assertEqual(mem.inactive, 8 * 1024)\n            self.assertEqual(mem.slab, 22 * 1024)\n            self.assertEqual(mem.available, 3 * 1024)\n\n\n# =====================================================================\n# --- system swap memory\n# =====================================================================\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemSwapMemory(PsutilTestCase):\n\n    @staticmethod\n    def meminfo_has_swap_info():\n        \"\"\"Return True if /proc/meminfo provides swap metrics.\"\"\"\n        with open(\"/proc/meminfo\") as f:\n            data = f.read()\n        return 'SwapTotal:' in data and 'SwapFree:' in data\n\n    def test_total(self):\n        free_value = free_swap().total\n        psutil_value = psutil.swap_memory().total\n        return self.assertAlmostEqual(\n            free_value, psutil_value, delta=TOLERANCE_SYS_MEM)\n\n    @retry_on_failure()\n    def test_used(self):\n        free_value = free_swap().used\n        psutil_value = psutil.swap_memory().used\n        return self.assertAlmostEqual(\n            free_value, psutil_value, delta=TOLERANCE_SYS_MEM)\n\n    @retry_on_failure()\n    def test_free(self):\n        free_value = free_swap().free\n        psutil_value = psutil.swap_memory().free\n        return self.assertAlmostEqual(\n            free_value, psutil_value, delta=TOLERANCE_SYS_MEM)\n\n    def test_missing_sin_sout(self):\n        with mock.patch('psutil._common.open', create=True) as m:\n            with warnings.catch_warnings(record=True) as ws:\n                warnings.simplefilter(\"always\")\n                ret = psutil.swap_memory()\n                assert m.called\n                self.assertEqual(len(ws), 1)\n                w = ws[0]\n                assert w.filename.endswith('psutil/_pslinux.py')\n                self.assertIn(\n                    \"'sin' and 'sout' swap memory stats couldn't \"\n                    \"be determined\", str(w.message))\n                self.assertEqual(ret.sin, 0)\n                self.assertEqual(ret.sout, 0)\n\n    def test_no_vmstat_mocked(self):\n        # see https://github.com/giampaolo/psutil/issues/722\n        with mock_open_exception(\n                \"/proc/vmstat\",\n                IOError(errno.ENOENT, 'no such file or directory')) as m:\n            with warnings.catch_warnings(record=True) as ws:\n                warnings.simplefilter(\"always\")\n                ret = psutil.swap_memory()\n                assert m.called\n                self.assertEqual(len(ws), 1)\n                w = ws[0]\n                assert w.filename.endswith('psutil/_pslinux.py')\n                self.assertIn(\n                    \"'sin' and 'sout' swap memory stats couldn't \"\n                    \"be determined and were set to 0\",\n                    str(w.message))\n                self.assertEqual(ret.sin, 0)\n                self.assertEqual(ret.sout, 0)\n\n    def test_meminfo_against_sysinfo(self):\n        # Make sure the content of /proc/meminfo about swap memory\n        # matches sysinfo() syscall, see:\n        # https://github.com/giampaolo/psutil/issues/1015\n        if not self.meminfo_has_swap_info():\n            return unittest.skip(\"/proc/meminfo has no swap metrics\")\n        with mock.patch('psutil._pslinux.cext.linux_sysinfo') as m:\n            swap = psutil.swap_memory()\n        assert not m.called\n        import psutil._psutil_linux as cext\n        _, _, _, _, total, free, unit_multiplier = cext.linux_sysinfo()\n        total *= unit_multiplier\n        free *= unit_multiplier\n        self.assertEqual(swap.total, total)\n        self.assertAlmostEqual(swap.free, free, delta=TOLERANCE_SYS_MEM)\n\n    def test_emulate_meminfo_has_no_metrics(self):\n        # Emulate a case where /proc/meminfo provides no swap metrics\n        # in which case sysinfo() syscall is supposed to be used\n        # as a fallback.\n        with mock_open_content(\"/proc/meminfo\", b\"\") as m:\n            psutil.swap_memory()\n            assert m.called\n\n\n# =====================================================================\n# --- system CPU\n# =====================================================================\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemCPUTimes(PsutilTestCase):\n\n    def test_fields(self):\n        fields = psutil.cpu_times()._fields\n        kernel_ver = re.findall(r'\\d+\\.\\d+\\.\\d+', os.uname()[2])[0]\n        kernel_ver_info = tuple(map(int, kernel_ver.split('.')))\n        if kernel_ver_info >= (2, 6, 11):\n            self.assertIn('steal', fields)\n        else:\n            self.assertNotIn('steal', fields)\n        if kernel_ver_info >= (2, 6, 24):\n            self.assertIn('guest', fields)\n        else:\n            self.assertNotIn('guest', fields)\n        if kernel_ver_info >= (3, 2, 0):\n            self.assertIn('guest_nice', fields)\n        else:\n            self.assertNotIn('guest_nice', fields)\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemCPUCountLogical(PsutilTestCase):\n\n    @unittest.skipIf(not os.path.exists(\"/sys/devices/system/cpu/online\"),\n                     \"/sys/devices/system/cpu/online does not exist\")\n    def test_against_sysdev_cpu_online(self):\n        with open(\"/sys/devices/system/cpu/online\") as f:\n            value = f.read().strip()\n        if \"-\" in str(value):\n            value = int(value.split('-')[1]) + 1\n            self.assertEqual(psutil.cpu_count(), value)\n\n    @unittest.skipIf(not os.path.exists(\"/sys/devices/system/cpu\"),\n                     \"/sys/devices/system/cpu does not exist\")\n    def test_against_sysdev_cpu_num(self):\n        ls = os.listdir(\"/sys/devices/system/cpu\")\n        count = len([x for x in ls if re.search(r\"cpu\\d+$\", x) is not None])\n        self.assertEqual(psutil.cpu_count(), count)\n\n    @unittest.skipIf(not which(\"nproc\"), \"nproc utility not available\")\n    def test_against_nproc(self):\n        num = int(sh(\"nproc --all\"))\n        self.assertEqual(psutil.cpu_count(logical=True), num)\n\n    @unittest.skipIf(not which(\"lscpu\"), \"lscpu utility not available\")\n    def test_against_lscpu(self):\n        out = sh(\"lscpu -p\")\n        num = len([x for x in out.split('\\n') if not x.startswith('#')])\n        self.assertEqual(psutil.cpu_count(logical=True), num)\n\n    def test_emulate_fallbacks(self):\n        import psutil._pslinux\n        original = psutil._pslinux.cpu_count_logical()\n        # Here we want to mock os.sysconf(\"SC_NPROCESSORS_ONLN\") in\n        # order to cause the parsing of /proc/cpuinfo and /proc/stat.\n        with mock.patch(\n                'psutil._pslinux.os.sysconf', side_effect=ValueError) as m:\n            self.assertEqual(psutil._pslinux.cpu_count_logical(), original)\n            assert m.called\n\n            # Let's have open() return emtpy data and make sure None is\n            # returned ('cause we mimick os.cpu_count()).\n            with mock.patch('psutil._common.open', create=True) as m:\n                self.assertIsNone(psutil._pslinux.cpu_count_logical())\n                self.assertEqual(m.call_count, 2)\n                # /proc/stat should be the last one\n                self.assertEqual(m.call_args[0][0], '/proc/stat')\n\n            # Let's push this a bit further and make sure /proc/cpuinfo\n            # parsing works as expected.\n            with open('/proc/cpuinfo', 'rb') as f:\n                cpuinfo_data = f.read()\n            fake_file = io.BytesIO(cpuinfo_data)\n            with mock.patch('psutil._common.open',\n                            return_value=fake_file, create=True) as m:\n                self.assertEqual(psutil._pslinux.cpu_count_logical(), original)\n\n            # Finally, let's make /proc/cpuinfo return meaningless data;\n            # this way we'll fall back on relying on /proc/stat\n            with mock_open_content('/proc/cpuinfo', b\"\") as m:\n                self.assertEqual(psutil._pslinux.cpu_count_logical(), original)\n                m.called\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemCPUCountPhysical(PsutilTestCase):\n\n    @unittest.skipIf(not which(\"lscpu\"), \"lscpu utility not available\")\n    def test_against_lscpu(self):\n        out = sh(\"lscpu -p\")\n        core_ids = set()\n        for line in out.split('\\n'):\n            if not line.startswith('#'):\n                fields = line.split(',')\n                core_ids.add(fields[1])\n        self.assertEqual(psutil.cpu_count(logical=False), len(core_ids))\n\n    def test_method_2(self):\n        meth_1 = psutil._pslinux.cpu_count_physical()\n        with mock.patch('glob.glob', return_value=[]) as m:\n            meth_2 = psutil._pslinux.cpu_count_physical()\n            assert m.called\n        if meth_1 is not None:\n            self.assertEqual(meth_1, meth_2)\n\n    def test_emulate_none(self):\n        with mock.patch('glob.glob', return_value=[]) as m1:\n            with mock.patch('psutil._common.open', create=True) as m2:\n                self.assertIsNone(psutil._pslinux.cpu_count_physical())\n        assert m1.called\n        assert m2.called\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemCPUFrequency(PsutilTestCase):\n\n    @unittest.skipIf(not HAS_CPU_FREQ, \"not supported\")\n    def test_emulate_use_second_file(self):\n        # https://github.com/giampaolo/psutil/issues/981\n        def path_exists_mock(path):\n            if path.startswith(\"/sys/devices/system/cpu/cpufreq/policy\"):\n                return False\n            else:\n                return orig_exists(path)\n\n        orig_exists = os.path.exists\n        with mock.patch(\"os.path.exists\", side_effect=path_exists_mock,\n                        create=True):\n            assert psutil.cpu_freq()\n\n    @unittest.skipIf(not HAS_CPU_FREQ, \"not supported\")\n    def test_emulate_use_cpuinfo(self):\n        # Emulate a case where /sys/devices/system/cpu/cpufreq* does not\n        # exist and /proc/cpuinfo is used instead.\n        def path_exists_mock(path):\n            if path.startswith('/sys/devices/system/cpu/'):\n                return False\n            else:\n                if path == \"/proc/cpuinfo\":\n                    flags.append(None)\n                return os_path_exists(path)\n\n        flags = []\n        os_path_exists = os.path.exists\n        try:\n            with mock.patch(\"os.path.exists\", side_effect=path_exists_mock):\n                reload_module(psutil._pslinux)\n                ret = psutil.cpu_freq()\n                assert ret\n                assert flags\n                self.assertEqual(ret.max, 0.0)\n                self.assertEqual(ret.min, 0.0)\n                for freq in psutil.cpu_freq(percpu=True):\n                    self.assertEqual(ret.max, 0.0)\n                    self.assertEqual(ret.min, 0.0)\n        finally:\n            reload_module(psutil._pslinux)\n            reload_module(psutil)\n\n    @unittest.skipIf(not HAS_CPU_FREQ, \"not supported\")\n    def test_emulate_data(self):\n        def open_mock(name, *args, **kwargs):\n            if (name.endswith('/scaling_cur_freq') and\n                    name.startswith(\"/sys/devices/system/cpu/cpufreq/policy\")):\n                return io.BytesIO(b\"500000\")\n            elif (name.endswith('/scaling_min_freq') and\n                    name.startswith(\"/sys/devices/system/cpu/cpufreq/policy\")):\n                return io.BytesIO(b\"600000\")\n            elif (name.endswith('/scaling_max_freq') and\n                    name.startswith(\"/sys/devices/system/cpu/cpufreq/policy\")):\n                return io.BytesIO(b\"700000\")\n            elif name == '/proc/cpuinfo':\n                return io.BytesIO(b\"cpu MHz\t\t: 500\")\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, side_effect=open_mock):\n            with mock.patch(\n                    'os.path.exists', return_value=True):\n                freq = psutil.cpu_freq()\n                self.assertEqual(freq.current, 500.0)\n                # when /proc/cpuinfo is used min and max frequencies are not\n                # available and are set to 0.\n                if freq.min != 0.0:\n                    self.assertEqual(freq.min, 600.0)\n                if freq.max != 0.0:\n                    self.assertEqual(freq.max, 700.0)\n\n    @unittest.skipIf(not HAS_CPU_FREQ, \"not supported\")\n    def test_emulate_multi_cpu(self):\n        def open_mock(name, *args, **kwargs):\n            n = name\n            if (n.endswith('/scaling_cur_freq') and\n                    n.startswith(\"/sys/devices/system/cpu/cpufreq/policy0\")):\n                return io.BytesIO(b\"100000\")\n            elif (n.endswith('/scaling_min_freq') and\n                    n.startswith(\"/sys/devices/system/cpu/cpufreq/policy0\")):\n                return io.BytesIO(b\"200000\")\n            elif (n.endswith('/scaling_max_freq') and\n                    n.startswith(\"/sys/devices/system/cpu/cpufreq/policy0\")):\n                return io.BytesIO(b\"300000\")\n            elif (n.endswith('/scaling_cur_freq') and\n                    n.startswith(\"/sys/devices/system/cpu/cpufreq/policy1\")):\n                return io.BytesIO(b\"400000\")\n            elif (n.endswith('/scaling_min_freq') and\n                    n.startswith(\"/sys/devices/system/cpu/cpufreq/policy1\")):\n                return io.BytesIO(b\"500000\")\n            elif (n.endswith('/scaling_max_freq') and\n                    n.startswith(\"/sys/devices/system/cpu/cpufreq/policy1\")):\n                return io.BytesIO(b\"600000\")\n            elif name == '/proc/cpuinfo':\n                return io.BytesIO(b\"cpu MHz\t\t: 100\\n\"\n                                  b\"cpu MHz\t\t: 400\")\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, side_effect=open_mock):\n            with mock.patch('os.path.exists', return_value=True):\n                with mock.patch('psutil._pslinux.cpu_count_logical',\n                                return_value=2):\n                    freq = psutil.cpu_freq(percpu=True)\n                    self.assertEqual(freq[0].current, 100.0)\n                    if freq[0].min != 0.0:\n                        self.assertEqual(freq[0].min, 200.0)\n                    if freq[0].max != 0.0:\n                        self.assertEqual(freq[0].max, 300.0)\n                    self.assertEqual(freq[1].current, 400.0)\n                    if freq[1].min != 0.0:\n                        self.assertEqual(freq[1].min, 500.0)\n                    if freq[1].max != 0.0:\n                        self.assertEqual(freq[1].max, 600.0)\n\n    @unittest.skipIf(not HAS_CPU_FREQ, \"not supported\")\n    def test_emulate_no_scaling_cur_freq_file(self):\n        # See: https://github.com/giampaolo/psutil/issues/1071\n        def open_mock(name, *args, **kwargs):\n            if name.endswith('/scaling_cur_freq'):\n                raise IOError(errno.ENOENT, \"\")\n            elif name.endswith('/cpuinfo_cur_freq'):\n                return io.BytesIO(b\"200000\")\n            elif name == '/proc/cpuinfo':\n                return io.BytesIO(b\"cpu MHz\t\t: 200\")\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, side_effect=open_mock):\n            with mock.patch('os.path.exists', return_value=True):\n                with mock.patch('psutil._pslinux.cpu_count_logical',\n                                return_value=1):\n                    freq = psutil.cpu_freq()\n                    self.assertEqual(freq.current, 200)\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemCPUStats(PsutilTestCase):\n\n    def test_ctx_switches(self):\n        vmstat_value = vmstat(\"context switches\")\n        psutil_value = psutil.cpu_stats().ctx_switches\n        self.assertAlmostEqual(vmstat_value, psutil_value, delta=500)\n\n    def test_interrupts(self):\n        vmstat_value = vmstat(\"interrupts\")\n        psutil_value = psutil.cpu_stats().interrupts\n        self.assertAlmostEqual(vmstat_value, psutil_value, delta=500)\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestLoadAvg(PsutilTestCase):\n\n    @unittest.skipIf(not HAS_GETLOADAVG, \"not supported\")\n    def test_getloadavg(self):\n        psutil_value = psutil.getloadavg()\n        with open(\"/proc/loadavg\", \"r\") as f:\n            proc_value = f.read().split()\n\n        self.assertAlmostEqual(float(proc_value[0]), psutil_value[0], delta=1)\n        self.assertAlmostEqual(float(proc_value[1]), psutil_value[1], delta=1)\n        self.assertAlmostEqual(float(proc_value[2]), psutil_value[2], delta=1)\n\n\n# =====================================================================\n# --- system network\n# =====================================================================\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemNetIfAddrs(PsutilTestCase):\n\n    def test_ips(self):\n        for name, addrs in psutil.net_if_addrs().items():\n            for addr in addrs:\n                if addr.family == psutil.AF_LINK:\n                    self.assertEqual(addr.address, get_mac_address(name))\n                elif addr.family == socket.AF_INET:\n                    self.assertEqual(addr.address, get_ipv4_address(name))\n                    self.assertEqual(addr.netmask, get_ipv4_netmask(name))\n                    if addr.broadcast is not None:\n                        self.assertEqual(addr.broadcast,\n                                         get_ipv4_broadcast(name))\n                    else:\n                        self.assertEqual(get_ipv4_broadcast(name), '0.0.0.0')\n                elif addr.family == socket.AF_INET6:\n                    # IPv6 addresses can have a percent symbol at the end.\n                    # E.g. these 2 are equivalent:\n                    # \"fe80::1ff:fe23:4567:890a\"\n                    # \"fe80::1ff:fe23:4567:890a%eth0\"\n                    # That is the \"zone id\" portion, which usually is the name\n                    # of the network interface.\n                    address = addr.address.split('%')[0]\n                    self.assertEqual(address, get_ipv6_address(name))\n\n    # XXX - not reliable when having virtual NICs installed by Docker.\n    # @unittest.skipIf(not which('ip'), \"'ip' utility not available\")\n    # def test_net_if_names(self):\n    #     out = sh(\"ip addr\").strip()\n    #     nics = [x for x in psutil.net_if_addrs().keys() if ':' not in x]\n    #     found = 0\n    #     for line in out.split('\\n'):\n    #         line = line.strip()\n    #         if re.search(r\"^\\d+:\", line):\n    #             found += 1\n    #             name = line.split(':')[1].strip()\n    #             self.assertIn(name, nics)\n    #     self.assertEqual(len(nics), found, msg=\"%s\\n---\\n%s\" % (\n    #         pprint.pformat(nics), out))\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemNetIfStats(PsutilTestCase):\n\n    def test_against_ifconfig(self):\n        for name, stats in psutil.net_if_stats().items():\n            try:\n                out = sh(\"ifconfig %s\" % name)\n            except RuntimeError:\n                pass\n            else:\n                self.assertEqual(stats.isup, 'RUNNING' in out, msg=out)\n                self.assertEqual(stats.mtu,\n                                 int(re.findall(r'(?i)MTU[: ](\\d+)', out)[0]))\n\n    def test_mtu(self):\n        for name, stats in psutil.net_if_stats().items():\n            with open(\"/sys/class/net/%s/mtu\" % name, \"rt\") as f:\n                self.assertEqual(stats.mtu, int(f.read().strip()))\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemNetIOCounters(PsutilTestCase):\n\n    @retry_on_failure()\n    def test_against_ifconfig(self):\n        def ifconfig(nic):\n            ret = {}\n            out = sh(\"ifconfig %s\" % name)\n            ret['packets_recv'] = int(\n                re.findall(r'RX packets[: ](\\d+)', out)[0])\n            ret['packets_sent'] = int(\n                re.findall(r'TX packets[: ](\\d+)', out)[0])\n            ret['errin'] = int(re.findall(r'errors[: ](\\d+)', out)[0])\n            ret['errout'] = int(re.findall(r'errors[: ](\\d+)', out)[1])\n            ret['dropin'] = int(re.findall(r'dropped[: ](\\d+)', out)[0])\n            ret['dropout'] = int(re.findall(r'dropped[: ](\\d+)', out)[1])\n            ret['bytes_recv'] = int(\n                re.findall(r'RX (?:packets \\d+ +)?bytes[: ](\\d+)', out)[0])\n            ret['bytes_sent'] = int(\n                re.findall(r'TX (?:packets \\d+ +)?bytes[: ](\\d+)', out)[0])\n            return ret\n\n        nio = psutil.net_io_counters(pernic=True, nowrap=False)\n        for name, stats in nio.items():\n            try:\n                ifconfig_ret = ifconfig(name)\n            except RuntimeError:\n                continue\n            self.assertAlmostEqual(\n                stats.bytes_recv, ifconfig_ret['bytes_recv'], delta=1024 * 5)\n            self.assertAlmostEqual(\n                stats.bytes_sent, ifconfig_ret['bytes_sent'], delta=1024 * 5)\n            self.assertAlmostEqual(\n                stats.packets_recv, ifconfig_ret['packets_recv'], delta=1024)\n            self.assertAlmostEqual(\n                stats.packets_sent, ifconfig_ret['packets_sent'], delta=1024)\n            self.assertAlmostEqual(\n                stats.errin, ifconfig_ret['errin'], delta=10)\n            self.assertAlmostEqual(\n                stats.errout, ifconfig_ret['errout'], delta=10)\n            self.assertAlmostEqual(\n                stats.dropin, ifconfig_ret['dropin'], delta=10)\n            self.assertAlmostEqual(\n                stats.dropout, ifconfig_ret['dropout'], delta=10)\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemNetConnections(PsutilTestCase):\n\n    @mock.patch('psutil._pslinux.socket.inet_ntop', side_effect=ValueError)\n    @mock.patch('psutil._pslinux.supports_ipv6', return_value=False)\n    def test_emulate_ipv6_unsupported(self, supports_ipv6, inet_ntop):\n        # see: https://github.com/giampaolo/psutil/issues/623\n        try:\n            s = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)\n            self.addCleanup(s.close)\n            s.bind((\"::1\", 0))\n        except socket.error:\n            pass\n        psutil.net_connections(kind='inet6')\n\n    def test_emulate_unix(self):\n        with mock_open_content(\n            '/proc/net/unix',\n            textwrap.dedent(\"\"\"\\\n                0: 00000003 000 000 0001 03 462170 @/tmp/dbus-Qw2hMPIU3n\n                0: 00000003 000 000 0001 03 35010 @/tmp/dbus-tB2X8h69BQ\n                0: 00000003 000 000 0001 03 34424 @/tmp/dbus-cHy80Y8O\n                000000000000000000000000000000000000000000000000000000\n                \"\"\")) as m:\n            psutil.net_connections(kind='unix')\n            assert m.called\n\n\n# =====================================================================\n# --- system disks\n# =====================================================================\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemDiskPartitions(PsutilTestCase):\n\n    @unittest.skipIf(not hasattr(os, 'statvfs'), \"os.statvfs() not available\")\n    @skip_on_not_implemented()\n    def test_against_df(self):\n        # test psutil.disk_usage() and psutil.disk_partitions()\n        # against \"df -a\"\n        def df(path):\n            out = sh('df -P -B 1 \"%s\"' % path).strip()\n            lines = out.split('\\n')\n            lines.pop(0)\n            line = lines.pop(0)\n            dev, total, used, free = line.split()[:4]\n            if dev == 'none':\n                dev = ''\n            total, used, free = int(total), int(used), int(free)\n            return dev, total, used, free\n\n        for part in psutil.disk_partitions(all=False):\n            usage = psutil.disk_usage(part.mountpoint)\n            dev, total, used, free = df(part.mountpoint)\n            self.assertEqual(usage.total, total)\n            self.assertAlmostEqual(usage.free, free,\n                                   delta=TOLERANCE_DISK_USAGE)\n            self.assertAlmostEqual(usage.used, used,\n                                   delta=TOLERANCE_DISK_USAGE)\n\n    def test_zfs_fs(self):\n        # Test that ZFS partitions are returned.\n        with open(\"/proc/filesystems\", \"r\") as f:\n            data = f.read()\n        if 'zfs' in data:\n            for part in psutil.disk_partitions():\n                if part.fstype == 'zfs':\n                    break\n            else:\n                self.fail(\"couldn't find any ZFS partition\")\n        else:\n            # No ZFS partitions on this system. Let's fake one.\n            fake_file = io.StringIO(u(\"nodev\\tzfs\\n\"))\n            with mock.patch('psutil._common.open',\n                            return_value=fake_file, create=True) as m1:\n                with mock.patch(\n                        'psutil._pslinux.cext.disk_partitions',\n                        return_value=[('/dev/sdb3', '/', 'zfs', 'rw')]) as m2:\n                    ret = psutil.disk_partitions()\n                    assert m1.called\n                    assert m2.called\n                    assert ret\n                    self.assertEqual(ret[0].fstype, 'zfs')\n\n    def test_emulate_realpath_fail(self):\n        # See: https://github.com/giampaolo/psutil/issues/1307\n        try:\n            with mock.patch('os.path.realpath',\n                            return_value='/non/existent') as m:\n                with self.assertRaises(FileNotFoundError):\n                    psutil.disk_partitions()\n                assert m.called\n        finally:\n            psutil.PROCFS_PATH = \"/proc\"\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemDiskIoCounters(PsutilTestCase):\n\n    def test_emulate_kernel_2_4(self):\n        # Tests /proc/diskstats parsing format for 2.4 kernels, see:\n        # https://github.com/giampaolo/psutil/issues/767\n        with mock_open_content(\n                '/proc/diskstats',\n                \"   3     0   1 hda 2 3 4 5 6 7 8 9 10 11 12\"):\n            with mock.patch('psutil._pslinux.is_storage_device',\n                            return_value=True):\n                ret = psutil.disk_io_counters(nowrap=False)\n                self.assertEqual(ret.read_count, 1)\n                self.assertEqual(ret.read_merged_count, 2)\n                self.assertEqual(ret.read_bytes, 3 * SECTOR_SIZE)\n                self.assertEqual(ret.read_time, 4)\n                self.assertEqual(ret.write_count, 5)\n                self.assertEqual(ret.write_merged_count, 6)\n                self.assertEqual(ret.write_bytes, 7 * SECTOR_SIZE)\n                self.assertEqual(ret.write_time, 8)\n                self.assertEqual(ret.busy_time, 10)\n\n    def test_emulate_kernel_2_6_full(self):\n        # Tests /proc/diskstats parsing format for 2.6 kernels,\n        # lines reporting all metrics:\n        # https://github.com/giampaolo/psutil/issues/767\n        with mock_open_content(\n                '/proc/diskstats',\n                \"   3    0   hda 1 2 3 4 5 6 7 8 9 10 11\"):\n            with mock.patch('psutil._pslinux.is_storage_device',\n                            return_value=True):\n                ret = psutil.disk_io_counters(nowrap=False)\n                self.assertEqual(ret.read_count, 1)\n                self.assertEqual(ret.read_merged_count, 2)\n                self.assertEqual(ret.read_bytes, 3 * SECTOR_SIZE)\n                self.assertEqual(ret.read_time, 4)\n                self.assertEqual(ret.write_count, 5)\n                self.assertEqual(ret.write_merged_count, 6)\n                self.assertEqual(ret.write_bytes, 7 * SECTOR_SIZE)\n                self.assertEqual(ret.write_time, 8)\n                self.assertEqual(ret.busy_time, 10)\n\n    def test_emulate_kernel_2_6_limited(self):\n        # Tests /proc/diskstats parsing format for 2.6 kernels,\n        # where one line of /proc/partitions return a limited\n        # amount of metrics when it bumps into a partition\n        # (instead of a disk). See:\n        # https://github.com/giampaolo/psutil/issues/767\n        with mock_open_content(\n                '/proc/diskstats',\n                \"   3    1   hda 1 2 3 4\"):\n            with mock.patch('psutil._pslinux.is_storage_device',\n                            return_value=True):\n                ret = psutil.disk_io_counters(nowrap=False)\n                self.assertEqual(ret.read_count, 1)\n                self.assertEqual(ret.read_bytes, 2 * SECTOR_SIZE)\n                self.assertEqual(ret.write_count, 3)\n                self.assertEqual(ret.write_bytes, 4 * SECTOR_SIZE)\n\n                self.assertEqual(ret.read_merged_count, 0)\n                self.assertEqual(ret.read_time, 0)\n                self.assertEqual(ret.write_merged_count, 0)\n                self.assertEqual(ret.write_time, 0)\n                self.assertEqual(ret.busy_time, 0)\n\n    def test_emulate_include_partitions(self):\n        # Make sure that when perdisk=True disk partitions are returned,\n        # see:\n        # https://github.com/giampaolo/psutil/pull/1313#issuecomment-408626842\n        with mock_open_content(\n                '/proc/diskstats',\n                textwrap.dedent(\"\"\"\\\n                    3    0   nvme0n1 1 2 3 4 5 6 7 8 9 10 11\n                    3    0   nvme0n1p1 1 2 3 4 5 6 7 8 9 10 11\n                    \"\"\")):\n            with mock.patch('psutil._pslinux.is_storage_device',\n                            return_value=False):\n                ret = psutil.disk_io_counters(perdisk=True, nowrap=False)\n                self.assertEqual(len(ret), 2)\n                self.assertEqual(ret['nvme0n1'].read_count, 1)\n                self.assertEqual(ret['nvme0n1p1'].read_count, 1)\n                self.assertEqual(ret['nvme0n1'].write_count, 5)\n                self.assertEqual(ret['nvme0n1p1'].write_count, 5)\n\n    def test_emulate_exclude_partitions(self):\n        # Make sure that when perdisk=False partitions (e.g. 'sda1',\n        # 'nvme0n1p1') are skipped and not included in the total count.\n        # https://github.com/giampaolo/psutil/pull/1313#issuecomment-408626842\n        with mock_open_content(\n                '/proc/diskstats',\n                textwrap.dedent(\"\"\"\\\n                    3    0   nvme0n1 1 2 3 4 5 6 7 8 9 10 11\n                    3    0   nvme0n1p1 1 2 3 4 5 6 7 8 9 10 11\n                    \"\"\")):\n            with mock.patch('psutil._pslinux.is_storage_device',\n                            return_value=False):\n                ret = psutil.disk_io_counters(perdisk=False, nowrap=False)\n                self.assertIsNone(ret)\n\n        #\n        def is_storage_device(name):\n            return name == 'nvme0n1'\n\n        with mock_open_content(\n                '/proc/diskstats',\n                textwrap.dedent(\"\"\"\\\n                    3    0   nvme0n1 1 2 3 4 5 6 7 8 9 10 11\n                    3    0   nvme0n1p1 1 2 3 4 5 6 7 8 9 10 11\n                    \"\"\")):\n            with mock.patch('psutil._pslinux.is_storage_device',\n                            create=True, side_effect=is_storage_device):\n                ret = psutil.disk_io_counters(perdisk=False, nowrap=False)\n                self.assertEqual(ret.read_count, 1)\n                self.assertEqual(ret.write_count, 5)\n\n    def test_emulate_use_sysfs(self):\n        def exists(path):\n            if path == '/proc/diskstats':\n                return False\n            return True\n\n        wprocfs = psutil.disk_io_counters(perdisk=True)\n        with mock.patch('psutil._pslinux.os.path.exists',\n                        create=True, side_effect=exists):\n            wsysfs = psutil.disk_io_counters(perdisk=True)\n        self.assertEqual(len(wprocfs), len(wsysfs))\n\n    def test_emulate_not_impl(self):\n        def exists(path):\n            return False\n\n        with mock.patch('psutil._pslinux.os.path.exists',\n                        create=True, side_effect=exists):\n            self.assertRaises(NotImplementedError, psutil.disk_io_counters)\n\n\n# =====================================================================\n# --- misc\n# =====================================================================\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestMisc(PsutilTestCase):\n\n    def test_boot_time(self):\n        vmstat_value = vmstat('boot time')\n        psutil_value = psutil.boot_time()\n        self.assertEqual(int(vmstat_value), int(psutil_value))\n\n    def test_no_procfs_on_import(self):\n        my_procfs = self.get_testfn()\n        os.mkdir(my_procfs)\n\n        with open(os.path.join(my_procfs, 'stat'), 'w') as f:\n            f.write('cpu   0 0 0 0 0 0 0 0 0 0\\n')\n            f.write('cpu0  0 0 0 0 0 0 0 0 0 0\\n')\n            f.write('cpu1  0 0 0 0 0 0 0 0 0 0\\n')\n\n        try:\n            orig_open = open\n\n            def open_mock(name, *args, **kwargs):\n                if name.startswith('/proc'):\n                    raise IOError(errno.ENOENT, 'rejecting access for test')\n                return orig_open(name, *args, **kwargs)\n\n            patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n            with mock.patch(patch_point, side_effect=open_mock):\n                reload_module(psutil)\n\n                self.assertRaises(IOError, psutil.cpu_times)\n                self.assertRaises(IOError, psutil.cpu_times, percpu=True)\n                self.assertRaises(IOError, psutil.cpu_percent)\n                self.assertRaises(IOError, psutil.cpu_percent, percpu=True)\n                self.assertRaises(IOError, psutil.cpu_times_percent)\n                self.assertRaises(\n                    IOError, psutil.cpu_times_percent, percpu=True)\n\n                psutil.PROCFS_PATH = my_procfs\n\n                self.assertEqual(psutil.cpu_percent(), 0)\n                self.assertEqual(sum(psutil.cpu_times_percent()), 0)\n\n                # since we don't know the number of CPUs at import time,\n                # we awkwardly say there are none until the second call\n                per_cpu_percent = psutil.cpu_percent(percpu=True)\n                self.assertEqual(sum(per_cpu_percent), 0)\n\n                # ditto awkward length\n                per_cpu_times_percent = psutil.cpu_times_percent(percpu=True)\n                self.assertEqual(sum(map(sum, per_cpu_times_percent)), 0)\n\n                # much user, very busy\n                with open(os.path.join(my_procfs, 'stat'), 'w') as f:\n                    f.write('cpu   1 0 0 0 0 0 0 0 0 0\\n')\n                    f.write('cpu0  1 0 0 0 0 0 0 0 0 0\\n')\n                    f.write('cpu1  1 0 0 0 0 0 0 0 0 0\\n')\n\n                self.assertNotEqual(psutil.cpu_percent(), 0)\n                self.assertNotEqual(\n                    sum(psutil.cpu_percent(percpu=True)), 0)\n                self.assertNotEqual(sum(psutil.cpu_times_percent()), 0)\n                self.assertNotEqual(\n                    sum(map(sum, psutil.cpu_times_percent(percpu=True))), 0)\n        finally:\n            shutil.rmtree(my_procfs)\n            reload_module(psutil)\n\n        self.assertEqual(psutil.PROCFS_PATH, '/proc')\n\n    def test_cpu_steal_decrease(self):\n        # Test cumulative cpu stats decrease. We should ignore this.\n        # See issue #1210.\n        with mock_open_content(\n            \"/proc/stat\",\n            textwrap.dedent(\"\"\"\\\n                cpu   0 0 0 0 0 0 0 1 0 0\n                cpu0  0 0 0 0 0 0 0 1 0 0\n                cpu1  0 0 0 0 0 0 0 1 0 0\n                \"\"\").encode()) as m:\n            # first call to \"percent\" functions should read the new stat file\n            # and compare to the \"real\" file read at import time - so the\n            # values are meaningless\n            psutil.cpu_percent()\n            assert m.called\n            psutil.cpu_percent(percpu=True)\n            psutil.cpu_times_percent()\n            psutil.cpu_times_percent(percpu=True)\n\n        with mock_open_content(\n            \"/proc/stat\",\n            textwrap.dedent(\"\"\"\\\n                cpu   1 0 0 0 0 0 0 0 0 0\n                cpu0  1 0 0 0 0 0 0 0 0 0\n                cpu1  1 0 0 0 0 0 0 0 0 0\n                \"\"\").encode()) as m:\n            # Increase \"user\" while steal goes \"backwards\" to zero.\n            cpu_percent = psutil.cpu_percent()\n            assert m.called\n            cpu_percent_percpu = psutil.cpu_percent(percpu=True)\n            cpu_times_percent = psutil.cpu_times_percent()\n            cpu_times_percent_percpu = psutil.cpu_times_percent(percpu=True)\n            self.assertNotEqual(cpu_percent, 0)\n            self.assertNotEqual(sum(cpu_percent_percpu), 0)\n            self.assertNotEqual(sum(cpu_times_percent), 0)\n            self.assertNotEqual(sum(cpu_times_percent), 100.0)\n            self.assertNotEqual(sum(map(sum, cpu_times_percent_percpu)), 0)\n            self.assertNotEqual(sum(map(sum, cpu_times_percent_percpu)), 100.0)\n            self.assertEqual(cpu_times_percent.steal, 0)\n            self.assertNotEqual(cpu_times_percent.user, 0)\n\n    def test_boot_time_mocked(self):\n        with mock.patch('psutil._common.open', create=True) as m:\n            self.assertRaises(\n                RuntimeError,\n                psutil._pslinux.boot_time)\n            assert m.called\n\n    def test_users_mocked(self):\n        # Make sure ':0' and ':0.0' (returned by C ext) are converted\n        # to 'localhost'.\n        with mock.patch('psutil._pslinux.cext.users',\n                        return_value=[('giampaolo', 'pts/2', ':0',\n                                       1436573184.0, True, 2)]) as m:\n            self.assertEqual(psutil.users()[0].host, 'localhost')\n            assert m.called\n        with mock.patch('psutil._pslinux.cext.users',\n                        return_value=[('giampaolo', 'pts/2', ':0.0',\n                                       1436573184.0, True, 2)]) as m:\n            self.assertEqual(psutil.users()[0].host, 'localhost')\n            assert m.called\n        # ...otherwise it should be returned as-is\n        with mock.patch('psutil._pslinux.cext.users',\n                        return_value=[('giampaolo', 'pts/2', 'foo',\n                                       1436573184.0, True, 2)]) as m:\n            self.assertEqual(psutil.users()[0].host, 'foo')\n            assert m.called\n\n    def test_procfs_path(self):\n        tdir = self.get_testfn()\n        os.mkdir(tdir)\n        try:\n            psutil.PROCFS_PATH = tdir\n            self.assertRaises(IOError, psutil.virtual_memory)\n            self.assertRaises(IOError, psutil.cpu_times)\n            self.assertRaises(IOError, psutil.cpu_times, percpu=True)\n            self.assertRaises(IOError, psutil.boot_time)\n            # self.assertRaises(IOError, psutil.pids)\n            self.assertRaises(IOError, psutil.net_connections)\n            self.assertRaises(IOError, psutil.net_io_counters)\n            self.assertRaises(IOError, psutil.net_if_stats)\n            # self.assertRaises(IOError, psutil.disk_io_counters)\n            self.assertRaises(IOError, psutil.disk_partitions)\n            self.assertRaises(psutil.NoSuchProcess, psutil.Process)\n        finally:\n            psutil.PROCFS_PATH = \"/proc\"\n\n    @retry_on_failure()\n    def test_issue_687(self):\n        # In case of thread ID:\n        # - pid_exists() is supposed to return False\n        # - Process(tid) is supposed to work\n        # - pids() should not return the TID\n        # See: https://github.com/giampaolo/psutil/issues/687\n        t = ThreadTask()\n        t.start()\n        try:\n            p = psutil.Process()\n            threads = p.threads()\n            self.assertEqual(len(threads), 2)\n            tid = sorted(threads, key=lambda x: x.id)[1].id\n            self.assertNotEqual(p.pid, tid)\n            pt = psutil.Process(tid)\n            pt.as_dict()\n            self.assertNotIn(tid, psutil.pids())\n        finally:\n            t.stop()\n\n    def test_pid_exists_no_proc_status(self):\n        # Internally pid_exists relies on /proc/{pid}/status.\n        # Emulate a case where this file is empty in which case\n        # psutil is supposed to fall back on using pids().\n        with mock_open_content(\"/proc/%s/status\", \"\") as m:\n            assert psutil.pid_exists(os.getpid())\n            assert m.called\n\n\n# =====================================================================\n# --- sensors\n# =====================================================================\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\n@unittest.skipIf(not HAS_BATTERY, \"no battery\")\nclass TestSensorsBattery(PsutilTestCase):\n\n    @unittest.skipIf(not which(\"acpi\"), \"acpi utility not available\")\n    def test_percent(self):\n        out = sh(\"acpi -b\")\n        acpi_value = int(out.split(\",\")[1].strip().replace('%', ''))\n        psutil_value = psutil.sensors_battery().percent\n        self.assertAlmostEqual(acpi_value, psutil_value, delta=1)\n\n    def test_emulate_power_plugged(self):\n        # Pretend the AC power cable is connected.\n        def open_mock(name, *args, **kwargs):\n            if name.endswith(\"AC0/online\") or name.endswith(\"AC/online\"):\n                return io.BytesIO(b\"1\")\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, side_effect=open_mock) as m:\n            self.assertEqual(psutil.sensors_battery().power_plugged, True)\n            self.assertEqual(\n                psutil.sensors_battery().secsleft, psutil.POWER_TIME_UNLIMITED)\n            assert m.called\n\n    def test_emulate_power_plugged_2(self):\n        # Same as above but pretend /AC0/online does not exist in which\n        # case code relies on /status file.\n        def open_mock(name, *args, **kwargs):\n            if name.endswith(\"AC0/online\") or name.endswith(\"AC/online\"):\n                raise IOError(errno.ENOENT, \"\")\n            elif name.endswith(\"/status\"):\n                return io.StringIO(u(\"charging\"))\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, side_effect=open_mock) as m:\n            self.assertEqual(psutil.sensors_battery().power_plugged, True)\n            assert m.called\n\n    def test_emulate_power_not_plugged(self):\n        # Pretend the AC power cable is not connected.\n        def open_mock(name, *args, **kwargs):\n            if name.endswith(\"AC0/online\") or name.endswith(\"AC/online\"):\n                return io.BytesIO(b\"0\")\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, side_effect=open_mock) as m:\n            self.assertEqual(psutil.sensors_battery().power_plugged, False)\n            assert m.called\n\n    def test_emulate_power_not_plugged_2(self):\n        # Same as above but pretend /AC0/online does not exist in which\n        # case code relies on /status file.\n        def open_mock(name, *args, **kwargs):\n            if name.endswith(\"AC0/online\") or name.endswith(\"AC/online\"):\n                raise IOError(errno.ENOENT, \"\")\n            elif name.endswith(\"/status\"):\n                return io.StringIO(u(\"discharging\"))\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, side_effect=open_mock) as m:\n            self.assertEqual(psutil.sensors_battery().power_plugged, False)\n            assert m.called\n\n    def test_emulate_power_undetermined(self):\n        # Pretend we can't know whether the AC power cable not\n        # connected (assert fallback to False).\n        def open_mock(name, *args, **kwargs):\n            if name.startswith(\"/sys/class/power_supply/AC0/online\") or \\\n                    name.startswith(\"/sys/class/power_supply/AC/online\"):\n                raise IOError(errno.ENOENT, \"\")\n            elif name.startswith(\"/sys/class/power_supply/BAT0/status\"):\n                return io.BytesIO(b\"???\")\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, side_effect=open_mock) as m:\n            self.assertIsNone(psutil.sensors_battery().power_plugged)\n            assert m.called\n\n    def test_emulate_energy_full_0(self):\n        # Emulate a case where energy_full files returns 0.\n        with mock_open_content(\n                \"/sys/class/power_supply/BAT0/energy_full\", b\"0\") as m:\n            self.assertEqual(psutil.sensors_battery().percent, 0)\n            assert m.called\n\n    def test_emulate_energy_full_not_avail(self):\n        # Emulate a case where energy_full file does not exist.\n        # Expected fallback on /capacity.\n        with mock_open_exception(\n                \"/sys/class/power_supply/BAT0/energy_full\",\n                IOError(errno.ENOENT, \"\")):\n            with mock_open_exception(\n                    \"/sys/class/power_supply/BAT0/charge_full\",\n                    IOError(errno.ENOENT, \"\")):\n                with mock_open_content(\n                        \"/sys/class/power_supply/BAT0/capacity\", b\"88\"):\n                    self.assertEqual(psutil.sensors_battery().percent, 88)\n\n    def test_emulate_no_power(self):\n        # Emulate a case where /AC0/online file nor /BAT0/status exist.\n        with mock_open_exception(\n                \"/sys/class/power_supply/AC/online\",\n                IOError(errno.ENOENT, \"\")):\n            with mock_open_exception(\n                    \"/sys/class/power_supply/AC0/online\",\n                    IOError(errno.ENOENT, \"\")):\n                with mock_open_exception(\n                        \"/sys/class/power_supply/BAT0/status\",\n                        IOError(errno.ENOENT, \"\")):\n                    self.assertIsNone(psutil.sensors_battery().power_plugged)\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSensorsBatteryEmulated(PsutilTestCase):\n\n    def test_it(self):\n        def open_mock(name, *args, **kwargs):\n            if name.endswith(\"/energy_now\"):\n                return io.StringIO(u(\"60000000\"))\n            elif name.endswith(\"/power_now\"):\n                return io.StringIO(u(\"0\"))\n            elif name.endswith(\"/energy_full\"):\n                return io.StringIO(u(\"60000001\"))\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch('os.listdir', return_value=[\"BAT0\"]) as mlistdir:\n            with mock.patch(patch_point, side_effect=open_mock) as mopen:\n                self.assertIsNotNone(psutil.sensors_battery())\n        assert mlistdir.called\n        assert mopen.called\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSensorsTemperatures(PsutilTestCase):\n\n    def test_emulate_class_hwmon(self):\n        def open_mock(name, *args, **kwargs):\n            if name.endswith('/name'):\n                return io.StringIO(u(\"name\"))\n            elif name.endswith('/temp1_label'):\n                return io.StringIO(u(\"label\"))\n            elif name.endswith('/temp1_input'):\n                return io.BytesIO(b\"30000\")\n            elif name.endswith('/temp1_max'):\n                return io.BytesIO(b\"40000\")\n            elif name.endswith('/temp1_crit'):\n                return io.BytesIO(b\"50000\")\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, side_effect=open_mock):\n            # Test case with /sys/class/hwmon\n            with mock.patch('glob.glob',\n                            return_value=['/sys/class/hwmon/hwmon0/temp1']):\n                temp = psutil.sensors_temperatures()['name'][0]\n                self.assertEqual(temp.label, 'label')\n                self.assertEqual(temp.current, 30.0)\n                self.assertEqual(temp.high, 40.0)\n                self.assertEqual(temp.critical, 50.0)\n\n    def test_emulate_class_thermal(self):\n        def open_mock(name, *args, **kwargs):\n            if name.endswith('0_temp'):\n                return io.BytesIO(b\"50000\")\n            elif name.endswith('temp'):\n                return io.BytesIO(b\"30000\")\n            elif name.endswith('0_type'):\n                return io.StringIO(u(\"critical\"))\n            elif name.endswith('type'):\n                return io.StringIO(u(\"name\"))\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        def glob_mock(path):\n            if path == '/sys/class/hwmon/hwmon*/temp*_*':\n                return []\n            elif path == '/sys/class/hwmon/hwmon*/device/temp*_*':\n                return []\n            elif path == '/sys/class/thermal/thermal_zone*':\n                return ['/sys/class/thermal/thermal_zone0']\n            elif path == '/sys/class/thermal/thermal_zone0/trip_point*':\n                return ['/sys/class/thermal/thermal_zone1/trip_point_0_type',\n                        '/sys/class/thermal/thermal_zone1/trip_point_0_temp']\n            return []\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, side_effect=open_mock):\n            with mock.patch('glob.glob', create=True, side_effect=glob_mock):\n                temp = psutil.sensors_temperatures()['name'][0]\n                self.assertEqual(temp.label, '')\n                self.assertEqual(temp.current, 30.0)\n                self.assertEqual(temp.high, 50.0)\n                self.assertEqual(temp.critical, 50.0)\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSensorsFans(PsutilTestCase):\n\n    def test_emulate_data(self):\n        def open_mock(name, *args, **kwargs):\n            if name.endswith('/name'):\n                return io.StringIO(u(\"name\"))\n            elif name.endswith('/fan1_label'):\n                return io.StringIO(u(\"label\"))\n            elif name.endswith('/fan1_input'):\n                return io.StringIO(u(\"2000\"))\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, side_effect=open_mock):\n            with mock.patch('glob.glob',\n                            return_value=['/sys/class/hwmon/hwmon2/fan1']):\n                fan = psutil.sensors_fans()['name'][0]\n                self.assertEqual(fan.label, 'label')\n                self.assertEqual(fan.current, 2000)\n\n\n# =====================================================================\n# --- test process\n# =====================================================================\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestProcess(PsutilTestCase):\n\n    @retry_on_failure()\n    def test_memory_full_info(self):\n        testfn = self.get_testfn()\n        src = textwrap.dedent(\"\"\"\n            import time\n            with open(\"%s\", \"w\") as f:\n                time.sleep(10)\n            \"\"\" % testfn)\n        sproc = self.pyrun(src)\n        call_until(lambda: os.listdir('.'), \"'%s' not in ret\" % testfn)\n        p = psutil.Process(sproc.pid)\n        time.sleep(.1)\n        mem = p.memory_full_info()\n        maps = p.memory_maps(grouped=False)\n        self.assertAlmostEqual(\n            mem.uss, sum([x.private_dirty + x.private_clean for x in maps]),\n            delta=4096)\n        self.assertAlmostEqual(\n            mem.pss, sum([x.pss for x in maps]), delta=4096)\n        self.assertAlmostEqual(\n            mem.swap, sum([x.swap for x in maps]), delta=4096)\n\n    def test_memory_full_info_mocked(self):\n        # See: https://github.com/giampaolo/psutil/issues/1222\n        with mock_open_content(\n            \"/proc/%s/smaps\" % os.getpid(),\n            textwrap.dedent(\"\"\"\\\n                fffff0 r-xp 00000000 00:00 0                  [vsyscall]\n                Size:                  1 kB\n                Rss:                   2 kB\n                Pss:                   3 kB\n                Shared_Clean:          4 kB\n                Shared_Dirty:          5 kB\n                Private_Clean:         6 kB\n                Private_Dirty:         7 kB\n                Referenced:            8 kB\n                Anonymous:             9 kB\n                LazyFree:              10 kB\n                AnonHugePages:         11 kB\n                ShmemPmdMapped:        12 kB\n                Shared_Hugetlb:        13 kB\n                Private_Hugetlb:       14 kB\n                Swap:                  15 kB\n                SwapPss:               16 kB\n                KernelPageSize:        17 kB\n                MMUPageSize:           18 kB\n                Locked:                19 kB\n                VmFlags: rd ex\n                \"\"\").encode()) as m:\n            p = psutil.Process()\n            mem = p.memory_full_info()\n            assert m.called\n            self.assertEqual(mem.uss, (6 + 7 + 14) * 1024)\n            self.assertEqual(mem.pss, 3 * 1024)\n            self.assertEqual(mem.swap, 15 * 1024)\n\n    # On PYPY file descriptors are not closed fast enough.\n    @unittest.skipIf(PYPY, \"unreliable on PYPY\")\n    def test_open_files_mode(self):\n        def get_test_file(fname):\n            p = psutil.Process()\n            giveup_at = time.time() + GLOBAL_TIMEOUT\n            while True:\n                for file in p.open_files():\n                    if file.path == os.path.abspath(fname):\n                        return file\n                    elif time.time() > giveup_at:\n                        break\n            raise RuntimeError(\"timeout looking for test file\")\n\n        #\n        testfn = self.get_testfn()\n        with open(testfn, \"w\"):\n            self.assertEqual(get_test_file(testfn).mode, \"w\")\n        with open(testfn, \"r\"):\n            self.assertEqual(get_test_file(testfn).mode, \"r\")\n        with open(testfn, \"a\"):\n            self.assertEqual(get_test_file(testfn).mode, \"a\")\n        #\n        with open(testfn, \"r+\"):\n            self.assertEqual(get_test_file(testfn).mode, \"r+\")\n        with open(testfn, \"w+\"):\n            self.assertEqual(get_test_file(testfn).mode, \"r+\")\n        with open(testfn, \"a+\"):\n            self.assertEqual(get_test_file(testfn).mode, \"a+\")\n        # note: \"x\" bit is not supported\n        if PY3:\n            safe_rmpath(testfn)\n            with open(testfn, \"x\"):\n                self.assertEqual(get_test_file(testfn).mode, \"w\")\n            safe_rmpath(testfn)\n            with open(testfn, \"x+\"):\n                self.assertEqual(get_test_file(testfn).mode, \"r+\")\n\n    def test_open_files_file_gone(self):\n        # simulates a file which gets deleted during open_files()\n        # execution\n        p = psutil.Process()\n        files = p.open_files()\n        with open(self.get_testfn(), 'w'):\n            # give the kernel some time to see the new file\n            call_until(p.open_files, \"len(ret) != %i\" % len(files))\n            with mock.patch('psutil._pslinux.os.readlink',\n                            side_effect=OSError(errno.ENOENT, \"\")) as m:\n                files = p.open_files()\n                assert not files\n                assert m.called\n            # also simulate the case where os.readlink() returns EINVAL\n            # in which case psutil is supposed to 'continue'\n            with mock.patch('psutil._pslinux.os.readlink',\n                            side_effect=OSError(errno.EINVAL, \"\")) as m:\n                self.assertEqual(p.open_files(), [])\n                assert m.called\n\n    def test_open_files_fd_gone(self):\n        # Simulate a case where /proc/{pid}/fdinfo/{fd} disappears\n        # while iterating through fds.\n        # https://travis-ci.org/giampaolo/psutil/jobs/225694530\n        p = psutil.Process()\n        files = p.open_files()\n        with open(self.get_testfn(), 'w'):\n            # give the kernel some time to see the new file\n            call_until(p.open_files, \"len(ret) != %i\" % len(files))\n            patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n            with mock.patch(patch_point,\n                            side_effect=IOError(errno.ENOENT, \"\")) as m:\n                files = p.open_files()\n                assert not files\n                assert m.called\n\n    # --- mocked tests\n\n    def test_terminal_mocked(self):\n        with mock.patch('psutil._pslinux._psposix.get_terminal_map',\n                        return_value={}) as m:\n            self.assertIsNone(psutil._pslinux.Process(os.getpid()).terminal())\n            assert m.called\n\n    # TODO: re-enable this test.\n    # def test_num_ctx_switches_mocked(self):\n    #     with mock.patch('psutil._common.open', create=True) as m:\n    #         self.assertRaises(\n    #             NotImplementedError,\n    #             psutil._pslinux.Process(os.getpid()).num_ctx_switches)\n    #         assert m.called\n\n    def test_cmdline_mocked(self):\n        # see: https://github.com/giampaolo/psutil/issues/639\n        p = psutil.Process()\n        fake_file = io.StringIO(u('foo\\x00bar\\x00'))\n        with mock.patch('psutil._common.open',\n                        return_value=fake_file, create=True) as m:\n            self.assertEqual(p.cmdline(), ['foo', 'bar'])\n            assert m.called\n        fake_file = io.StringIO(u('foo\\x00bar\\x00\\x00'))\n        with mock.patch('psutil._common.open',\n                        return_value=fake_file, create=True) as m:\n            self.assertEqual(p.cmdline(), ['foo', 'bar', ''])\n            assert m.called\n\n    def test_cmdline_spaces_mocked(self):\n        # see: https://github.com/giampaolo/psutil/issues/1179\n        p = psutil.Process()\n        fake_file = io.StringIO(u('foo bar '))\n        with mock.patch('psutil._common.open',\n                        return_value=fake_file, create=True) as m:\n            self.assertEqual(p.cmdline(), ['foo', 'bar'])\n            assert m.called\n        fake_file = io.StringIO(u('foo bar  '))\n        with mock.patch('psutil._common.open',\n                        return_value=fake_file, create=True) as m:\n            self.assertEqual(p.cmdline(), ['foo', 'bar', ''])\n            assert m.called\n\n    def test_cmdline_mixed_separators(self):\n        # https://github.com/giampaolo/psutil/issues/\n        #    1179#issuecomment-552984549\n        p = psutil.Process()\n        fake_file = io.StringIO(u('foo\\x20bar\\x00'))\n        with mock.patch('psutil._common.open',\n                        return_value=fake_file, create=True) as m:\n            self.assertEqual(p.cmdline(), ['foo', 'bar'])\n            assert m.called\n\n    def test_readlink_path_deleted_mocked(self):\n        with mock.patch('psutil._pslinux.os.readlink',\n                        return_value='/home/foo (deleted)'):\n            self.assertEqual(psutil.Process().exe(), \"/home/foo\")\n            self.assertEqual(psutil.Process().cwd(), \"/home/foo\")\n\n    def test_threads_mocked(self):\n        # Test the case where os.listdir() returns a file (thread)\n        # which no longer exists by the time we open() it (race\n        # condition). threads() is supposed to ignore that instead\n        # of raising NSP.\n        def open_mock(name, *args, **kwargs):\n            if name.startswith('/proc/%s/task' % os.getpid()):\n                raise IOError(errno.ENOENT, \"\")\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, side_effect=open_mock) as m:\n            ret = psutil.Process().threads()\n            assert m.called\n            self.assertEqual(ret, [])\n\n        # ...but if it bumps into something != ENOENT we want an\n        # exception.\n        def open_mock(name, *args, **kwargs):\n            if name.startswith('/proc/%s/task' % os.getpid()):\n                raise IOError(errno.EPERM, \"\")\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        with mock.patch(patch_point, side_effect=open_mock):\n            self.assertRaises(psutil.AccessDenied, psutil.Process().threads)\n\n    def test_exe_mocked(self):\n        with mock.patch('psutil._pslinux.readlink',\n                        side_effect=OSError(errno.ENOENT, \"\")) as m1:\n            with mock.patch('psutil.Process.cmdline',\n                            side_effect=psutil.AccessDenied(0, \"\")) as m2:\n                # No such file error; might be raised also if /proc/pid/exe\n                # path actually exists for system processes with low pids\n                # (about 0-20). In this case psutil is supposed to return\n                # an empty string.\n                ret = psutil.Process().exe()\n                assert m1.called\n                assert m2.called\n                self.assertEqual(ret, \"\")\n\n                # ...but if /proc/pid no longer exist we're supposed to treat\n                # it as an alias for zombie process\n                with mock.patch('psutil._pslinux.os.path.lexists',\n                                return_value=False):\n                    self.assertRaises(\n                        psutil.ZombieProcess, psutil.Process().exe)\n\n    def test_issue_1014(self):\n        # Emulates a case where smaps file does not exist. In this case\n        # wrap_exception decorator should not raise NoSuchProcess.\n        with mock_open_exception(\n                '/proc/%s/smaps' % os.getpid(),\n                IOError(errno.ENOENT, \"\")) as m:\n            p = psutil.Process()\n            with self.assertRaises(FileNotFoundError):\n                p.memory_maps()\n            assert m.called\n\n    @unittest.skipIf(not HAS_RLIMIT, \"not supported\")\n    def test_rlimit_zombie(self):\n        # Emulate a case where rlimit() raises ENOSYS, which may\n        # happen in case of zombie process:\n        # https://travis-ci.org/giampaolo/psutil/jobs/51368273\n        with mock.patch(\"psutil._pslinux.prlimit\",\n                        side_effect=OSError(errno.ENOSYS, \"\")) as m:\n            p = psutil.Process()\n            p.name()\n            with self.assertRaises(psutil.ZombieProcess) as exc:\n                p.rlimit(psutil.RLIMIT_NOFILE)\n            assert m.called\n        self.assertEqual(exc.exception.pid, p.pid)\n        self.assertEqual(exc.exception.name, p.name())\n\n    def test_cwd_zombie(self):\n        with mock.patch(\"psutil._pslinux.os.readlink\",\n                        side_effect=OSError(errno.ENOENT, \"\")) as m:\n            p = psutil.Process()\n            p.name()\n            with self.assertRaises(psutil.ZombieProcess) as exc:\n                p.cwd()\n            assert m.called\n        self.assertEqual(exc.exception.pid, p.pid)\n        self.assertEqual(exc.exception.name, p.name())\n\n    def test_stat_file_parsing(self):\n        from psutil._pslinux import CLOCK_TICKS\n\n        args = [\n            \"0\",      # pid\n            \"(cat)\",  # name\n            \"Z\",      # status\n            \"1\",      # ppid\n            \"0\",      # pgrp\n            \"0\",      # session\n            \"0\",      # tty\n            \"0\",      # tpgid\n            \"0\",      # flags\n            \"0\",      # minflt\n            \"0\",      # cminflt\n            \"0\",      # majflt\n            \"0\",      # cmajflt\n            \"2\",      # utime\n            \"3\",      # stime\n            \"4\",      # cutime\n            \"5\",      # cstime\n            \"0\",      # priority\n            \"0\",      # nice\n            \"0\",      # num_threads\n            \"0\",      # itrealvalue\n            \"6\",      # starttime\n            \"0\",      # vsize\n            \"0\",      # rss\n            \"0\",      # rsslim\n            \"0\",      # startcode\n            \"0\",      # endcode\n            \"0\",      # startstack\n            \"0\",      # kstkesp\n            \"0\",      # kstkeip\n            \"0\",      # signal\n            \"0\",      # blocked\n            \"0\",      # sigignore\n            \"0\",      # sigcatch\n            \"0\",      # wchan\n            \"0\",      # nswap\n            \"0\",      # cnswap\n            \"0\",      # exit_signal\n            \"6\",      # processor\n            \"0\",      # rt priority\n            \"0\",      # policy\n            \"7\",      # delayacct_blkio_ticks\n        ]\n        content = \" \".join(args).encode()\n        with mock_open_content('/proc/%s/stat' % os.getpid(), content):\n            p = psutil.Process()\n            self.assertEqual(p.name(), 'cat')\n            self.assertEqual(p.status(), psutil.STATUS_ZOMBIE)\n            self.assertEqual(p.ppid(), 1)\n            self.assertEqual(\n                p.create_time(), 6 / CLOCK_TICKS + psutil.boot_time())\n            cpu = p.cpu_times()\n            self.assertEqual(cpu.user, 2 / CLOCK_TICKS)\n            self.assertEqual(cpu.system, 3 / CLOCK_TICKS)\n            self.assertEqual(cpu.children_user, 4 / CLOCK_TICKS)\n            self.assertEqual(cpu.children_system, 5 / CLOCK_TICKS)\n            self.assertEqual(cpu.iowait, 7 / CLOCK_TICKS)\n            self.assertEqual(p.cpu_num(), 6)\n\n    def test_status_file_parsing(self):\n        with mock_open_content(\n            '/proc/%s/status' % os.getpid(),\n            textwrap.dedent(\"\"\"\\\n                Uid:\\t1000\\t1001\\t1002\\t1003\n                Gid:\\t1004\\t1005\\t1006\\t1007\n                Threads:\\t66\n                Cpus_allowed:\\tf\n                Cpus_allowed_list:\\t0-7\n                voluntary_ctxt_switches:\\t12\n                nonvoluntary_ctxt_switches:\\t13\"\"\").encode()):\n            p = psutil.Process()\n            self.assertEqual(p.num_ctx_switches().voluntary, 12)\n            self.assertEqual(p.num_ctx_switches().involuntary, 13)\n            self.assertEqual(p.num_threads(), 66)\n            uids = p.uids()\n            self.assertEqual(uids.real, 1000)\n            self.assertEqual(uids.effective, 1001)\n            self.assertEqual(uids.saved, 1002)\n            gids = p.gids()\n            self.assertEqual(gids.real, 1004)\n            self.assertEqual(gids.effective, 1005)\n            self.assertEqual(gids.saved, 1006)\n            self.assertEqual(p._proc._get_eligible_cpus(), list(range(0, 8)))\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestProcessAgainstStatus(PsutilTestCase):\n    \"\"\"/proc/pid/stat and /proc/pid/status have many values in common.\n    Whenever possible, psutil uses /proc/pid/stat (it's faster).\n    For all those cases we check that the value found in\n    /proc/pid/stat (by psutil) matches the one found in\n    /proc/pid/status.\n    \"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        cls.proc = psutil.Process()\n\n    def read_status_file(self, linestart):\n        with psutil._psplatform.open_text(\n                '/proc/%s/status' % self.proc.pid) as f:\n            for line in f:\n                line = line.strip()\n                if line.startswith(linestart):\n                    value = line.partition('\\t')[2]\n                    try:\n                        return int(value)\n                    except ValueError:\n                        return value\n            raise ValueError(\"can't find %r\" % linestart)\n\n    def test_name(self):\n        value = self.read_status_file(\"Name:\")\n        self.assertEqual(self.proc.name(), value)\n\n    def test_status(self):\n        value = self.read_status_file(\"State:\")\n        value = value[value.find('(') + 1:value.rfind(')')]\n        value = value.replace(' ', '-')\n        self.assertEqual(self.proc.status(), value)\n\n    def test_ppid(self):\n        value = self.read_status_file(\"PPid:\")\n        self.assertEqual(self.proc.ppid(), value)\n\n    def test_num_threads(self):\n        value = self.read_status_file(\"Threads:\")\n        self.assertEqual(self.proc.num_threads(), value)\n\n    def test_uids(self):\n        value = self.read_status_file(\"Uid:\")\n        value = tuple(map(int, value.split()[1:4]))\n        self.assertEqual(self.proc.uids(), value)\n\n    def test_gids(self):\n        value = self.read_status_file(\"Gid:\")\n        value = tuple(map(int, value.split()[1:4]))\n        self.assertEqual(self.proc.gids(), value)\n\n    @retry_on_failure()\n    def test_num_ctx_switches(self):\n        value = self.read_status_file(\"voluntary_ctxt_switches:\")\n        self.assertEqual(self.proc.num_ctx_switches().voluntary, value)\n        value = self.read_status_file(\"nonvoluntary_ctxt_switches:\")\n        self.assertEqual(self.proc.num_ctx_switches().involuntary, value)\n\n    def test_cpu_affinity(self):\n        value = self.read_status_file(\"Cpus_allowed_list:\")\n        if '-' in str(value):\n            min_, max_ = map(int, value.split('-'))\n            self.assertEqual(\n                self.proc.cpu_affinity(), list(range(min_, max_ + 1)))\n\n    def test_cpu_affinity_eligible_cpus(self):\n        value = self.read_status_file(\"Cpus_allowed_list:\")\n        with mock.patch(\"psutil._pslinux.per_cpu_times\") as m:\n            self.proc._proc._get_eligible_cpus()\n        if '-' in str(value):\n            assert not m.called\n        else:\n            assert m.called\n\n\n# =====================================================================\n# --- test utils\n# =====================================================================\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestUtils(PsutilTestCase):\n\n    def test_readlink(self):\n        with mock.patch(\"os.readlink\", return_value=\"foo (deleted)\") as m:\n            self.assertEqual(psutil._psplatform.readlink(\"bar\"), \"foo\")\n            assert m.called\n\n    def test_cat(self):\n        testfn = self.get_testfn()\n        with open(testfn, \"wt\") as f:\n            f.write(\"foo \")\n        self.assertEqual(psutil._psplatform.cat(testfn, binary=False), \"foo\")\n        self.assertEqual(psutil._psplatform.cat(testfn, binary=True), b\"foo\")\n        self.assertEqual(\n            psutil._psplatform.cat(testfn + '??', fallback=\"bar\"), \"bar\")\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n    run_from_name(__file__)\n"
                    },
                    "test_memleaks": {
                        "type": "module",
                        "extension": "py",
                        "code": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"\nTests for detecting function memory leaks (typically the ones\nimplemented in C). It does so by calling a function many times and\nchecking whether process memory usage keeps increasing between\ncalls or over time.\nNote that this may produce false positives (especially on Windows\nfor some reason).\nPyPy appears to be completely unstable for this framework, probably\nbecause of how its JIT handles memory, so tests are skipped.\n\"\"\"\n\nfrom __future__ import print_function\nimport functools\nimport os\n\nimport psutil\nimport psutil._common\nfrom psutil import LINUX\nfrom psutil import MACOS\nfrom psutil import OPENBSD\nfrom psutil import POSIX\nfrom psutil import SUNOS\nfrom psutil import WINDOWS\nfrom psutil._compat import ProcessLookupError\nfrom psutil._compat import super\nfrom psutil.tests import create_sockets\nfrom psutil.tests import get_testfn\nfrom psutil.tests import HAS_CPU_AFFINITY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_ENVIRON\nfrom psutil.tests import HAS_IONICE\nfrom psutil.tests import HAS_MEMORY_MAPS\nfrom psutil.tests import HAS_NET_IO_COUNTERS\nfrom psutil.tests import HAS_PROC_CPU_NUM\nfrom psutil.tests import HAS_PROC_IO_COUNTERS\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import HAS_SENSORS_BATTERY\nfrom psutil.tests import HAS_SENSORS_FANS\nfrom psutil.tests import HAS_SENSORS_TEMPERATURES\nfrom psutil.tests import process_namespace\nfrom psutil.tests import skip_on_access_denied\nfrom psutil.tests import spawn_testproc\nfrom psutil.tests import system_namespace\nfrom psutil.tests import terminate\nfrom psutil.tests import TestMemoryLeak\nfrom psutil.tests import unittest\n\n\ncext = psutil._psplatform.cext\nthisproc = psutil.Process()\nFEW_TIMES = 5\n\n\ndef fewtimes_if_linux():\n    \"\"\"Decorator for those Linux functions which are implemented in pure\n    Python, and which we want to run faster.\n    \"\"\"\n    def decorator(fun):\n        @functools.wraps(fun)\n        def wrapper(self, *args, **kwargs):\n            if LINUX:\n                before = self.__class__.times\n                try:\n                    self.__class__.times = FEW_TIMES\n                    return fun(self, *args, **kwargs)\n                finally:\n                    self.__class__.times = before\n            else:\n                return fun(self, *args, **kwargs)\n        return wrapper\n    return decorator\n\n\n# ===================================================================\n# Process class\n# ===================================================================\n\n\nclass TestProcessObjectLeaks(TestMemoryLeak):\n    \"\"\"Test leaks of Process class methods.\"\"\"\n\n    proc = thisproc\n\n    def test_coverage(self):\n        ns = process_namespace(None)\n        ns.test_class_coverage(self, ns.getters + ns.setters)\n\n    @fewtimes_if_linux()\n    def test_name(self):\n        self.execute(self.proc.name)\n\n    @fewtimes_if_linux()\n    def test_cmdline(self):\n        self.execute(self.proc.cmdline)\n\n    @fewtimes_if_linux()\n    def test_exe(self):\n        self.execute(self.proc.exe)\n\n    @fewtimes_if_linux()\n    def test_ppid(self):\n        self.execute(self.proc.ppid)\n\n    @unittest.skipIf(not POSIX, \"POSIX only\")\n    @fewtimes_if_linux()\n    def test_uids(self):\n        self.execute(self.proc.uids)\n\n    @unittest.skipIf(not POSIX, \"POSIX only\")\n    @fewtimes_if_linux()\n    def test_gids(self):\n        self.execute(self.proc.gids)\n\n    @fewtimes_if_linux()\n    def test_status(self):\n        self.execute(self.proc.status)\n\n    def test_nice(self):\n        self.execute(self.proc.nice)\n\n    def test_nice_set(self):\n        niceness = thisproc.nice()\n        self.execute(lambda: self.proc.nice(niceness))\n\n    @unittest.skipIf(not HAS_IONICE, \"not supported\")\n    def test_ionice(self):\n        self.execute(self.proc.ionice)\n\n    @unittest.skipIf(not HAS_IONICE, \"not supported\")\n    def test_ionice_set(self):\n        if WINDOWS:\n            value = thisproc.ionice()\n            self.execute(lambda: self.proc.ionice(value))\n        else:\n            self.execute(lambda: self.proc.ionice(psutil.IOPRIO_CLASS_NONE))\n            fun = functools.partial(cext.proc_ioprio_set, os.getpid(), -1, 0)\n            self.execute_w_exc(OSError, fun)\n\n    @unittest.skipIf(not HAS_PROC_IO_COUNTERS, \"not supported\")\n    @fewtimes_if_linux()\n    def test_io_counters(self):\n        self.execute(self.proc.io_counters)\n\n    @unittest.skipIf(POSIX, \"worthless on POSIX\")\n    def test_username(self):\n        # always open 1 handle on Windows (only once)\n        psutil.Process().username()\n        self.execute(self.proc.username)\n\n    @fewtimes_if_linux()\n    def test_create_time(self):\n        self.execute(self.proc.create_time)\n\n    @fewtimes_if_linux()\n    @skip_on_access_denied(only_if=OPENBSD)\n    def test_num_threads(self):\n        self.execute(self.proc.num_threads)\n\n    @unittest.skipIf(not WINDOWS, \"WINDOWS only\")\n    def test_num_handles(self):\n        self.execute(self.proc.num_handles)\n\n    @unittest.skipIf(not POSIX, \"POSIX only\")\n    @fewtimes_if_linux()\n    def test_num_fds(self):\n        self.execute(self.proc.num_fds)\n\n    @fewtimes_if_linux()\n    def test_num_ctx_switches(self):\n        self.execute(self.proc.num_ctx_switches)\n\n    @fewtimes_if_linux()\n    @skip_on_access_denied(only_if=OPENBSD)\n    def test_threads(self):\n        self.execute(self.proc.threads)\n\n    @fewtimes_if_linux()\n    def test_cpu_times(self):\n        self.execute(self.proc.cpu_times)\n\n    @fewtimes_if_linux()\n    @unittest.skipIf(not HAS_PROC_CPU_NUM, \"not supported\")\n    def test_cpu_num(self):\n        self.execute(self.proc.cpu_num)\n\n    @fewtimes_if_linux()\n    def test_memory_info(self):\n        self.execute(self.proc.memory_info)\n\n    @fewtimes_if_linux()\n    def test_memory_full_info(self):\n        self.execute(self.proc.memory_full_info)\n\n    @unittest.skipIf(not POSIX, \"POSIX only\")\n    @fewtimes_if_linux()\n    def test_terminal(self):\n        self.execute(self.proc.terminal)\n\n    def test_resume(self):\n        times = FEW_TIMES if POSIX else self.times\n        self.execute(self.proc.resume, times=times)\n\n    @fewtimes_if_linux()\n    def test_cwd(self):\n        self.execute(self.proc.cwd)\n\n    @unittest.skipIf(not HAS_CPU_AFFINITY, \"not supported\")\n    def test_cpu_affinity(self):\n        self.execute(self.proc.cpu_affinity)\n\n    @unittest.skipIf(not HAS_CPU_AFFINITY, \"not supported\")\n    def test_cpu_affinity_set(self):\n        affinity = thisproc.cpu_affinity()\n        self.execute(lambda: self.proc.cpu_affinity(affinity))\n        self.execute_w_exc(\n            ValueError, lambda: self.proc.cpu_affinity([-1]))\n\n    @fewtimes_if_linux()\n    def test_open_files(self):\n        with open(get_testfn(), 'w'):\n            self.execute(self.proc.open_files)\n\n    @unittest.skipIf(not HAS_MEMORY_MAPS, \"not supported\")\n    @fewtimes_if_linux()\n    def test_memory_maps(self):\n        self.execute(self.proc.memory_maps)\n\n    @unittest.skipIf(not LINUX, \"LINUX only\")\n    @unittest.skipIf(not HAS_RLIMIT, \"not supported\")\n    def test_rlimit(self):\n        self.execute(lambda: self.proc.rlimit(psutil.RLIMIT_NOFILE))\n\n    @unittest.skipIf(not LINUX, \"LINUX only\")\n    @unittest.skipIf(not HAS_RLIMIT, \"not supported\")\n    def test_rlimit_set(self):\n        limit = thisproc.rlimit(psutil.RLIMIT_NOFILE)\n        self.execute(lambda: self.proc.rlimit(psutil.RLIMIT_NOFILE, limit))\n        self.execute_w_exc((OSError, ValueError), lambda: self.proc.rlimit(-1))\n\n    @fewtimes_if_linux()\n    # Windows implementation is based on a single system-wide\n    # function (tested later).\n    @unittest.skipIf(WINDOWS, \"worthless on WINDOWS\")\n    def test_connections(self):\n        # TODO: UNIX sockets are temporarily implemented by parsing\n        # 'pfiles' cmd  output; we don't want that part of the code to\n        # be executed.\n        with create_sockets():\n            kind = 'inet' if SUNOS else 'all'\n            self.execute(lambda: self.proc.connections(kind))\n\n    @unittest.skipIf(not HAS_ENVIRON, \"not supported\")\n    def test_environ(self):\n        self.execute(self.proc.environ)\n\n    @unittest.skipIf(not WINDOWS, \"WINDOWS only\")\n    def test_proc_info(self):\n        self.execute(lambda: cext.proc_info(os.getpid()))\n\n\nclass TestTerminatedProcessLeaks(TestProcessObjectLeaks):\n    \"\"\"Repeat the tests above looking for leaks occurring when dealing\n    with terminated processes raising NoSuchProcess exception.\n    The C functions are still invoked but will follow different code\n    paths. We'll check those code paths.\n    \"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        cls.subp = spawn_testproc()\n        cls.proc = psutil.Process(cls.subp.pid)\n        cls.proc.kill()\n        cls.proc.wait()\n\n    @classmethod\n    def tearDownClass(cls):\n        super().tearDownClass()\n        terminate(cls.subp)\n\n    def call(self, fun):\n        try:\n            fun()\n        except psutil.NoSuchProcess:\n            pass\n\n    if WINDOWS:\n\n        def test_kill(self):\n            self.execute(self.proc.kill)\n\n        def test_terminate(self):\n            self.execute(self.proc.terminate)\n\n        def test_suspend(self):\n            self.execute(self.proc.suspend)\n\n        def test_resume(self):\n            self.execute(self.proc.resume)\n\n        def test_wait(self):\n            self.execute(self.proc.wait)\n\n        def test_proc_info(self):\n            # test dual implementation\n            def call():\n                try:\n                    return cext.proc_info(self.proc.pid)\n                except ProcessLookupError:\n                    pass\n\n            self.execute(call)\n\n\n@unittest.skipIf(not WINDOWS, \"WINDOWS only\")\nclass TestProcessDualImplementation(TestMemoryLeak):\n\n    def test_cmdline_peb_true(self):\n        self.execute(lambda: cext.proc_cmdline(os.getpid(), use_peb=True))\n\n    def test_cmdline_peb_false(self):\n        self.execute(lambda: cext.proc_cmdline(os.getpid(), use_peb=False))\n\n\n# ===================================================================\n# system APIs\n# ===================================================================\n\n\nclass TestModuleFunctionsLeaks(TestMemoryLeak):\n    \"\"\"Test leaks of psutil module functions.\"\"\"\n\n    def test_coverage(self):\n        ns = system_namespace()\n        ns.test_class_coverage(self, ns.all)\n\n    # --- cpu\n\n    @fewtimes_if_linux()\n    def test_cpu_count(self):  # logical\n        self.execute(lambda: psutil.cpu_count(logical=True))\n\n    @fewtimes_if_linux()\n    def test_cpu_count_physical(self):\n        self.execute(lambda: psutil.cpu_count(logical=False))\n\n    @fewtimes_if_linux()\n    def test_cpu_times(self):\n        self.execute(psutil.cpu_times)\n\n    @fewtimes_if_linux()\n    def test_per_cpu_times(self):\n        self.execute(lambda: psutil.cpu_times(percpu=True))\n\n    @fewtimes_if_linux()\n    def test_cpu_stats(self):\n        self.execute(psutil.cpu_stats)\n\n    @fewtimes_if_linux()\n    @unittest.skipIf(not HAS_CPU_FREQ, \"not supported\")\n    def test_cpu_freq(self):\n        self.execute(psutil.cpu_freq)\n\n    @unittest.skipIf(not WINDOWS, \"WINDOWS only\")\n    def test_getloadavg(self):\n        psutil.getloadavg()\n        self.execute(psutil.getloadavg)\n\n    # --- mem\n\n    def test_virtual_memory(self):\n        self.execute(psutil.virtual_memory)\n\n    # TODO: remove this skip when this gets fixed\n    @unittest.skipIf(SUNOS, \"worthless on SUNOS (uses a subprocess)\")\n    def test_swap_memory(self):\n        self.execute(psutil.swap_memory)\n\n    def test_pid_exists(self):\n        times = FEW_TIMES if POSIX else self.times\n        self.execute(lambda: psutil.pid_exists(os.getpid()), times=times)\n\n    # --- disk\n\n    def test_disk_usage(self):\n        times = FEW_TIMES if POSIX else self.times\n        self.execute(lambda: psutil.disk_usage('.'), times=times)\n\n    def test_disk_partitions(self):\n        self.execute(psutil.disk_partitions)\n\n    @unittest.skipIf(LINUX and not os.path.exists('/proc/diskstats'),\n                     '/proc/diskstats not available on this Linux version')\n    @fewtimes_if_linux()\n    def test_disk_io_counters(self):\n        self.execute(lambda: psutil.disk_io_counters(nowrap=False))\n\n    # --- proc\n\n    @fewtimes_if_linux()\n    def test_pids(self):\n        self.execute(psutil.pids)\n\n    # --- net\n\n    @fewtimes_if_linux()\n    @unittest.skipIf(not HAS_NET_IO_COUNTERS, 'not supported')\n    def test_net_io_counters(self):\n        self.execute(lambda: psutil.net_io_counters(nowrap=False))\n\n    @fewtimes_if_linux()\n    @unittest.skipIf(MACOS and os.getuid() != 0, \"need root access\")\n    def test_net_connections(self):\n        # always opens and handle on Windows() (once)\n        psutil.net_connections(kind='all')\n        with create_sockets():\n            self.execute(lambda: psutil.net_connections(kind='all'))\n\n    def test_net_if_addrs(self):\n        # Note: verified that on Windows this was a false positive.\n        tolerance = 80 * 1024 if WINDOWS else self.tolerance\n        self.execute(psutil.net_if_addrs, tolerance=tolerance)\n\n    def test_net_if_stats(self):\n        self.execute(psutil.net_if_stats)\n\n    # --- sensors\n\n    @fewtimes_if_linux()\n    @unittest.skipIf(not HAS_SENSORS_BATTERY, \"not supported\")\n    def test_sensors_battery(self):\n        self.execute(psutil.sensors_battery)\n\n    @fewtimes_if_linux()\n    @unittest.skipIf(not HAS_SENSORS_TEMPERATURES, \"not supported\")\n    def test_sensors_temperatures(self):\n        self.execute(psutil.sensors_temperatures)\n\n    @fewtimes_if_linux()\n    @unittest.skipIf(not HAS_SENSORS_FANS, \"not supported\")\n    def test_sensors_fans(self):\n        self.execute(psutil.sensors_fans)\n\n    # --- others\n\n    @fewtimes_if_linux()\n    def test_boot_time(self):\n        self.execute(psutil.boot_time)\n\n    def test_users(self):\n        self.execute(psutil.users)\n\n    if WINDOWS:\n\n        # --- win services\n\n        def test_win_service_iter(self):\n            self.execute(cext.winservice_enumerate)\n\n        def test_win_service_get(self):\n            pass\n\n        def test_win_service_get_config(self):\n            name = next(psutil.win_service_iter()).name()\n            self.execute(lambda: cext.winservice_query_config(name))\n\n        def test_win_service_get_status(self):\n            name = next(psutil.win_service_iter()).name()\n            self.execute(lambda: cext.winservice_query_status(name))\n\n        def test_win_service_get_description(self):\n            name = next(psutil.win_service_iter()).name()\n            self.execute(lambda: cext.winservice_query_descr(name))\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n    run_from_name(__file__)\n"
                    },
                    "test_misc": {
                        "type": "module",
                        "extension": "py",
                        "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"\nMiscellaneous tests.\n\"\"\"\n\nimport ast\nimport collections\nimport errno\nimport json\nimport os\nimport pickle\nimport socket\nimport stat\nimport sys\n\nfrom psutil import LINUX\nfrom psutil import POSIX\nfrom psutil import WINDOWS\nfrom psutil._common import memoize\nfrom psutil._common import memoize_when_activated\nfrom psutil._common import supports_ipv6\nfrom psutil._common import wrap_numbers\nfrom psutil._compat import PY3\nfrom psutil.tests import APPVEYOR\nfrom psutil.tests import CI_TESTING\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_MEMORY_MAPS\nfrom psutil.tests import HAS_NET_IO_COUNTERS\nfrom psutil.tests import HAS_SENSORS_BATTERY\nfrom psutil.tests import HAS_SENSORS_FANS\nfrom psutil.tests import HAS_SENSORS_TEMPERATURES\nfrom psutil.tests import import_module_by_path\nfrom psutil.tests import mock\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import PYTHON_EXE\nfrom psutil.tests import reload_module\nfrom psutil.tests import ROOT_DIR\nfrom psutil.tests import SCRIPTS_DIR\nfrom psutil.tests import sh\nfrom psutil.tests import unittest\nimport psutil\nimport psutil.tests\n\n\nPYTHON_39 = sys.version_info[:2] == (3, 9)\n\n\n# ===================================================================\n# --- Misc / generic tests.\n# ===================================================================\n\n\nclass TestMisc(PsutilTestCase):\n\n    def test_process__repr__(self, func=repr):\n        p = psutil.Process(self.spawn_testproc().pid)\n        r = func(p)\n        self.assertIn(\"psutil.Process\", r)\n        self.assertIn(\"pid=%s\" % p.pid, r)\n        self.assertIn(\"name='%s'\" % str(p.name()),\n                      r.replace(\"name=u'\", \"name='\"))\n        self.assertIn(\"status=\", r)\n        self.assertNotIn(\"exitcode=\", r)\n        p.terminate()\n        p.wait()\n        r = func(p)\n        self.assertIn(\"status='terminated'\", r)\n        self.assertIn(\"exitcode=\", r)\n\n        with mock.patch.object(psutil.Process, \"name\",\n                               side_effect=psutil.ZombieProcess(os.getpid())):\n            p = psutil.Process()\n            r = func(p)\n            self.assertIn(\"pid=%s\" % p.pid, r)\n            self.assertIn(\"status='zombie'\", r)\n            self.assertNotIn(\"name=\", r)\n        with mock.patch.object(psutil.Process, \"name\",\n                               side_effect=psutil.NoSuchProcess(os.getpid())):\n            p = psutil.Process()\n            r = func(p)\n            self.assertIn(\"pid=%s\" % p.pid, r)\n            self.assertIn(\"terminated\", r)\n            self.assertNotIn(\"name=\", r)\n        with mock.patch.object(psutil.Process, \"name\",\n                               side_effect=psutil.AccessDenied(os.getpid())):\n            p = psutil.Process()\n            r = func(p)\n            self.assertIn(\"pid=%s\" % p.pid, r)\n            self.assertNotIn(\"name=\", r)\n\n    def test_process__str__(self):\n        self.test_process__repr__(func=str)\n\n    def test_no_such_process__repr__(self, func=repr):\n        self.assertEqual(\n            repr(psutil.NoSuchProcess(321)),\n            \"psutil.NoSuchProcess process no longer exists (pid=321)\")\n        self.assertEqual(\n            repr(psutil.NoSuchProcess(321, name='foo')),\n            \"psutil.NoSuchProcess process no longer exists (pid=321, \"\n            \"name='foo')\")\n        self.assertEqual(\n            repr(psutil.NoSuchProcess(321, msg='foo')),\n            \"psutil.NoSuchProcess foo\")\n\n    def test_zombie_process__repr__(self, func=repr):\n        self.assertEqual(\n            repr(psutil.ZombieProcess(321)),\n            \"psutil.ZombieProcess process still exists but it's a zombie \"\n            \"(pid=321)\")\n        self.assertEqual(\n            repr(psutil.ZombieProcess(321, name='foo')),\n            \"psutil.ZombieProcess process still exists but it's a zombie \"\n            \"(pid=321, name='foo')\")\n        self.assertEqual(\n            repr(psutil.ZombieProcess(321, name='foo', ppid=1)),\n            \"psutil.ZombieProcess process still exists but it's a zombie \"\n            \"(pid=321, name='foo', ppid=1)\")\n        self.assertEqual(\n            repr(psutil.ZombieProcess(321, msg='foo')),\n            \"psutil.ZombieProcess foo\")\n\n    def test_access_denied__repr__(self, func=repr):\n        self.assertEqual(\n            repr(psutil.AccessDenied(321)),\n            \"psutil.AccessDenied (pid=321)\")\n        self.assertEqual(\n            repr(psutil.AccessDenied(321, name='foo')),\n            \"psutil.AccessDenied (pid=321, name='foo')\")\n        self.assertEqual(\n            repr(psutil.AccessDenied(321, msg='foo')),\n            \"psutil.AccessDenied foo\")\n\n    def test_timeout_expired__repr__(self, func=repr):\n        self.assertEqual(\n            repr(psutil.TimeoutExpired(321)),\n            \"psutil.TimeoutExpired timeout after 321 seconds\")\n        self.assertEqual(\n            repr(psutil.TimeoutExpired(321, pid=111)),\n            \"psutil.TimeoutExpired timeout after 321 seconds (pid=111)\")\n        self.assertEqual(\n            repr(psutil.TimeoutExpired(321, pid=111, name='foo')),\n            \"psutil.TimeoutExpired timeout after 321 seconds \"\n            \"(pid=111, name='foo')\")\n\n    def test_process__eq__(self):\n        p1 = psutil.Process()\n        p2 = psutil.Process()\n        self.assertEqual(p1, p2)\n        p2._ident = (0, 0)\n        self.assertNotEqual(p1, p2)\n        self.assertNotEqual(p1, 'foo')\n\n    def test_process__hash__(self):\n        s = set([psutil.Process(), psutil.Process()])\n        self.assertEqual(len(s), 1)\n\n    def test__all__(self):\n        dir_psutil = dir(psutil)\n        for name in dir_psutil:\n            if name in ('long', 'tests', 'test', 'PermissionError',\n                        'ProcessLookupError'):\n                continue\n            if not name.startswith('_'):\n                try:\n                    __import__(name)\n                except ImportError:\n                    if name not in psutil.__all__:\n                        fun = getattr(psutil, name)\n                        if fun is None:\n                            continue\n                        if (fun.__doc__ is not None and\n                                'deprecated' not in fun.__doc__.lower()):\n                            self.fail('%r not in psutil.__all__' % name)\n\n        # Import 'star' will break if __all__ is inconsistent, see:\n        # https://github.com/giampaolo/psutil/issues/656\n        # Can't do `from psutil import *` as it won't work on python 3\n        # so we simply iterate over __all__.\n        for name in psutil.__all__:\n            self.assertIn(name, dir_psutil)\n\n    def test_version(self):\n        self.assertEqual('.'.join([str(x) for x in psutil.version_info]),\n                         psutil.__version__)\n\n    def test_process_as_dict_no_new_names(self):\n        # See https://github.com/giampaolo/psutil/issues/813\n        p = psutil.Process()\n        p.foo = '1'\n        self.assertNotIn('foo', p.as_dict())\n\n    def test_memoize(self):\n        @memoize\n        def foo(*args, **kwargs):\n            \"foo docstring\"\n            calls.append(None)\n            return (args, kwargs)\n\n        calls = []\n        # no args\n        for x in range(2):\n            ret = foo()\n            expected = ((), {})\n            self.assertEqual(ret, expected)\n            self.assertEqual(len(calls), 1)\n        # with args\n        for x in range(2):\n            ret = foo(1)\n            expected = ((1, ), {})\n            self.assertEqual(ret, expected)\n            self.assertEqual(len(calls), 2)\n        # with args + kwargs\n        for x in range(2):\n            ret = foo(1, bar=2)\n            expected = ((1, ), {'bar': 2})\n            self.assertEqual(ret, expected)\n            self.assertEqual(len(calls), 3)\n        # clear cache\n        foo.cache_clear()\n        ret = foo()\n        expected = ((), {})\n        self.assertEqual(ret, expected)\n        self.assertEqual(len(calls), 4)\n        # docstring\n        self.assertEqual(foo.__doc__, \"foo docstring\")\n\n    def test_memoize_when_activated(self):\n        class Foo:\n\n            @memoize_when_activated\n            def foo(self):\n                calls.append(None)\n\n        f = Foo()\n        calls = []\n        f.foo()\n        f.foo()\n        self.assertEqual(len(calls), 2)\n\n        # activate\n        calls = []\n        f.foo.cache_activate(f)\n        f.foo()\n        f.foo()\n        self.assertEqual(len(calls), 1)\n\n        # deactivate\n        calls = []\n        f.foo.cache_deactivate(f)\n        f.foo()\n        f.foo()\n        self.assertEqual(len(calls), 2)\n\n    def test_parse_environ_block(self):\n        from psutil._common import parse_environ_block\n\n        def k(s):\n            return s.upper() if WINDOWS else s\n\n        self.assertEqual(parse_environ_block(\"a=1\\0\"),\n                         {k(\"a\"): \"1\"})\n        self.assertEqual(parse_environ_block(\"a=1\\0b=2\\0\\0\"),\n                         {k(\"a\"): \"1\", k(\"b\"): \"2\"})\n        self.assertEqual(parse_environ_block(\"a=1\\0b=\\0\\0\"),\n                         {k(\"a\"): \"1\", k(\"b\"): \"\"})\n        # ignore everything after \\0\\0\n        self.assertEqual(parse_environ_block(\"a=1\\0b=2\\0\\0c=3\\0\"),\n                         {k(\"a\"): \"1\", k(\"b\"): \"2\"})\n        # ignore everything that is not an assignment\n        self.assertEqual(parse_environ_block(\"xxx\\0a=1\\0\"), {k(\"a\"): \"1\"})\n        self.assertEqual(parse_environ_block(\"a=1\\0=b=2\\0\"), {k(\"a\"): \"1\"})\n        # do not fail if the block is incomplete\n        self.assertEqual(parse_environ_block(\"a=1\\0b=2\"), {k(\"a\"): \"1\"})\n\n    def test_supports_ipv6(self):\n        self.addCleanup(supports_ipv6.cache_clear)\n        if supports_ipv6():\n            with mock.patch('psutil._common.socket') as s:\n                s.has_ipv6 = False\n                supports_ipv6.cache_clear()\n                assert not supports_ipv6()\n\n            supports_ipv6.cache_clear()\n            with mock.patch('psutil._common.socket.socket',\n                            side_effect=socket.error) as s:\n                assert not supports_ipv6()\n                assert s.called\n\n            supports_ipv6.cache_clear()\n            with mock.patch('psutil._common.socket.socket',\n                            side_effect=socket.gaierror) as s:\n                assert not supports_ipv6()\n                supports_ipv6.cache_clear()\n                assert s.called\n\n            supports_ipv6.cache_clear()\n            with mock.patch('psutil._common.socket.socket.bind',\n                            side_effect=socket.gaierror) as s:\n                assert not supports_ipv6()\n                supports_ipv6.cache_clear()\n                assert s.called\n        else:\n            with self.assertRaises(Exception):\n                sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)\n                try:\n                    sock.bind((\"::1\", 0))\n                finally:\n                    sock.close()\n\n    def test_isfile_strict(self):\n        from psutil._common import isfile_strict\n        this_file = os.path.abspath(__file__)\n        assert isfile_strict(this_file)\n        assert not isfile_strict(os.path.dirname(this_file))\n        with mock.patch('psutil._common.os.stat',\n                        side_effect=OSError(errno.EPERM, \"foo\")):\n            self.assertRaises(OSError, isfile_strict, this_file)\n        with mock.patch('psutil._common.os.stat',\n                        side_effect=OSError(errno.EACCES, \"foo\")):\n            self.assertRaises(OSError, isfile_strict, this_file)\n        with mock.patch('psutil._common.os.stat',\n                        side_effect=OSError(errno.ENOENT, \"foo\")):\n            assert not isfile_strict(this_file)\n        with mock.patch('psutil._common.stat.S_ISREG', return_value=False):\n            assert not isfile_strict(this_file)\n\n    def test_serialization(self):\n        def check(ret):\n            if json is not None:\n                json.loads(json.dumps(ret))\n            a = pickle.dumps(ret)\n            b = pickle.loads(a)\n            self.assertEqual(ret, b)\n\n        check(psutil.Process().as_dict())\n        check(psutil.virtual_memory())\n        check(psutil.swap_memory())\n        check(psutil.cpu_times())\n        check(psutil.cpu_times_percent(interval=0))\n        check(psutil.net_io_counters())\n        if LINUX and not os.path.exists('/proc/diskstats'):\n            pass\n        else:\n            if not APPVEYOR:\n                check(psutil.disk_io_counters())\n        check(psutil.disk_partitions())\n        check(psutil.disk_usage(os.getcwd()))\n        check(psutil.users())\n\n    def test_setup_script(self):\n        setup_py = os.path.join(ROOT_DIR, 'setup.py')\n        if CI_TESTING and not os.path.exists(setup_py):\n            return self.skipTest(\"can't find setup.py\")\n        module = import_module_by_path(setup_py)\n        self.assertRaises(SystemExit, module.setup)\n        self.assertEqual(module.get_version(), psutil.__version__)\n\n    def test_ad_on_process_creation(self):\n        # We are supposed to be able to instantiate Process also in case\n        # of zombie processes or access denied.\n        with mock.patch.object(psutil.Process, 'create_time',\n                               side_effect=psutil.AccessDenied) as meth:\n            psutil.Process()\n            assert meth.called\n        with mock.patch.object(psutil.Process, 'create_time',\n                               side_effect=psutil.ZombieProcess(1)) as meth:\n            psutil.Process()\n            assert meth.called\n        with mock.patch.object(psutil.Process, 'create_time',\n                               side_effect=ValueError) as meth:\n            with self.assertRaises(ValueError):\n                psutil.Process()\n            assert meth.called\n\n    def test_sanity_version_check(self):\n        # see: https://github.com/giampaolo/psutil/issues/564\n        with mock.patch(\n                \"psutil._psplatform.cext.version\", return_value=\"0.0.0\"):\n            with self.assertRaises(ImportError) as cm:\n                reload_module(psutil)\n            self.assertIn(\"version conflict\", str(cm.exception).lower())\n\n\n# ===================================================================\n# --- Tests for wrap_numbers() function.\n# ===================================================================\n\n\nnt = collections.namedtuple('foo', 'a b c')\n\n\nclass TestWrapNumbers(PsutilTestCase):\n\n    def setUp(self):\n        wrap_numbers.cache_clear()\n\n    tearDown = setUp\n\n    def test_first_call(self):\n        input = {'disk1': nt(5, 5, 5)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n\n    def test_input_hasnt_changed(self):\n        input = {'disk1': nt(5, 5, 5)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n\n    def test_increase_but_no_wrap(self):\n        input = {'disk1': nt(5, 5, 5)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n        input = {'disk1': nt(10, 15, 20)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n        input = {'disk1': nt(20, 25, 30)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n        input = {'disk1': nt(20, 25, 30)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n\n    def test_wrap(self):\n        # let's say 100 is the threshold\n        input = {'disk1': nt(100, 100, 100)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n        # first wrap restarts from 10\n        input = {'disk1': nt(100, 100, 10)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'),\n                         {'disk1': nt(100, 100, 110)})\n        # then it remains the same\n        input = {'disk1': nt(100, 100, 10)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'),\n                         {'disk1': nt(100, 100, 110)})\n        # then it goes up\n        input = {'disk1': nt(100, 100, 90)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'),\n                         {'disk1': nt(100, 100, 190)})\n        # then it wraps again\n        input = {'disk1': nt(100, 100, 20)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'),\n                         {'disk1': nt(100, 100, 210)})\n        # and remains the same\n        input = {'disk1': nt(100, 100, 20)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'),\n                         {'disk1': nt(100, 100, 210)})\n        # now wrap another num\n        input = {'disk1': nt(50, 100, 20)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'),\n                         {'disk1': nt(150, 100, 210)})\n        # and again\n        input = {'disk1': nt(40, 100, 20)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'),\n                         {'disk1': nt(190, 100, 210)})\n        # keep it the same\n        input = {'disk1': nt(40, 100, 20)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'),\n                         {'disk1': nt(190, 100, 210)})\n\n    def test_changing_keys(self):\n        # Emulate a case where the second call to disk_io()\n        # (or whatever) provides a new disk, then the new disk\n        # disappears on the third call.\n        input = {'disk1': nt(5, 5, 5)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n        input = {'disk1': nt(5, 5, 5),\n                 'disk2': nt(7, 7, 7)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n        input = {'disk1': nt(8, 8, 8)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n\n    def test_changing_keys_w_wrap(self):\n        input = {'disk1': nt(50, 50, 50),\n                 'disk2': nt(100, 100, 100)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n        # disk 2 wraps\n        input = {'disk1': nt(50, 50, 50),\n                 'disk2': nt(100, 100, 10)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'),\n                         {'disk1': nt(50, 50, 50),\n                          'disk2': nt(100, 100, 110)})\n        # disk 2 disappears\n        input = {'disk1': nt(50, 50, 50)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n\n        # then it appears again; the old wrap is supposed to be\n        # gone.\n        input = {'disk1': nt(50, 50, 50),\n                 'disk2': nt(100, 100, 100)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n        # remains the same\n        input = {'disk1': nt(50, 50, 50),\n                 'disk2': nt(100, 100, 100)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n        # and then wraps again\n        input = {'disk1': nt(50, 50, 50),\n                 'disk2': nt(100, 100, 10)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'),\n                         {'disk1': nt(50, 50, 50),\n                          'disk2': nt(100, 100, 110)})\n\n    def test_real_data(self):\n        d = {'nvme0n1': (300, 508, 640, 1571, 5970, 1987, 2049, 451751, 47048),\n             'nvme0n1p1': (1171, 2, 5600256, 1024, 516, 0, 0, 0, 8),\n             'nvme0n1p2': (54, 54, 2396160, 5165056, 4, 24, 30, 1207, 28),\n             'nvme0n1p3': (2389, 4539, 5154, 150, 4828, 1844, 2019, 398, 348)}\n        self.assertEqual(wrap_numbers(d, 'disk_io'), d)\n        self.assertEqual(wrap_numbers(d, 'disk_io'), d)\n        # decrease this   \u2193\n        d = {'nvme0n1': (100, 508, 640, 1571, 5970, 1987, 2049, 451751, 47048),\n             'nvme0n1p1': (1171, 2, 5600256, 1024, 516, 0, 0, 0, 8),\n             'nvme0n1p2': (54, 54, 2396160, 5165056, 4, 24, 30, 1207, 28),\n             'nvme0n1p3': (2389, 4539, 5154, 150, 4828, 1844, 2019, 398, 348)}\n        out = wrap_numbers(d, 'disk_io')\n        self.assertEqual(out['nvme0n1'][0], 400)\n\n    # --- cache tests\n\n    def test_cache_first_call(self):\n        input = {'disk1': nt(5, 5, 5)}\n        wrap_numbers(input, 'disk_io')\n        cache = wrap_numbers.cache_info()\n        self.assertEqual(cache[0], {'disk_io': input})\n        self.assertEqual(cache[1], {'disk_io': {}})\n        self.assertEqual(cache[2], {'disk_io': {}})\n\n    def test_cache_call_twice(self):\n        input = {'disk1': nt(5, 5, 5)}\n        wrap_numbers(input, 'disk_io')\n        input = {'disk1': nt(10, 10, 10)}\n        wrap_numbers(input, 'disk_io')\n        cache = wrap_numbers.cache_info()\n        self.assertEqual(cache[0], {'disk_io': input})\n        self.assertEqual(\n            cache[1],\n            {'disk_io': {('disk1', 0): 0, ('disk1', 1): 0, ('disk1', 2): 0}})\n        self.assertEqual(cache[2], {'disk_io': {}})\n\n    def test_cache_wrap(self):\n        # let's say 100 is the threshold\n        input = {'disk1': nt(100, 100, 100)}\n        wrap_numbers(input, 'disk_io')\n\n        # first wrap restarts from 10\n        input = {'disk1': nt(100, 100, 10)}\n        wrap_numbers(input, 'disk_io')\n        cache = wrap_numbers.cache_info()\n        self.assertEqual(cache[0], {'disk_io': input})\n        self.assertEqual(\n            cache[1],\n            {'disk_io': {('disk1', 0): 0, ('disk1', 1): 0, ('disk1', 2): 100}})\n        self.assertEqual(cache[2], {'disk_io': {'disk1': set([('disk1', 2)])}})\n\n        def assert_():\n            cache = wrap_numbers.cache_info()\n            self.assertEqual(\n                cache[1],\n                {'disk_io': {('disk1', 0): 0, ('disk1', 1): 0,\n                             ('disk1', 2): 100}})\n            self.assertEqual(cache[2],\n                             {'disk_io': {'disk1': set([('disk1', 2)])}})\n\n        # then it remains the same\n        input = {'disk1': nt(100, 100, 10)}\n        wrap_numbers(input, 'disk_io')\n        cache = wrap_numbers.cache_info()\n        self.assertEqual(cache[0], {'disk_io': input})\n        assert_()\n\n        # then it goes up\n        input = {'disk1': nt(100, 100, 90)}\n        wrap_numbers(input, 'disk_io')\n        cache = wrap_numbers.cache_info()\n        self.assertEqual(cache[0], {'disk_io': input})\n        assert_()\n\n        # then it wraps again\n        input = {'disk1': nt(100, 100, 20)}\n        wrap_numbers(input, 'disk_io')\n        cache = wrap_numbers.cache_info()\n        self.assertEqual(cache[0], {'disk_io': input})\n        self.assertEqual(\n            cache[1],\n            {'disk_io': {('disk1', 0): 0, ('disk1', 1): 0, ('disk1', 2): 190}})\n        self.assertEqual(cache[2], {'disk_io': {'disk1': set([('disk1', 2)])}})\n\n    def test_cache_changing_keys(self):\n        input = {'disk1': nt(5, 5, 5)}\n        wrap_numbers(input, 'disk_io')\n        input = {'disk1': nt(5, 5, 5),\n                 'disk2': nt(7, 7, 7)}\n        wrap_numbers(input, 'disk_io')\n        cache = wrap_numbers.cache_info()\n        self.assertEqual(cache[0], {'disk_io': input})\n        self.assertEqual(\n            cache[1],\n            {'disk_io': {('disk1', 0): 0, ('disk1', 1): 0, ('disk1', 2): 0}})\n        self.assertEqual(cache[2], {'disk_io': {}})\n\n    def test_cache_clear(self):\n        input = {'disk1': nt(5, 5, 5)}\n        wrap_numbers(input, 'disk_io')\n        wrap_numbers(input, 'disk_io')\n        wrap_numbers.cache_clear('disk_io')\n        self.assertEqual(wrap_numbers.cache_info(), ({}, {}, {}))\n        wrap_numbers.cache_clear('disk_io')\n        wrap_numbers.cache_clear('?!?')\n\n    @unittest.skipIf(not HAS_NET_IO_COUNTERS, 'not supported')\n    def test_cache_clear_public_apis(self):\n        if not psutil.disk_io_counters() or not psutil.net_io_counters():\n            return self.skipTest(\"no disks or NICs available\")\n        psutil.disk_io_counters()\n        psutil.net_io_counters()\n        caches = wrap_numbers.cache_info()\n        for cache in caches:\n            self.assertIn('psutil.disk_io_counters', cache)\n            self.assertIn('psutil.net_io_counters', cache)\n\n        psutil.disk_io_counters.cache_clear()\n        caches = wrap_numbers.cache_info()\n        for cache in caches:\n            self.assertIn('psutil.net_io_counters', cache)\n            self.assertNotIn('psutil.disk_io_counters', cache)\n\n        psutil.net_io_counters.cache_clear()\n        caches = wrap_numbers.cache_info()\n        self.assertEqual(caches, ({}, {}, {}))\n\n\n# ===================================================================\n# --- Example script tests\n# ===================================================================\n\n\n@unittest.skipIf(not os.path.exists(SCRIPTS_DIR),\n                 \"can't locate scripts directory\")\nclass TestScripts(PsutilTestCase):\n    \"\"\"Tests for scripts in the \"scripts\" directory.\"\"\"\n\n    @staticmethod\n    def assert_stdout(exe, *args, **kwargs):\n        exe = '%s' % os.path.join(SCRIPTS_DIR, exe)\n        cmd = [PYTHON_EXE, exe]\n        for arg in args:\n            cmd.append(arg)\n        try:\n            out = sh(cmd, **kwargs).strip()\n        except RuntimeError as err:\n            if 'AccessDenied' in str(err):\n                return str(err)\n            else:\n                raise\n        assert out, out\n        return out\n\n    @staticmethod\n    def assert_syntax(exe, args=None):\n        exe = os.path.join(SCRIPTS_DIR, exe)\n        if PY3:\n            f = open(exe, 'rt', encoding='utf8')\n        else:\n            f = open(exe, 'rt')\n        with f:\n            src = f.read()\n        ast.parse(src)\n\n    def test_coverage(self):\n        # make sure all example scripts have a test method defined\n        meths = dir(self)\n        for name in os.listdir(SCRIPTS_DIR):\n            if name.endswith('.py'):\n                if 'test_' + os.path.splitext(name)[0] not in meths:\n                    # self.assert_stdout(name)\n                    self.fail('no test defined for %r script'\n                              % os.path.join(SCRIPTS_DIR, name))\n\n    @unittest.skipIf(not POSIX, \"POSIX only\")\n    def test_executable(self):\n        for name in os.listdir(SCRIPTS_DIR):\n            if name.endswith('.py'):\n                path = os.path.join(SCRIPTS_DIR, name)\n                if not stat.S_IXUSR & os.stat(path)[stat.ST_MODE]:\n                    self.fail('%r is not executable' % path)\n\n    def test_disk_usage(self):\n        self.assert_stdout('disk_usage.py')\n\n    def test_free(self):\n        self.assert_stdout('free.py')\n\n    def test_meminfo(self):\n        self.assert_stdout('meminfo.py')\n\n    def test_procinfo(self):\n        self.assert_stdout('procinfo.py', str(os.getpid()))\n\n    @unittest.skipIf(CI_TESTING and not psutil.users(), \"no users\")\n    def test_who(self):\n        self.assert_stdout('who.py')\n\n    def test_ps(self):\n        self.assert_stdout('ps.py')\n\n    def test_pstree(self):\n        self.assert_stdout('pstree.py')\n\n    def test_netstat(self):\n        self.assert_stdout('netstat.py')\n\n    def test_ifconfig(self):\n        self.assert_stdout('ifconfig.py')\n\n    @unittest.skipIf(not HAS_MEMORY_MAPS, \"not supported\")\n    def test_pmap(self):\n        self.assert_stdout('pmap.py', str(os.getpid()))\n\n    def test_procsmem(self):\n        if 'uss' not in psutil.Process().memory_full_info()._fields:\n            raise self.skipTest(\"not supported\")\n        self.assert_stdout('procsmem.py')\n\n    def test_killall(self):\n        self.assert_syntax('killall.py')\n\n    def test_nettop(self):\n        self.assert_syntax('nettop.py')\n\n    def test_top(self):\n        self.assert_syntax('top.py')\n\n    def test_iotop(self):\n        self.assert_syntax('iotop.py')\n\n    def test_pidof(self):\n        output = self.assert_stdout('pidof.py', psutil.Process().name())\n        self.assertIn(str(os.getpid()), output)\n\n    @unittest.skipIf(not WINDOWS, \"WINDOWS only\")\n    def test_winservices(self):\n        self.assert_stdout('winservices.py')\n\n    def test_cpu_distribution(self):\n        self.assert_syntax('cpu_distribution.py')\n\n    @unittest.skipIf(not HAS_SENSORS_TEMPERATURES, \"not supported\")\n    def test_temperatures(self):\n        if not psutil.sensors_temperatures():\n            self.skipTest(\"no temperatures\")\n        self.assert_stdout('temperatures.py')\n\n    @unittest.skipIf(not HAS_SENSORS_FANS, \"not supported\")\n    def test_fans(self):\n        if not psutil.sensors_fans():\n            self.skipTest(\"no fans\")\n        self.assert_stdout('fans.py')\n\n    @unittest.skipIf(not HAS_SENSORS_BATTERY, \"not supported\")\n    @unittest.skipIf(not HAS_BATTERY, \"no battery\")\n    def test_battery(self):\n        self.assert_stdout('battery.py')\n\n    @unittest.skipIf(not HAS_SENSORS_BATTERY, \"not supported\")\n    @unittest.skipIf(not HAS_BATTERY, \"no battery\")\n    def test_sensors(self):\n        self.assert_stdout('sensors.py')\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n    run_from_name(__file__)\n"
                    },
                    "test_osx": {
                        "type": "module",
                        "extension": "py",
                        "code": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"macOS specific tests.\"\"\"\n\nimport re\nimport time\n\nimport psutil\nfrom psutil import MACOS\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import sh\nfrom psutil.tests import spawn_testproc\nfrom psutil.tests import terminate\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import unittest\n\n\ndef sysctl(cmdline):\n    \"\"\"Expects a sysctl command with an argument and parse the result\n    returning only the value of interest.\n    \"\"\"\n    out = sh(cmdline)\n    result = out.split()[1]\n    try:\n        return int(result)\n    except ValueError:\n        return result\n\n\ndef vm_stat(field):\n    \"\"\"Wrapper around 'vm_stat' cmdline utility.\"\"\"\n    from psutil._psutil_posix import getpagesize\n\n    out = sh('vm_stat')\n    for line in out.split('\\n'):\n        if field in line:\n            break\n    else:\n        raise ValueError(\"line not found\")\n    return int(re.search(r'\\d+', line).group(0)) * getpagesize()\n\n\n# http://code.activestate.com/recipes/578019/\ndef human2bytes(s):\n    SYMBOLS = {\n        'customary': ('B', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'),\n    }\n    init = s\n    num = \"\"\n    while s and s[0:1].isdigit() or s[0:1] == '.':\n        num += s[0]\n        s = s[1:]\n    num = float(num)\n    letter = s.strip()\n    for name, sset in SYMBOLS.items():\n        if letter in sset:\n            break\n    else:\n        if letter == 'k':\n            sset = SYMBOLS['customary']\n            letter = letter.upper()\n        else:\n            raise ValueError(\"can't interpret %r\" % init)\n    prefix = {sset[0]: 1}\n    for i, s in enumerate(sset[1:]):\n        prefix[s] = 1 << (i + 1) * 10\n    return int(num * prefix[letter])\n\n\n@unittest.skipIf(not MACOS, \"MACOS only\")\nclass TestProcess(PsutilTestCase):\n\n    @classmethod\n    def setUpClass(cls):\n        cls.pid = spawn_testproc().pid\n\n    @classmethod\n    def tearDownClass(cls):\n        terminate(cls.pid)\n\n    def test_process_create_time(self):\n        output = sh(\"ps -o lstart -p %s\" % self.pid)\n        start_ps = output.replace('STARTED', '').strip()\n        hhmmss = start_ps.split(' ')[-2]\n        year = start_ps.split(' ')[-1]\n        start_psutil = psutil.Process(self.pid).create_time()\n        self.assertEqual(\n            hhmmss,\n            time.strftime(\"%H:%M:%S\", time.localtime(start_psutil)))\n        self.assertEqual(\n            year,\n            time.strftime(\"%Y\", time.localtime(start_psutil)))\n\n\n@unittest.skipIf(not MACOS, \"MACOS only\")\nclass TestSystemAPIs(PsutilTestCase):\n\n    # --- disk\n\n    @retry_on_failure()\n    def test_disks(self):\n        # test psutil.disk_usage() and psutil.disk_partitions()\n        # against \"df -a\"\n        def df(path):\n            out = sh('df -k \"%s\"' % path).strip()\n            lines = out.split('\\n')\n            lines.pop(0)\n            line = lines.pop(0)\n            dev, total, used, free = line.split()[:4]\n            if dev == 'none':\n                dev = ''\n            total = int(total) * 1024\n            used = int(used) * 1024\n            free = int(free) * 1024\n            return dev, total, used, free\n\n        for part in psutil.disk_partitions(all=False):\n            usage = psutil.disk_usage(part.mountpoint)\n            dev, total, used, free = df(part.mountpoint)\n            self.assertEqual(part.device, dev)\n            self.assertEqual(usage.total, total)\n            self.assertAlmostEqual(usage.free, free,\n                                   delta=TOLERANCE_DISK_USAGE)\n            self.assertAlmostEqual(usage.used, used,\n                                   delta=TOLERANCE_DISK_USAGE)\n\n    # --- cpu\n\n    def test_cpu_count_logical(self):\n        num = sysctl(\"sysctl hw.logicalcpu\")\n        self.assertEqual(num, psutil.cpu_count(logical=True))\n\n    def test_cpu_count_physical(self):\n        num = sysctl(\"sysctl hw.physicalcpu\")\n        self.assertEqual(num, psutil.cpu_count(logical=False))\n\n    def test_cpu_freq(self):\n        freq = psutil.cpu_freq()\n        self.assertEqual(\n            freq.current * 1000 * 1000, sysctl(\"sysctl hw.cpufrequency\"))\n        self.assertEqual(\n            freq.min * 1000 * 1000, sysctl(\"sysctl hw.cpufrequency_min\"))\n        self.assertEqual(\n            freq.max * 1000 * 1000, sysctl(\"sysctl hw.cpufrequency_max\"))\n\n    # --- virtual mem\n\n    def test_vmem_total(self):\n        sysctl_hwphymem = sysctl('sysctl hw.memsize')\n        self.assertEqual(sysctl_hwphymem, psutil.virtual_memory().total)\n\n    @retry_on_failure()\n    def test_vmem_free(self):\n        vmstat_val = vm_stat(\"free\")\n        psutil_val = psutil.virtual_memory().free\n        self.assertAlmostEqual(psutil_val, vmstat_val, delta=TOLERANCE_SYS_MEM)\n\n    @retry_on_failure()\n    def test_vmem_active(self):\n        vmstat_val = vm_stat(\"active\")\n        psutil_val = psutil.virtual_memory().active\n        self.assertAlmostEqual(psutil_val, vmstat_val, delta=TOLERANCE_SYS_MEM)\n\n    @retry_on_failure()\n    def test_vmem_inactive(self):\n        vmstat_val = vm_stat(\"inactive\")\n        psutil_val = psutil.virtual_memory().inactive\n        self.assertAlmostEqual(psutil_val, vmstat_val, delta=TOLERANCE_SYS_MEM)\n\n    @retry_on_failure()\n    def test_vmem_wired(self):\n        vmstat_val = vm_stat(\"wired\")\n        psutil_val = psutil.virtual_memory().wired\n        self.assertAlmostEqual(psutil_val, vmstat_val, delta=TOLERANCE_SYS_MEM)\n\n    # --- swap mem\n\n    @retry_on_failure()\n    def test_swapmem_sin(self):\n        vmstat_val = vm_stat(\"Pageins\")\n        psutil_val = psutil.swap_memory().sin\n        self.assertEqual(psutil_val, vmstat_val)\n\n    @retry_on_failure()\n    def test_swapmem_sout(self):\n        vmstat_val = vm_stat(\"Pageout\")\n        psutil_val = psutil.swap_memory().sout\n        self.assertEqual(psutil_val, vmstat_val)\n\n    # Not very reliable.\n    # def test_swapmem_total(self):\n    #     out = sh('sysctl vm.swapusage')\n    #     out = out.replace('vm.swapusage: ', '')\n    #     total, used, free = re.findall('\\d+.\\d+\\w', out)\n    #     psutil_smem = psutil.swap_memory()\n    #     self.assertEqual(psutil_smem.total, human2bytes(total))\n    #     self.assertEqual(psutil_smem.used, human2bytes(used))\n    #     self.assertEqual(psutil_smem.free, human2bytes(free))\n\n    # --- network\n\n    def test_net_if_stats(self):\n        for name, stats in psutil.net_if_stats().items():\n            try:\n                out = sh(\"ifconfig %s\" % name)\n            except RuntimeError:\n                pass\n            else:\n                self.assertEqual(stats.isup, 'RUNNING' in out, msg=out)\n                self.assertEqual(stats.mtu,\n                                 int(re.findall(r'mtu (\\d+)', out)[0]))\n\n    # --- sensors_battery\n\n    @unittest.skipIf(not HAS_BATTERY, \"no battery\")\n    def test_sensors_battery(self):\n        out = sh(\"pmset -g batt\")\n        percent = re.search(r\"(\\d+)%\", out).group(1)\n        drawing_from = re.search(\"Now drawing from '([^']+)'\", out).group(1)\n        power_plugged = drawing_from == \"AC Power\"\n        psutil_result = psutil.sensors_battery()\n        self.assertEqual(psutil_result.power_plugged, power_plugged)\n        self.assertEqual(psutil_result.percent, int(percent))\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n    run_from_name(__file__)\n"
                    },
                    "test_posix": {
                        "type": "module",
                        "extension": "py",
                        "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"POSIX specific tests.\"\"\"\n\nimport datetime\nimport errno\nimport os\nimport re\nimport subprocess\nimport time\n\nimport psutil\nfrom psutil import AIX\nfrom psutil import BSD\nfrom psutil import LINUX\nfrom psutil import MACOS\nfrom psutil import OPENBSD\nfrom psutil import POSIX\nfrom psutil import SUNOS\nfrom psutil.tests import CI_TESTING\nfrom psutil.tests import spawn_testproc\nfrom psutil.tests import HAS_NET_IO_COUNTERS\nfrom psutil.tests import mock\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import PYTHON_EXE\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_access_denied\nfrom psutil.tests import terminate\nfrom psutil.tests import unittest\nfrom psutil.tests import which\n\nif POSIX:\n    import mmap\n    import resource\n\n    from psutil._psutil_posix import getpagesize\n\n\ndef ps(fmt, pid=None):\n    \"\"\"\n    Wrapper for calling the ps command with a little bit of cross-platform\n    support for a narrow range of features.\n    \"\"\"\n\n    cmd = ['ps']\n\n    if LINUX:\n        cmd.append('--no-headers')\n\n    if pid is not None:\n        cmd.extend(['-p', str(pid)])\n    else:\n        if SUNOS or AIX:\n            cmd.append('-A')\n        else:\n            cmd.append('ax')\n\n    if SUNOS:\n        fmt_map = set(('command', 'comm', 'start', 'stime'))\n        fmt = fmt_map.get(fmt, fmt)\n\n    cmd.extend(['-o', fmt])\n\n    output = sh(cmd)\n\n    if LINUX:\n        output = output.splitlines()\n    else:\n        output = output.splitlines()[1:]\n\n    all_output = []\n    for line in output:\n        line = line.strip()\n\n        try:\n            line = int(line)\n        except ValueError:\n            pass\n\n        all_output.append(line)\n\n    if pid is None:\n        return all_output\n    else:\n        return all_output[0]\n\n# ps \"-o\" field names differ wildly between platforms.\n# \"comm\" means \"only executable name\" but is not available on BSD platforms.\n# \"args\" means \"command with all its arguments\", and is also not available\n# on BSD platforms.\n# \"command\" is like \"args\" on most platforms, but like \"comm\" on AIX,\n# and not available on SUNOS.\n# so for the executable name we can use \"comm\" on Solaris and split \"command\"\n# on other platforms.\n# to get the cmdline (with args) we have to use \"args\" on AIX and\n# Solaris, and can use \"command\" on all others.\n\n\ndef ps_name(pid):\n    field = \"command\"\n    if SUNOS:\n        field = \"comm\"\n    return ps(field, pid).split()[0]\n\n\ndef ps_args(pid):\n    field = \"command\"\n    if AIX or SUNOS:\n        field = \"args\"\n    return ps(field, pid)\n\n\ndef ps_rss(pid):\n    field = \"rss\"\n    if AIX:\n        field = \"rssize\"\n    return ps(field, pid)\n\n\ndef ps_vsz(pid):\n    field = \"vsz\"\n    if AIX:\n        field = \"vsize\"\n    return ps(field, pid)\n\n\n@unittest.skipIf(not POSIX, \"POSIX only\")\nclass TestProcess(PsutilTestCase):\n    \"\"\"Compare psutil results against 'ps' command line utility (mainly).\"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        cls.pid = spawn_testproc([PYTHON_EXE, \"-E\", \"-O\"],\n                                 stdin=subprocess.PIPE).pid\n\n    @classmethod\n    def tearDownClass(cls):\n        terminate(cls.pid)\n\n    def test_ppid(self):\n        ppid_ps = ps('ppid', self.pid)\n        ppid_psutil = psutil.Process(self.pid).ppid()\n        self.assertEqual(ppid_ps, ppid_psutil)\n\n    def test_uid(self):\n        uid_ps = ps('uid', self.pid)\n        uid_psutil = psutil.Process(self.pid).uids().real\n        self.assertEqual(uid_ps, uid_psutil)\n\n    def test_gid(self):\n        gid_ps = ps('rgid', self.pid)\n        gid_psutil = psutil.Process(self.pid).gids().real\n        self.assertEqual(gid_ps, gid_psutil)\n\n    def test_username(self):\n        username_ps = ps('user', self.pid)\n        username_psutil = psutil.Process(self.pid).username()\n        self.assertEqual(username_ps, username_psutil)\n\n    def test_username_no_resolution(self):\n        # Emulate a case where the system can't resolve the uid to\n        # a username in which case psutil is supposed to return\n        # the stringified uid.\n        p = psutil.Process()\n        with mock.patch(\"psutil.pwd.getpwuid\", side_effect=KeyError) as fun:\n            self.assertEqual(p.username(), str(p.uids().real))\n            assert fun.called\n\n    @skip_on_access_denied()\n    @retry_on_failure()\n    def test_rss_memory(self):\n        # give python interpreter some time to properly initialize\n        # so that the results are the same\n        time.sleep(0.1)\n        rss_ps = ps_rss(self.pid)\n        rss_psutil = psutil.Process(self.pid).memory_info()[0] / 1024\n        self.assertEqual(rss_ps, rss_psutil)\n\n    @skip_on_access_denied()\n    @retry_on_failure()\n    def test_vsz_memory(self):\n        # give python interpreter some time to properly initialize\n        # so that the results are the same\n        time.sleep(0.1)\n        vsz_ps = ps_vsz(self.pid)\n        vsz_psutil = psutil.Process(self.pid).memory_info()[1] / 1024\n        self.assertEqual(vsz_ps, vsz_psutil)\n\n    def test_name(self):\n        name_ps = ps_name(self.pid)\n        # remove path if there is any, from the command\n        name_ps = os.path.basename(name_ps).lower()\n        name_psutil = psutil.Process(self.pid).name().lower()\n        # ...because of how we calculate PYTHON_EXE; on MACOS this may\n        # be \"pythonX.Y\".\n        name_ps = re.sub(r\"\\d.\\d\", \"\", name_ps)\n        name_psutil = re.sub(r\"\\d.\\d\", \"\", name_psutil)\n        # ...may also be \"python.X\"\n        name_ps = re.sub(r\"\\d\", \"\", name_ps)\n        name_psutil = re.sub(r\"\\d\", \"\", name_psutil)\n        self.assertEqual(name_ps, name_psutil)\n\n    def test_name_long(self):\n        # On UNIX the kernel truncates the name to the first 15\n        # characters. In such a case psutil tries to determine the\n        # full name from the cmdline.\n        name = \"long-program-name\"\n        cmdline = [\"long-program-name-extended\", \"foo\", \"bar\"]\n        with mock.patch(\"psutil._psplatform.Process.name\",\n                        return_value=name):\n            with mock.patch(\"psutil._psplatform.Process.cmdline\",\n                            return_value=cmdline):\n                p = psutil.Process()\n                self.assertEqual(p.name(), \"long-program-name-extended\")\n\n    def test_name_long_cmdline_ad_exc(self):\n        # Same as above but emulates a case where cmdline() raises\n        # AccessDenied in which case psutil is supposed to return\n        # the truncated name instead of crashing.\n        name = \"long-program-name\"\n        with mock.patch(\"psutil._psplatform.Process.name\",\n                        return_value=name):\n            with mock.patch(\"psutil._psplatform.Process.cmdline\",\n                            side_effect=psutil.AccessDenied(0, \"\")):\n                p = psutil.Process()\n                self.assertEqual(p.name(), \"long-program-name\")\n\n    def test_name_long_cmdline_nsp_exc(self):\n        # Same as above but emulates a case where cmdline() raises NSP\n        # which is supposed to propagate.\n        name = \"long-program-name\"\n        with mock.patch(\"psutil._psplatform.Process.name\",\n                        return_value=name):\n            with mock.patch(\"psutil._psplatform.Process.cmdline\",\n                            side_effect=psutil.NoSuchProcess(0, \"\")):\n                p = psutil.Process()\n                self.assertRaises(psutil.NoSuchProcess, p.name)\n\n    @unittest.skipIf(MACOS or BSD, 'ps -o start not available')\n    def test_create_time(self):\n        time_ps = ps('start', self.pid)\n        time_psutil = psutil.Process(self.pid).create_time()\n        time_psutil_tstamp = datetime.datetime.fromtimestamp(\n            time_psutil).strftime(\"%H:%M:%S\")\n        # sometimes ps shows the time rounded up instead of down, so we check\n        # for both possible values\n        round_time_psutil = round(time_psutil)\n        round_time_psutil_tstamp = datetime.datetime.fromtimestamp(\n            round_time_psutil).strftime(\"%H:%M:%S\")\n        self.assertIn(time_ps, [time_psutil_tstamp, round_time_psutil_tstamp])\n\n    def test_exe(self):\n        ps_pathname = ps_name(self.pid)\n        psutil_pathname = psutil.Process(self.pid).exe()\n        try:\n            self.assertEqual(ps_pathname, psutil_pathname)\n        except AssertionError:\n            # certain platforms such as BSD are more accurate returning:\n            # \"/usr/local/bin/python2.7\"\n            # ...instead of:\n            # \"/usr/local/bin/python\"\n            # We do not want to consider this difference in accuracy\n            # an error.\n            adjusted_ps_pathname = ps_pathname[:len(ps_pathname)]\n            self.assertEqual(ps_pathname, adjusted_ps_pathname)\n\n    def test_cmdline(self):\n        ps_cmdline = ps_args(self.pid)\n        psutil_cmdline = \" \".join(psutil.Process(self.pid).cmdline())\n        self.assertEqual(ps_cmdline, psutil_cmdline)\n\n    # On SUNOS \"ps\" reads niceness /proc/pid/psinfo which returns an\n    # incorrect value (20); the real deal is getpriority(2) which\n    # returns 0; psutil relies on it, see:\n    # https://github.com/giampaolo/psutil/issues/1082\n    # AIX has the same issue\n    @unittest.skipIf(SUNOS, \"not reliable on SUNOS\")\n    @unittest.skipIf(AIX, \"not reliable on AIX\")\n    def test_nice(self):\n        ps_nice = ps('nice', self.pid)\n        psutil_nice = psutil.Process().nice()\n        self.assertEqual(ps_nice, psutil_nice)\n\n\n@unittest.skipIf(not POSIX, \"POSIX only\")\nclass TestSystemAPIs(PsutilTestCase):\n    \"\"\"Test some system APIs.\"\"\"\n\n    @retry_on_failure()\n    def test_pids(self):\n        # Note: this test might fail if the OS is starting/killing\n        # other processes in the meantime\n        pids_ps = sorted(ps(\"pid\"))\n        pids_psutil = psutil.pids()\n\n        # on MACOS and OPENBSD ps doesn't show pid 0\n        if MACOS or OPENBSD and 0 not in pids_ps:\n            pids_ps.insert(0, 0)\n\n        # There will often be one more process in pids_ps for ps itself\n        if len(pids_ps) - len(pids_psutil) > 1:\n            difference = [x for x in pids_psutil if x not in pids_ps] + \\\n                         [x for x in pids_ps if x not in pids_psutil]\n            self.fail(\"difference: \" + str(difference))\n\n    # for some reason ifconfig -a does not report all interfaces\n    # returned by psutil\n    @unittest.skipIf(SUNOS, \"unreliable on SUNOS\")\n    @unittest.skipIf(not which('ifconfig'), \"no ifconfig cmd\")\n    @unittest.skipIf(not HAS_NET_IO_COUNTERS, \"not supported\")\n    def test_nic_names(self):\n        output = sh(\"ifconfig -a\")\n        for nic in psutil.net_io_counters(pernic=True).keys():\n            for line in output.split():\n                if line.startswith(nic):\n                    break\n            else:\n                self.fail(\n                    \"couldn't find %s nic in 'ifconfig -a' output\\n%s\" % (\n                        nic, output))\n\n    @unittest.skipIf(CI_TESTING and not psutil.users(), \"unreliable on CI\")\n    @retry_on_failure()\n    def test_users(self):\n        out = sh(\"who\")\n        if not out.strip():\n            raise self.skipTest(\"no users on this system\")\n        lines = out.split('\\n')\n        users = [x.split()[0] for x in lines]\n        terminals = [x.split()[1] for x in lines]\n        self.assertEqual(len(users), len(psutil.users()))\n        for u in psutil.users():\n            self.assertIn(u.name, users)\n            self.assertIn(u.terminal, terminals)\n\n    def test_pid_exists_let_raise(self):\n        # According to \"man 2 kill\" possible error values for kill\n        # are (EINVAL, EPERM, ESRCH). Test that any other errno\n        # results in an exception.\n        with mock.patch(\"psutil._psposix.os.kill\",\n                        side_effect=OSError(errno.EBADF, \"\")) as m:\n            self.assertRaises(OSError, psutil._psposix.pid_exists, os.getpid())\n            assert m.called\n\n    def test_os_waitpid_let_raise(self):\n        # os.waitpid() is supposed to catch EINTR and ECHILD only.\n        # Test that any other errno results in an exception.\n        with mock.patch(\"psutil._psposix.os.waitpid\",\n                        side_effect=OSError(errno.EBADF, \"\")) as m:\n            self.assertRaises(OSError, psutil._psposix.wait_pid, os.getpid())\n            assert m.called\n\n    def test_os_waitpid_eintr(self):\n        # os.waitpid() is supposed to \"retry\" on EINTR.\n        with mock.patch(\"psutil._psposix.os.waitpid\",\n                        side_effect=OSError(errno.EINTR, \"\")) as m:\n            self.assertRaises(\n                psutil._psposix.TimeoutExpired,\n                psutil._psposix.wait_pid, os.getpid(), timeout=0.01)\n            assert m.called\n\n    def test_os_waitpid_bad_ret_status(self):\n        # Simulate os.waitpid() returning a bad status.\n        with mock.patch(\"psutil._psposix.os.waitpid\",\n                        return_value=(1, -1)) as m:\n            self.assertRaises(ValueError,\n                              psutil._psposix.wait_pid, os.getpid())\n            assert m.called\n\n    # AIX can return '-' in df output instead of numbers, e.g. for /proc\n    @unittest.skipIf(AIX, \"unreliable on AIX\")\n    @retry_on_failure()\n    def test_disk_usage(self):\n        def df(device):\n            out = sh(\"df -k %s\" % device).strip()\n            line = out.split('\\n')[1]\n            fields = line.split()\n            total = int(fields[1]) * 1024\n            used = int(fields[2]) * 1024\n            free = int(fields[3]) * 1024\n            percent = float(fields[4].replace('%', ''))\n            return (total, used, free, percent)\n\n        tolerance = 4 * 1024 * 1024  # 4MB\n        for part in psutil.disk_partitions(all=False):\n            usage = psutil.disk_usage(part.mountpoint)\n            try:\n                total, used, free, percent = df(part.device)\n            except RuntimeError as err:\n                # see:\n                # https://travis-ci.org/giampaolo/psutil/jobs/138338464\n                # https://travis-ci.org/giampaolo/psutil/jobs/138343361\n                err = str(err).lower()\n                if \"no such file or directory\" in err or \\\n                        \"raw devices not supported\" in err or \\\n                        \"permission denied\" in err:\n                    continue\n                else:\n                    raise\n            else:\n                self.assertAlmostEqual(usage.total, total, delta=tolerance)\n                self.assertAlmostEqual(usage.used, used, delta=tolerance)\n                self.assertAlmostEqual(usage.free, free, delta=tolerance)\n                self.assertAlmostEqual(usage.percent, percent, delta=1)\n\n\n@unittest.skipIf(not POSIX, \"POSIX only\")\nclass TestMisc(PsutilTestCase):\n\n    def test_getpagesize(self):\n        pagesize = getpagesize()\n        self.assertGreater(pagesize, 0)\n        self.assertEqual(pagesize, resource.getpagesize())\n        self.assertEqual(pagesize, mmap.PAGESIZE)\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n    run_from_name(__file__)\n"
                    },
                    "test_process": {
                        "type": "module",
                        "extension": "py",
                        "code": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Tests for psutil.Process class.\"\"\"\n\nimport collections\nimport errno\nimport getpass\nimport itertools\nimport os\nimport signal\nimport socket\nimport stat\nimport subprocess\nimport sys\nimport textwrap\nimport time\nimport types\n\nimport psutil\n\nfrom psutil import AIX\nfrom psutil import BSD\nfrom psutil import LINUX\nfrom psutil import MACOS\nfrom psutil import NETBSD\nfrom psutil import OPENBSD\nfrom psutil import OSX\nfrom psutil import POSIX\nfrom psutil import SUNOS\nfrom psutil import WINDOWS\nfrom psutil._common import open_text\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import long\nfrom psutil._compat import PY3\nfrom psutil._compat import super\nfrom psutil.tests import APPVEYOR\nfrom psutil.tests import call_until\nfrom psutil.tests import CI_TESTING\nfrom psutil.tests import copyload_shared_lib\nfrom psutil.tests import create_exe\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_CPU_AFFINITY\nfrom psutil.tests import HAS_ENVIRON\nfrom psutil.tests import HAS_IONICE\nfrom psutil.tests import HAS_MEMORY_MAPS\nfrom psutil.tests import HAS_PROC_CPU_NUM\nfrom psutil.tests import HAS_PROC_IO_COUNTERS\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import HAS_THREADS\nfrom psutil.tests import mock\nfrom psutil.tests import process_namespace\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import PYPY\nfrom psutil.tests import PYTHON_EXE\nfrom psutil.tests import reap_children\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_access_denied\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import unittest\nfrom psutil.tests import wait_for_pid\n\n\n# ===================================================================\n# --- psutil.Process class tests\n# ===================================================================\n\n\nclass TestProcess(PsutilTestCase):\n    \"\"\"Tests for psutil.Process class.\"\"\"\n\n    def spawn_psproc(self, *args, **kwargs):\n        sproc = self.spawn_testproc(*args, **kwargs)\n        return psutil.Process(sproc.pid)\n\n    # ---\n\n    def test_pid(self):\n        p = psutil.Process()\n        self.assertEqual(p.pid, os.getpid())\n        with self.assertRaises(AttributeError):\n            p.pid = 33\n\n    def test_kill(self):\n        p = self.spawn_psproc()\n        p.kill()\n        code = p.wait()\n        if WINDOWS:\n            self.assertEqual(code, signal.SIGTERM)\n        else:\n            self.assertEqual(code, -signal.SIGKILL)\n        self.assertProcessGone(p)\n\n    def test_terminate(self):\n        p = self.spawn_psproc()\n        p.terminate()\n        code = p.wait()\n        if WINDOWS:\n            self.assertEqual(code, signal.SIGTERM)\n        else:\n            self.assertEqual(code, -signal.SIGTERM)\n        self.assertProcessGone(p)\n\n    def test_send_signal(self):\n        sig = signal.SIGKILL if POSIX else signal.SIGTERM\n        p = self.spawn_psproc()\n        p.send_signal(sig)\n        code = p.wait()\n        if WINDOWS:\n            self.assertEqual(code, sig)\n        else:\n            self.assertEqual(code, -sig)\n        self.assertProcessGone(p)\n\n    @unittest.skipIf(not POSIX, \"not POSIX\")\n    def test_send_signal_mocked(self):\n        sig = signal.SIGTERM\n        p = self.spawn_psproc()\n        with mock.patch('psutil.os.kill',\n                        side_effect=OSError(errno.ESRCH, \"\")):\n            self.assertRaises(psutil.NoSuchProcess, p.send_signal, sig)\n\n        p = self.spawn_psproc()\n        with mock.patch('psutil.os.kill',\n                        side_effect=OSError(errno.EPERM, \"\")):\n            self.assertRaises(psutil.AccessDenied, p.send_signal, sig)\n\n    def test_wait_exited(self):\n        # Test waitpid() + WIFEXITED -> WEXITSTATUS.\n        # normal return, same as exit(0)\n        cmd = [PYTHON_EXE, \"-c\", \"pass\"]\n        p = self.spawn_psproc(cmd)\n        code = p.wait()\n        self.assertEqual(code, 0)\n        self.assertProcessGone(p)\n        # exit(1), implicit in case of error\n        cmd = [PYTHON_EXE, \"-c\", \"1 / 0\"]\n        p = self.spawn_psproc(cmd, stderr=subprocess.PIPE)\n        code = p.wait()\n        self.assertEqual(code, 1)\n        self.assertProcessGone(p)\n        # via sys.exit()\n        cmd = [PYTHON_EXE, \"-c\", \"import sys; sys.exit(5);\"]\n        p = self.spawn_psproc(cmd)\n        code = p.wait()\n        self.assertEqual(code, 5)\n        self.assertProcessGone(p)\n        # via os._exit()\n        cmd = [PYTHON_EXE, \"-c\", \"import os; os._exit(5);\"]\n        p = self.spawn_psproc(cmd)\n        code = p.wait()\n        self.assertEqual(code, 5)\n        self.assertProcessGone(p)\n\n    def test_wait_stopped(self):\n        p = self.spawn_psproc()\n        if POSIX:\n            # Test waitpid() + WIFSTOPPED and WIFCONTINUED.\n            # Note: if a process is stopped it ignores SIGTERM.\n            p.send_signal(signal.SIGSTOP)\n            self.assertRaises(psutil.TimeoutExpired, p.wait, timeout=0.001)\n            p.send_signal(signal.SIGCONT)\n            self.assertRaises(psutil.TimeoutExpired, p.wait, timeout=0.001)\n            p.send_signal(signal.SIGTERM)\n            self.assertEqual(p.wait(), -signal.SIGTERM)\n            self.assertEqual(p.wait(), -signal.SIGTERM)\n        else:\n            p.suspend()\n            self.assertRaises(psutil.TimeoutExpired, p.wait, timeout=0.001)\n            p.resume()\n            self.assertRaises(psutil.TimeoutExpired, p.wait, timeout=0.001)\n            p.terminate()\n            self.assertEqual(p.wait(), signal.SIGTERM)\n            self.assertEqual(p.wait(), signal.SIGTERM)\n\n    def test_wait_non_children(self):\n        # Test wait() against a process which is not our direct\n        # child.\n        child, grandchild = self.spawn_children_pair()\n        self.assertRaises(psutil.TimeoutExpired, child.wait, 0.01)\n        self.assertRaises(psutil.TimeoutExpired, grandchild.wait, 0.01)\n        # We also terminate the direct child otherwise the\n        # grandchild will hang until the parent is gone.\n        child.terminate()\n        grandchild.terminate()\n        child_ret = child.wait()\n        grandchild_ret = grandchild.wait()\n        if POSIX:\n            self.assertEqual(child_ret, -signal.SIGTERM)\n            # For processes which are not our children we're supposed\n            # to get None.\n            self.assertEqual(grandchild_ret, None)\n        else:\n            self.assertEqual(child_ret, signal.SIGTERM)\n            self.assertEqual(child_ret, signal.SIGTERM)\n\n    def test_wait_timeout(self):\n        p = self.spawn_psproc()\n        p.name()\n        self.assertRaises(psutil.TimeoutExpired, p.wait, 0.01)\n        self.assertRaises(psutil.TimeoutExpired, p.wait, 0)\n        self.assertRaises(ValueError, p.wait, -1)\n\n    def test_wait_timeout_nonblocking(self):\n        p = self.spawn_psproc()\n        self.assertRaises(psutil.TimeoutExpired, p.wait, 0)\n        p.kill()\n        stop_at = time.time() + GLOBAL_TIMEOUT\n        while time.time() < stop_at:\n            try:\n                code = p.wait(0)\n                break\n            except psutil.TimeoutExpired:\n                pass\n        else:\n            raise self.fail('timeout')\n        if POSIX:\n            self.assertEqual(code, -signal.SIGKILL)\n        else:\n            self.assertEqual(code, signal.SIGTERM)\n        self.assertProcessGone(p)\n\n    def test_cpu_percent(self):\n        p = psutil.Process()\n        p.cpu_percent(interval=0.001)\n        p.cpu_percent(interval=0.001)\n        for x in range(100):\n            percent = p.cpu_percent(interval=None)\n            self.assertIsInstance(percent, float)\n            self.assertGreaterEqual(percent, 0.0)\n        with self.assertRaises(ValueError):\n            p.cpu_percent(interval=-1)\n\n    def test_cpu_percent_numcpus_none(self):\n        # See: https://github.com/giampaolo/psutil/issues/1087\n        with mock.patch('psutil.cpu_count', return_value=None) as m:\n            psutil.Process().cpu_percent()\n            assert m.called\n\n    def test_cpu_times(self):\n        times = psutil.Process().cpu_times()\n        assert (times.user > 0.0) or (times.system > 0.0), times\n        assert (times.children_user >= 0.0), times\n        assert (times.children_system >= 0.0), times\n        if LINUX:\n            assert times.iowait >= 0.0, times\n        # make sure returned values can be pretty printed with strftime\n        for name in times._fields:\n            time.strftime(\"%H:%M:%S\", time.localtime(getattr(times, name)))\n\n    def test_cpu_times_2(self):\n        user_time, kernel_time = psutil.Process().cpu_times()[:2]\n        utime, ktime = os.times()[:2]\n\n        # Use os.times()[:2] as base values to compare our results\n        # using a tolerance  of +/- 0.1 seconds.\n        # It will fail if the difference between the values is > 0.1s.\n        if (max([user_time, utime]) - min([user_time, utime])) > 0.1:\n            self.fail(\"expected: %s, found: %s\" % (utime, user_time))\n\n        if (max([kernel_time, ktime]) - min([kernel_time, ktime])) > 0.1:\n            self.fail(\"expected: %s, found: %s\" % (ktime, kernel_time))\n\n    @unittest.skipIf(not HAS_PROC_CPU_NUM, \"not supported\")\n    def test_cpu_num(self):\n        p = psutil.Process()\n        num = p.cpu_num()\n        self.assertGreaterEqual(num, 0)\n        if psutil.cpu_count() == 1:\n            self.assertEqual(num, 0)\n        self.assertIn(p.cpu_num(), range(psutil.cpu_count()))\n\n    def test_create_time(self):\n        p = self.spawn_psproc()\n        now = time.time()\n        create_time = p.create_time()\n\n        # Use time.time() as base value to compare our result using a\n        # tolerance of +/- 1 second.\n        # It will fail if the difference between the values is > 2s.\n        difference = abs(create_time - now)\n        if difference > 2:\n            self.fail(\"expected: %s, found: %s, difference: %s\"\n                      % (now, create_time, difference))\n\n        # make sure returned value can be pretty printed with strftime\n        time.strftime(\"%Y %m %d %H:%M:%S\", time.localtime(p.create_time()))\n\n    @unittest.skipIf(not POSIX, 'POSIX only')\n    def test_terminal(self):\n        terminal = psutil.Process().terminal()\n        if terminal is not None:\n            tty = os.path.realpath(sh('tty'))\n            self.assertEqual(terminal, tty)\n\n    @unittest.skipIf(not HAS_PROC_IO_COUNTERS, 'not supported')\n    @skip_on_not_implemented(only_if=LINUX)\n    def test_io_counters(self):\n        p = psutil.Process()\n        # test reads\n        io1 = p.io_counters()\n        with open(PYTHON_EXE, 'rb') as f:\n            f.read()\n        io2 = p.io_counters()\n        if not BSD and not AIX:\n            self.assertGreater(io2.read_count, io1.read_count)\n            self.assertEqual(io2.write_count, io1.write_count)\n            if LINUX:\n                self.assertGreater(io2.read_chars, io1.read_chars)\n                self.assertEqual(io2.write_chars, io1.write_chars)\n        else:\n            self.assertGreaterEqual(io2.read_bytes, io1.read_bytes)\n            self.assertGreaterEqual(io2.write_bytes, io1.write_bytes)\n\n        # test writes\n        io1 = p.io_counters()\n        with open(self.get_testfn(), 'wb') as f:\n            if PY3:\n                f.write(bytes(\"x\" * 1000000, 'ascii'))\n            else:\n                f.write(\"x\" * 1000000)\n        io2 = p.io_counters()\n        self.assertGreaterEqual(io2.write_count, io1.write_count)\n        self.assertGreaterEqual(io2.write_bytes, io1.write_bytes)\n        self.assertGreaterEqual(io2.read_count, io1.read_count)\n        self.assertGreaterEqual(io2.read_bytes, io1.read_bytes)\n        if LINUX:\n            self.assertGreater(io2.write_chars, io1.write_chars)\n            self.assertGreaterEqual(io2.read_chars, io1.read_chars)\n\n        # sanity check\n        for i in range(len(io2)):\n            if BSD and i >= 2:\n                # On BSD read_bytes and write_bytes are always set to -1.\n                continue\n            self.assertGreaterEqual(io2[i], 0)\n            self.assertGreaterEqual(io2[i], 0)\n\n    @unittest.skipIf(not HAS_IONICE, \"not supported\")\n    @unittest.skipIf(not LINUX, \"linux only\")\n    def test_ionice_linux(self):\n        p = psutil.Process()\n        if not CI_TESTING:\n            self.assertEqual(p.ionice()[0], psutil.IOPRIO_CLASS_NONE)\n        self.assertEqual(psutil.IOPRIO_CLASS_NONE, 0)\n        self.assertEqual(psutil.IOPRIO_CLASS_RT, 1)  # high\n        self.assertEqual(psutil.IOPRIO_CLASS_BE, 2)  # normal\n        self.assertEqual(psutil.IOPRIO_CLASS_IDLE, 3)  # low\n        init = p.ionice()\n        try:\n            # low\n            p.ionice(psutil.IOPRIO_CLASS_IDLE)\n            self.assertEqual(tuple(p.ionice()), (psutil.IOPRIO_CLASS_IDLE, 0))\n            with self.assertRaises(ValueError):  # accepts no value\n                p.ionice(psutil.IOPRIO_CLASS_IDLE, value=7)\n            # normal\n            p.ionice(psutil.IOPRIO_CLASS_BE)\n            self.assertEqual(tuple(p.ionice()), (psutil.IOPRIO_CLASS_BE, 0))\n            p.ionice(psutil.IOPRIO_CLASS_BE, value=7)\n            self.assertEqual(tuple(p.ionice()), (psutil.IOPRIO_CLASS_BE, 7))\n            with self.assertRaises(ValueError):\n                p.ionice(psutil.IOPRIO_CLASS_BE, value=8)\n            try:\n                p.ionice(psutil.IOPRIO_CLASS_RT, value=7)\n            except psutil.AccessDenied:\n                pass\n            # errs\n            self.assertRaisesRegex(\n                ValueError, \"ioclass accepts no value\",\n                p.ionice, psutil.IOPRIO_CLASS_NONE, 1)\n            self.assertRaisesRegex(\n                ValueError, \"ioclass accepts no value\",\n                p.ionice, psutil.IOPRIO_CLASS_IDLE, 1)\n            self.assertRaisesRegex(\n                ValueError, \"'ioclass' argument must be specified\",\n                p.ionice, value=1)\n        finally:\n            ioclass, value = init\n            if ioclass == psutil.IOPRIO_CLASS_NONE:\n                value = 0\n            p.ionice(ioclass, value)\n\n    @unittest.skipIf(not HAS_IONICE, \"not supported\")\n    @unittest.skipIf(not WINDOWS, 'not supported on this win version')\n    def test_ionice_win(self):\n        p = psutil.Process()\n        if not CI_TESTING:\n            self.assertEqual(p.ionice(), psutil.IOPRIO_NORMAL)\n        init = p.ionice()\n        try:\n            # base\n            p.ionice(psutil.IOPRIO_VERYLOW)\n            self.assertEqual(p.ionice(), psutil.IOPRIO_VERYLOW)\n            p.ionice(psutil.IOPRIO_LOW)\n            self.assertEqual(p.ionice(), psutil.IOPRIO_LOW)\n            try:\n                p.ionice(psutil.IOPRIO_HIGH)\n            except psutil.AccessDenied:\n                pass\n            else:\n                self.assertEqual(p.ionice(), psutil.IOPRIO_HIGH)\n            # errs\n            self.assertRaisesRegex(\n                TypeError, \"value argument not accepted on Windows\",\n                p.ionice, psutil.IOPRIO_NORMAL, value=1)\n            self.assertRaisesRegex(\n                ValueError, \"is not a valid priority\",\n                p.ionice, psutil.IOPRIO_HIGH + 1)\n        finally:\n            p.ionice(init)\n\n    @unittest.skipIf(not HAS_RLIMIT, \"not supported\")\n    def test_rlimit_get(self):\n        import resource\n        p = psutil.Process(os.getpid())\n        names = [x for x in dir(psutil) if x.startswith('RLIMIT')]\n        assert names, names\n        for name in names:\n            value = getattr(psutil, name)\n            self.assertGreaterEqual(value, 0)\n            if name in dir(resource):\n                self.assertEqual(value, getattr(resource, name))\n                # XXX - On PyPy RLIMIT_INFINITY returned by\n                # resource.getrlimit() is reported as a very big long\n                # number instead of -1. It looks like a bug with PyPy.\n                if PYPY:\n                    continue\n                self.assertEqual(p.rlimit(value), resource.getrlimit(value))\n            else:\n                ret = p.rlimit(value)\n                self.assertEqual(len(ret), 2)\n                self.assertGreaterEqual(ret[0], -1)\n                self.assertGreaterEqual(ret[1], -1)\n\n    @unittest.skipIf(not HAS_RLIMIT, \"not supported\")\n    def test_rlimit_set(self):\n        p = self.spawn_psproc()\n        p.rlimit(psutil.RLIMIT_NOFILE, (5, 5))\n        self.assertEqual(p.rlimit(psutil.RLIMIT_NOFILE), (5, 5))\n        # If pid is 0 prlimit() applies to the calling process and\n        # we don't want that.\n        if LINUX:\n            with self.assertRaisesRegex(ValueError, \"can't use prlimit\"):\n                psutil._psplatform.Process(0).rlimit(0)\n        with self.assertRaises(ValueError):\n            p.rlimit(psutil.RLIMIT_NOFILE, (5, 5, 5))\n\n    @unittest.skipIf(not HAS_RLIMIT, \"not supported\")\n    def test_rlimit(self):\n        p = psutil.Process()\n        testfn = self.get_testfn()\n        soft, hard = p.rlimit(psutil.RLIMIT_FSIZE)\n        try:\n            p.rlimit(psutil.RLIMIT_FSIZE, (1024, hard))\n            with open(testfn, \"wb\") as f:\n                f.write(b\"X\" * 1024)\n            # write() or flush() doesn't always cause the exception\n            # but close() will.\n            with self.assertRaises(IOError) as exc:\n                with open(testfn, \"wb\") as f:\n                    f.write(b\"X\" * 1025)\n            self.assertEqual(exc.exception.errno if PY3 else exc.exception[0],\n                             errno.EFBIG)\n        finally:\n            p.rlimit(psutil.RLIMIT_FSIZE, (soft, hard))\n            self.assertEqual(p.rlimit(psutil.RLIMIT_FSIZE), (soft, hard))\n\n    @unittest.skipIf(not HAS_RLIMIT, \"not supported\")\n    def test_rlimit_infinity(self):\n        # First set a limit, then re-set it by specifying INFINITY\n        # and assume we overridden the previous limit.\n        p = psutil.Process()\n        soft, hard = p.rlimit(psutil.RLIMIT_FSIZE)\n        try:\n            p.rlimit(psutil.RLIMIT_FSIZE, (1024, hard))\n            p.rlimit(psutil.RLIMIT_FSIZE, (psutil.RLIM_INFINITY, hard))\n            with open(self.get_testfn(), \"wb\") as f:\n                f.write(b\"X\" * 2048)\n        finally:\n            p.rlimit(psutil.RLIMIT_FSIZE, (soft, hard))\n            self.assertEqual(p.rlimit(psutil.RLIMIT_FSIZE), (soft, hard))\n\n    @unittest.skipIf(not HAS_RLIMIT, \"not supported\")\n    def test_rlimit_infinity_value(self):\n        # RLIMIT_FSIZE should be RLIM_INFINITY, which will be a really\n        # big number on a platform with large file support.  On these\n        # platforms we need to test that the get/setrlimit functions\n        # properly convert the number to a C long long and that the\n        # conversion doesn't raise an error.\n        p = psutil.Process()\n        soft, hard = p.rlimit(psutil.RLIMIT_FSIZE)\n        self.assertEqual(psutil.RLIM_INFINITY, hard)\n        p.rlimit(psutil.RLIMIT_FSIZE, (soft, hard))\n\n    def test_num_threads(self):\n        # on certain platforms such as Linux we might test for exact\n        # thread number, since we always have with 1 thread per process,\n        # but this does not apply across all platforms (MACOS, Windows)\n        p = psutil.Process()\n        if OPENBSD:\n            try:\n                step1 = p.num_threads()\n            except psutil.AccessDenied:\n                raise unittest.SkipTest(\"on OpenBSD this requires root access\")\n        else:\n            step1 = p.num_threads()\n\n        with ThreadTask():\n            step2 = p.num_threads()\n            self.assertEqual(step2, step1 + 1)\n\n    @unittest.skipIf(not WINDOWS, 'WINDOWS only')\n    def test_num_handles(self):\n        # a better test is done later into test/_windows.py\n        p = psutil.Process()\n        self.assertGreater(p.num_handles(), 0)\n\n    @unittest.skipIf(not HAS_THREADS, 'not supported')\n    def test_threads(self):\n        p = psutil.Process()\n        if OPENBSD:\n            try:\n                step1 = p.threads()\n            except psutil.AccessDenied:\n                raise unittest.SkipTest(\"on OpenBSD this requires root access\")\n        else:\n            step1 = p.threads()\n\n        with ThreadTask():\n            step2 = p.threads()\n            self.assertEqual(len(step2), len(step1) + 1)\n            athread = step2[0]\n            # test named tuple\n            self.assertEqual(athread.id, athread[0])\n            self.assertEqual(athread.user_time, athread[1])\n            self.assertEqual(athread.system_time, athread[2])\n\n    @retry_on_failure()\n    @skip_on_access_denied(only_if=MACOS)\n    @unittest.skipIf(not HAS_THREADS, 'not supported')\n    def test_threads_2(self):\n        p = self.spawn_psproc()\n        if OPENBSD:\n            try:\n                p.threads()\n            except psutil.AccessDenied:\n                raise unittest.SkipTest(\n                    \"on OpenBSD this requires root access\")\n        self.assertAlmostEqual(\n            p.cpu_times().user,\n            sum([x.user_time for x in p.threads()]), delta=0.1)\n        self.assertAlmostEqual(\n            p.cpu_times().system,\n            sum([x.system_time for x in p.threads()]), delta=0.1)\n\n    @retry_on_failure()\n    def test_memory_info(self):\n        p = psutil.Process()\n\n        # step 1 - get a base value to compare our results\n        rss1, vms1 = p.memory_info()[:2]\n        percent1 = p.memory_percent()\n        self.assertGreater(rss1, 0)\n        self.assertGreater(vms1, 0)\n\n        # step 2 - allocate some memory\n        memarr = [None] * 1500000\n\n        rss2, vms2 = p.memory_info()[:2]\n        percent2 = p.memory_percent()\n\n        # step 3 - make sure that the memory usage bumped up\n        self.assertGreater(rss2, rss1)\n        self.assertGreaterEqual(vms2, vms1)  # vms might be equal\n        self.assertGreater(percent2, percent1)\n        del memarr\n\n        if WINDOWS:\n            mem = p.memory_info()\n            self.assertEqual(mem.rss, mem.wset)\n            self.assertEqual(mem.vms, mem.pagefile)\n\n        mem = p.memory_info()\n        for name in mem._fields:\n            self.assertGreaterEqual(getattr(mem, name), 0)\n\n    def test_memory_full_info(self):\n        p = psutil.Process()\n        total = psutil.virtual_memory().total\n        mem = p.memory_full_info()\n        for name in mem._fields:\n            value = getattr(mem, name)\n            self.assertGreaterEqual(value, 0, msg=(name, value))\n            if name == 'vms' and OSX or LINUX:\n                continue\n            self.assertLessEqual(value, total, msg=(name, value, total))\n        if LINUX or WINDOWS or MACOS:\n            self.assertGreaterEqual(mem.uss, 0)\n        if LINUX:\n            self.assertGreaterEqual(mem.pss, 0)\n            self.assertGreaterEqual(mem.swap, 0)\n\n    @unittest.skipIf(not HAS_MEMORY_MAPS, \"not supported\")\n    def test_memory_maps(self):\n        p = psutil.Process()\n        maps = p.memory_maps()\n        paths = [x for x in maps]\n        self.assertEqual(len(paths), len(set(paths)))\n        ext_maps = p.memory_maps(grouped=False)\n\n        for nt in maps:\n            if not nt.path.startswith('['):\n                assert os.path.isabs(nt.path), nt.path\n                if POSIX:\n                    try:\n                        assert os.path.exists(nt.path) or \\\n                            os.path.islink(nt.path), nt.path\n                    except AssertionError:\n                        if not LINUX:\n                            raise\n                        else:\n                            # https://github.com/giampaolo/psutil/issues/759\n                            with open_text('/proc/self/smaps') as f:\n                                data = f.read()\n                            if \"%s (deleted)\" % nt.path not in data:\n                                raise\n                else:\n                    # XXX - On Windows we have this strange behavior with\n                    # 64 bit dlls: they are visible via explorer but cannot\n                    # be accessed via os.stat() (wtf?).\n                    if '64' not in os.path.basename(nt.path):\n                        try:\n                            st = os.stat(nt.path)\n                        except FileNotFoundError:\n                            pass\n                        else:\n                            assert stat.S_ISREG(st.st_mode), nt.path\n        for nt in ext_maps:\n            for fname in nt._fields:\n                value = getattr(nt, fname)\n                if fname == 'path':\n                    continue\n                elif fname in ('addr', 'perms'):\n                    assert value, value\n                else:\n                    self.assertIsInstance(value, (int, long))\n                    assert value >= 0, value\n\n    @unittest.skipIf(not HAS_MEMORY_MAPS, \"not supported\")\n    def test_memory_maps_lists_lib(self):\n        # Make sure a newly loaded shared lib is listed.\n        p = psutil.Process()\n        with copyload_shared_lib() as path:\n            def normpath(p):\n                return os.path.realpath(os.path.normcase(p))\n            libpaths = [normpath(x.path)\n                        for x in p.memory_maps()]\n            self.assertIn(normpath(path), libpaths)\n\n    def test_memory_percent(self):\n        p = psutil.Process()\n        p.memory_percent()\n        self.assertRaises(ValueError, p.memory_percent, memtype=\"?!?\")\n        if LINUX or MACOS or WINDOWS:\n            p.memory_percent(memtype='uss')\n\n    def test_is_running(self):\n        p = self.spawn_psproc()\n        assert p.is_running()\n        assert p.is_running()\n        p.kill()\n        p.wait()\n        assert not p.is_running()\n        assert not p.is_running()\n\n    def test_exe(self):\n        p = self.spawn_psproc()\n        exe = p.exe()\n        try:\n            self.assertEqual(exe, PYTHON_EXE)\n        except AssertionError:\n            if WINDOWS and len(exe) == len(PYTHON_EXE):\n                # on Windows we don't care about case sensitivity\n                normcase = os.path.normcase\n                self.assertEqual(normcase(exe), normcase(PYTHON_EXE))\n            else:\n                # certain platforms such as BSD are more accurate returning:\n                # \"/usr/local/bin/python2.7\"\n                # ...instead of:\n                # \"/usr/local/bin/python\"\n                # We do not want to consider this difference in accuracy\n                # an error.\n                ver = \"%s.%s\" % (sys.version_info[0], sys.version_info[1])\n                try:\n                    self.assertEqual(exe.replace(ver, ''),\n                                     PYTHON_EXE.replace(ver, ''))\n                except AssertionError:\n                    # Tipically MACOS. Really not sure what to do here.\n                    pass\n\n        out = sh([exe, \"-c\", \"import os; print('hey')\"])\n        self.assertEqual(out, 'hey')\n\n    def test_cmdline(self):\n        cmdline = [PYTHON_EXE, \"-c\", \"import time; time.sleep(60)\"]\n        p = self.spawn_psproc(cmdline)\n        # XXX - most of the times the underlying sysctl() call on Net\n        # and Open BSD returns a truncated string.\n        # Also /proc/pid/cmdline behaves the same so it looks\n        # like this is a kernel bug.\n        # XXX - AIX truncates long arguments in /proc/pid/cmdline\n        if NETBSD or OPENBSD or AIX:\n            self.assertEqual(p.cmdline()[0], PYTHON_EXE)\n        else:\n            self.assertEqual(' '.join(p.cmdline()), ' '.join(cmdline))\n\n    @unittest.skipIf(PYPY, \"broken on PYPY\")\n    def test_long_cmdline(self):\n        testfn = self.get_testfn()\n        create_exe(testfn)\n        cmdline = [testfn] + ([\"0123456789\"] * 20)\n        p = self.spawn_psproc(cmdline)\n        self.assertEqual(p.cmdline(), cmdline)\n\n    def test_name(self):\n        p = self.spawn_psproc(PYTHON_EXE)\n        name = p.name().lower()\n        pyexe = os.path.basename(os.path.realpath(sys.executable)).lower()\n        assert pyexe.startswith(name), (pyexe, name)\n\n    @unittest.skipIf(PYPY, \"unreliable on PYPY\")\n    def test_long_name(self):\n        testfn = self.get_testfn(suffix=\"0123456789\" * 2)\n        create_exe(testfn)\n        p = self.spawn_psproc(testfn)\n        self.assertEqual(p.name(), os.path.basename(testfn))\n\n    # XXX\n    @unittest.skipIf(SUNOS, \"broken on SUNOS\")\n    @unittest.skipIf(AIX, \"broken on AIX\")\n    @unittest.skipIf(PYPY, \"broken on PYPY\")\n    def test_prog_w_funky_name(self):\n        # Test that name(), exe() and cmdline() correctly handle programs\n        # with funky chars such as spaces and \")\", see:\n        # https://github.com/giampaolo/psutil/issues/628\n        funky_path = self.get_testfn(suffix='foo bar )')\n        create_exe(funky_path)\n        cmdline = [funky_path, \"-c\",\n                   \"import time; [time.sleep(0.01) for x in range(3000)];\"\n                   \"arg1\", \"arg2\", \"\", \"arg3\", \"\"]\n        p = self.spawn_psproc(cmdline)\n        self.assertEqual(p.cmdline(), cmdline)\n        self.assertEqual(p.name(), os.path.basename(funky_path))\n        self.assertEqual(os.path.normcase(p.exe()),\n                         os.path.normcase(funky_path))\n\n    @unittest.skipIf(not POSIX, 'POSIX only')\n    def test_uids(self):\n        p = psutil.Process()\n        real, effective, saved = p.uids()\n        # os.getuid() refers to \"real\" uid\n        self.assertEqual(real, os.getuid())\n        # os.geteuid() refers to \"effective\" uid\n        self.assertEqual(effective, os.geteuid())\n        # No such thing as os.getsuid() (\"saved\" uid), but starting\n        # from python 2.7 we have os.getresuid() which returns all\n        # of them.\n        if hasattr(os, \"getresuid\"):\n            self.assertEqual(os.getresuid(), p.uids())\n\n    @unittest.skipIf(not POSIX, 'POSIX only')\n    def test_gids(self):\n        p = psutil.Process()\n        real, effective, saved = p.gids()\n        # os.getuid() refers to \"real\" uid\n        self.assertEqual(real, os.getgid())\n        # os.geteuid() refers to \"effective\" uid\n        self.assertEqual(effective, os.getegid())\n        # No such thing as os.getsgid() (\"saved\" gid), but starting\n        # from python 2.7 we have os.getresgid() which returns all\n        # of them.\n        if hasattr(os, \"getresuid\"):\n            self.assertEqual(os.getresgid(), p.gids())\n\n    def test_nice(self):\n        p = psutil.Process()\n        self.assertRaises(TypeError, p.nice, \"str\")\n        init = p.nice()\n        try:\n            if WINDOWS:\n                for prio in [psutil.NORMAL_PRIORITY_CLASS,\n                             psutil.IDLE_PRIORITY_CLASS,\n                             psutil.BELOW_NORMAL_PRIORITY_CLASS,\n                             psutil.REALTIME_PRIORITY_CLASS,\n                             psutil.HIGH_PRIORITY_CLASS,\n                             psutil.ABOVE_NORMAL_PRIORITY_CLASS]:\n                    with self.subTest(prio=prio):\n                        try:\n                            p.nice(prio)\n                        except psutil.AccessDenied:\n                            pass\n                        else:\n                            self.assertEqual(p.nice(), prio)\n            else:\n                try:\n                    if hasattr(os, \"getpriority\"):\n                        self.assertEqual(\n                            os.getpriority(os.PRIO_PROCESS, os.getpid()),\n                            p.nice())\n                    p.nice(1)\n                    self.assertEqual(p.nice(), 1)\n                    if hasattr(os, \"getpriority\"):\n                        self.assertEqual(\n                            os.getpriority(os.PRIO_PROCESS, os.getpid()),\n                            p.nice())\n                    # XXX - going back to previous nice value raises\n                    # AccessDenied on MACOS\n                    if not MACOS:\n                        p.nice(0)\n                        self.assertEqual(p.nice(), 0)\n                except psutil.AccessDenied:\n                    pass\n        finally:\n            try:\n                p.nice(init)\n            except psutil.AccessDenied:\n                pass\n\n    def test_status(self):\n        p = psutil.Process()\n        self.assertEqual(p.status(), psutil.STATUS_RUNNING)\n\n    def test_username(self):\n        p = self.spawn_psproc()\n        username = p.username()\n        if WINDOWS:\n            domain, username = username.split('\\\\')\n            self.assertEqual(username, getpass.getuser())\n            if 'USERDOMAIN' in os.environ:\n                self.assertEqual(domain, os.environ['USERDOMAIN'])\n        else:\n            self.assertEqual(username, getpass.getuser())\n\n    def test_cwd(self):\n        p = self.spawn_psproc()\n        self.assertEqual(p.cwd(), os.getcwd())\n\n    def test_cwd_2(self):\n        cmd = [PYTHON_EXE, \"-c\",\n               \"import os, time; os.chdir('..'); time.sleep(60)\"]\n        p = self.spawn_psproc(cmd)\n        call_until(p.cwd, \"ret == os.path.dirname(os.getcwd())\")\n\n    @unittest.skipIf(not HAS_CPU_AFFINITY, 'not supported')\n    def test_cpu_affinity(self):\n        p = psutil.Process()\n        initial = p.cpu_affinity()\n        assert initial, initial\n        self.addCleanup(p.cpu_affinity, initial)\n\n        if hasattr(os, \"sched_getaffinity\"):\n            self.assertEqual(initial, list(os.sched_getaffinity(p.pid)))\n        self.assertEqual(len(initial), len(set(initial)))\n\n        all_cpus = list(range(len(psutil.cpu_percent(percpu=True))))\n        for n in all_cpus:\n            p.cpu_affinity([n])\n            self.assertEqual(p.cpu_affinity(), [n])\n            if hasattr(os, \"sched_getaffinity\"):\n                self.assertEqual(p.cpu_affinity(),\n                                 list(os.sched_getaffinity(p.pid)))\n            # also test num_cpu()\n            if hasattr(p, \"num_cpu\"):\n                self.assertEqual(p.cpu_affinity()[0], p.num_cpu())\n\n        # [] is an alias for \"all eligible CPUs\"; on Linux this may\n        # not be equal to all available CPUs, see:\n        # https://github.com/giampaolo/psutil/issues/956\n        p.cpu_affinity([])\n        if LINUX:\n            self.assertEqual(p.cpu_affinity(), p._proc._get_eligible_cpus())\n        else:\n            self.assertEqual(p.cpu_affinity(), all_cpus)\n        if hasattr(os, \"sched_getaffinity\"):\n            self.assertEqual(p.cpu_affinity(),\n                             list(os.sched_getaffinity(p.pid)))\n        #\n        self.assertRaises(TypeError, p.cpu_affinity, 1)\n        p.cpu_affinity(initial)\n        # it should work with all iterables, not only lists\n        p.cpu_affinity(set(all_cpus))\n        p.cpu_affinity(tuple(all_cpus))\n\n    @unittest.skipIf(not HAS_CPU_AFFINITY, 'not supported')\n    def test_cpu_affinity_errs(self):\n        p = self.spawn_psproc()\n        invalid_cpu = [len(psutil.cpu_times(percpu=True)) + 10]\n        self.assertRaises(ValueError, p.cpu_affinity, invalid_cpu)\n        self.assertRaises(ValueError, p.cpu_affinity, range(10000, 11000))\n        self.assertRaises(TypeError, p.cpu_affinity, [0, \"1\"])\n        self.assertRaises(ValueError, p.cpu_affinity, [0, -1])\n\n    @unittest.skipIf(not HAS_CPU_AFFINITY, 'not supported')\n    def test_cpu_affinity_all_combinations(self):\n        p = psutil.Process()\n        initial = p.cpu_affinity()\n        assert initial, initial\n        self.addCleanup(p.cpu_affinity, initial)\n\n        # All possible CPU set combinations.\n        if len(initial) > 12:\n            initial = initial[:12]  # ...otherwise it will take forever\n        combos = []\n        for i in range(0, len(initial) + 1):\n            for subset in itertools.combinations(initial, i):\n                if subset:\n                    combos.append(list(subset))\n\n        for combo in combos:\n            p.cpu_affinity(combo)\n            self.assertEqual(sorted(p.cpu_affinity()), sorted(combo))\n\n    # TODO: #595\n    @unittest.skipIf(BSD, \"broken on BSD\")\n    # can't find any process file on Appveyor\n    @unittest.skipIf(APPVEYOR, \"unreliable on APPVEYOR\")\n    def test_open_files(self):\n        p = psutil.Process()\n        testfn = self.get_testfn()\n        files = p.open_files()\n        self.assertNotIn(testfn, files)\n        with open(testfn, 'wb') as f:\n            f.write(b'x' * 1024)\n            f.flush()\n            # give the kernel some time to see the new file\n            files = call_until(p.open_files, \"len(ret) != %i\" % len(files))\n            filenames = [os.path.normcase(x.path) for x in files]\n            self.assertIn(os.path.normcase(testfn), filenames)\n            if LINUX:\n                for file in files:\n                    if file.path == testfn:\n                        self.assertEqual(file.position, 1024)\n        for file in files:\n            assert os.path.isfile(file.path), file\n\n        # another process\n        cmdline = \"import time; f = open(r'%s', 'r'); time.sleep(60);\" % testfn\n        p = self.spawn_psproc([PYTHON_EXE, \"-c\", cmdline])\n\n        for x in range(100):\n            filenames = [os.path.normcase(x.path) for x in p.open_files()]\n            if testfn in filenames:\n                break\n            time.sleep(.01)\n        else:\n            self.assertIn(os.path.normcase(testfn), filenames)\n        for file in filenames:\n            assert os.path.isfile(file), file\n\n    # TODO: #595\n    @unittest.skipIf(BSD, \"broken on BSD\")\n    # can't find any process file on Appveyor\n    @unittest.skipIf(APPVEYOR, \"unreliable on APPVEYOR\")\n    def test_open_files_2(self):\n        # test fd and path fields\n        p = psutil.Process()\n        normcase = os.path.normcase\n        testfn = self.get_testfn()\n        with open(testfn, 'w') as fileobj:\n            for file in p.open_files():\n                if normcase(file.path) == normcase(fileobj.name) or \\\n                        file.fd == fileobj.fileno():\n                    break\n            else:\n                self.fail(\"no file found; files=%s\" % repr(p.open_files()))\n            self.assertEqual(normcase(file.path), normcase(fileobj.name))\n            if WINDOWS:\n                self.assertEqual(file.fd, -1)\n            else:\n                self.assertEqual(file.fd, fileobj.fileno())\n            # test positions\n            ntuple = p.open_files()[0]\n            self.assertEqual(ntuple[0], ntuple.path)\n            self.assertEqual(ntuple[1], ntuple.fd)\n            # test file is gone\n            self.assertNotIn(fileobj.name, p.open_files())\n\n    @unittest.skipIf(not POSIX, 'POSIX only')\n    def test_num_fds(self):\n        p = psutil.Process()\n        testfn = self.get_testfn()\n        start = p.num_fds()\n        file = open(testfn, 'w')\n        self.addCleanup(file.close)\n        self.assertEqual(p.num_fds(), start + 1)\n        sock = socket.socket()\n        self.addCleanup(sock.close)\n        self.assertEqual(p.num_fds(), start + 2)\n        file.close()\n        sock.close()\n        self.assertEqual(p.num_fds(), start)\n\n    @skip_on_not_implemented(only_if=LINUX)\n    @unittest.skipIf(OPENBSD or NETBSD, \"not reliable on OPENBSD & NETBSD\")\n    def test_num_ctx_switches(self):\n        p = psutil.Process()\n        before = sum(p.num_ctx_switches())\n        for x in range(500000):\n            after = sum(p.num_ctx_switches())\n            if after > before:\n                return\n        self.fail(\"num ctx switches still the same after 50.000 iterations\")\n\n    def test_ppid(self):\n        p = psutil.Process()\n        if hasattr(os, 'getppid'):\n            self.assertEqual(p.ppid(), os.getppid())\n        p = self.spawn_psproc()\n        self.assertEqual(p.ppid(), os.getpid())\n        if APPVEYOR:\n            # Occasional failures, see:\n            # https://ci.appveyor.com/project/giampaolo/psutil/build/\n            #     job/0hs623nenj7w4m33\n            return\n\n    def test_parent(self):\n        p = self.spawn_psproc()\n        self.assertEqual(p.parent().pid, os.getpid())\n\n        lowest_pid = psutil.pids()[0]\n        self.assertIsNone(psutil.Process(lowest_pid).parent())\n\n    def test_parent_multi(self):\n        parent = psutil.Process()\n        child, grandchild = self.spawn_children_pair()\n        self.assertEqual(grandchild.parent(), child)\n        self.assertEqual(child.parent(), parent)\n\n    def test_parent_disappeared(self):\n        # Emulate a case where the parent process disappeared.\n        p = self.spawn_psproc()\n        with mock.patch(\"psutil.Process\",\n                        side_effect=psutil.NoSuchProcess(0, 'foo')):\n            self.assertIsNone(p.parent())\n\n    @retry_on_failure()\n    def test_parents(self):\n        parent = psutil.Process()\n        assert parent.parents()\n        child, grandchild = self.spawn_children_pair()\n        self.assertEqual(child.parents()[0], parent)\n        self.assertEqual(grandchild.parents()[0], child)\n        self.assertEqual(grandchild.parents()[1], parent)\n\n    def test_children(self):\n        parent = psutil.Process()\n        self.assertEqual(parent.children(), [])\n        self.assertEqual(parent.children(recursive=True), [])\n        # On Windows we set the flag to 0 in order to cancel out the\n        # CREATE_NO_WINDOW flag (enabled by default) which creates\n        # an extra \"conhost.exe\" child.\n        child = self.spawn_psproc(creationflags=0)\n        children1 = parent.children()\n        children2 = parent.children(recursive=True)\n        for children in (children1, children2):\n            self.assertEqual(len(children), 1)\n            self.assertEqual(children[0].pid, child.pid)\n            self.assertEqual(children[0].ppid(), parent.pid)\n\n    def test_children_recursive(self):\n        # Test children() against two sub processes, p1 and p2, where\n        # p1 (our child) spawned p2 (our grandchild).\n        parent = psutil.Process()\n        child, grandchild = self.spawn_children_pair()\n        self.assertEqual(parent.children(), [child])\n        self.assertEqual(parent.children(recursive=True), [child, grandchild])\n        # If the intermediate process is gone there's no way for\n        # children() to recursively find it.\n        child.terminate()\n        child.wait()\n        self.assertEqual(parent.children(recursive=True), [])\n\n    def test_children_duplicates(self):\n        # find the process which has the highest number of children\n        table = collections.defaultdict(int)\n        for p in psutil.process_iter():\n            try:\n                table[p.ppid()] += 1\n            except psutil.Error:\n                pass\n        # this is the one, now let's make sure there are no duplicates\n        pid = sorted(table.items(), key=lambda x: x[1])[-1][0]\n        if LINUX and pid == 0:\n            raise self.skipTest(\"PID 0\")\n        p = psutil.Process(pid)\n        try:\n            c = p.children(recursive=True)\n        except psutil.AccessDenied:  # windows\n            pass\n        else:\n            self.assertEqual(len(c), len(set(c)))\n\n    def test_parents_and_children(self):\n        parent = psutil.Process()\n        child, grandchild = self.spawn_children_pair()\n        # forward\n        children = parent.children(recursive=True)\n        self.assertEqual(len(children), 2)\n        self.assertEqual(children[0], child)\n        self.assertEqual(children[1], grandchild)\n        # backward\n        parents = grandchild.parents()\n        self.assertEqual(parents[0], child)\n        self.assertEqual(parents[1], parent)\n\n    def test_suspend_resume(self):\n        p = self.spawn_psproc()\n        p.suspend()\n        for x in range(100):\n            if p.status() == psutil.STATUS_STOPPED:\n                break\n            time.sleep(0.01)\n        p.resume()\n        self.assertNotEqual(p.status(), psutil.STATUS_STOPPED)\n\n    def test_invalid_pid(self):\n        self.assertRaises(TypeError, psutil.Process, \"1\")\n        self.assertRaises(ValueError, psutil.Process, -1)\n\n    def test_as_dict(self):\n        p = psutil.Process()\n        d = p.as_dict(attrs=['exe', 'name'])\n        self.assertEqual(sorted(d.keys()), ['exe', 'name'])\n\n        p = psutil.Process(min(psutil.pids()))\n        d = p.as_dict(attrs=['connections'], ad_value='foo')\n        if not isinstance(d['connections'], list):\n            self.assertEqual(d['connections'], 'foo')\n\n        # Test ad_value is set on AccessDenied.\n        with mock.patch('psutil.Process.nice', create=True,\n                        side_effect=psutil.AccessDenied):\n            self.assertEqual(\n                p.as_dict(attrs=[\"nice\"], ad_value=1), {\"nice\": 1})\n\n        # Test that NoSuchProcess bubbles up.\n        with mock.patch('psutil.Process.nice', create=True,\n                        side_effect=psutil.NoSuchProcess(p.pid, \"name\")):\n            self.assertRaises(\n                psutil.NoSuchProcess, p.as_dict, attrs=[\"nice\"])\n\n        # Test that ZombieProcess is swallowed.\n        with mock.patch('psutil.Process.nice', create=True,\n                        side_effect=psutil.ZombieProcess(p.pid, \"name\")):\n            self.assertEqual(\n                p.as_dict(attrs=[\"nice\"], ad_value=\"foo\"), {\"nice\": \"foo\"})\n\n        # By default APIs raising NotImplementedError are\n        # supposed to be skipped.\n        with mock.patch('psutil.Process.nice', create=True,\n                        side_effect=NotImplementedError):\n            d = p.as_dict()\n            self.assertNotIn('nice', list(d.keys()))\n            # ...unless the user explicitly asked for some attr.\n            with self.assertRaises(NotImplementedError):\n                p.as_dict(attrs=[\"nice\"])\n\n        # errors\n        with self.assertRaises(TypeError):\n            p.as_dict('name')\n        with self.assertRaises(ValueError):\n            p.as_dict(['foo'])\n        with self.assertRaises(ValueError):\n            p.as_dict(['foo', 'bar'])\n\n    def test_oneshot(self):\n        p = psutil.Process()\n        with mock.patch(\"psutil._psplatform.Process.cpu_times\") as m:\n            with p.oneshot():\n                p.cpu_times()\n                p.cpu_times()\n            self.assertEqual(m.call_count, 1)\n\n        with mock.patch(\"psutil._psplatform.Process.cpu_times\") as m:\n            p.cpu_times()\n            p.cpu_times()\n        self.assertEqual(m.call_count, 2)\n\n    def test_oneshot_twice(self):\n        # Test the case where the ctx manager is __enter__ed twice.\n        # The second __enter__ is supposed to resut in a NOOP.\n        p = psutil.Process()\n        with mock.patch(\"psutil._psplatform.Process.cpu_times\") as m1:\n            with mock.patch(\"psutil._psplatform.Process.oneshot_enter\") as m2:\n                with p.oneshot():\n                    p.cpu_times()\n                    p.cpu_times()\n                    with p.oneshot():\n                        p.cpu_times()\n                        p.cpu_times()\n                self.assertEqual(m1.call_count, 1)\n                self.assertEqual(m2.call_count, 1)\n\n        with mock.patch(\"psutil._psplatform.Process.cpu_times\") as m:\n            p.cpu_times()\n            p.cpu_times()\n        self.assertEqual(m.call_count, 2)\n\n    def test_oneshot_cache(self):\n        # Make sure oneshot() cache is nonglobal. Instead it's\n        # supposed to be bound to the Process instance, see:\n        # https://github.com/giampaolo/psutil/issues/1373\n        p1, p2 = self.spawn_children_pair()\n        p1_ppid = p1.ppid()\n        p2_ppid = p2.ppid()\n        self.assertNotEqual(p1_ppid, p2_ppid)\n        with p1.oneshot():\n            self.assertEqual(p1.ppid(), p1_ppid)\n            self.assertEqual(p2.ppid(), p2_ppid)\n        with p2.oneshot():\n            self.assertEqual(p1.ppid(), p1_ppid)\n            self.assertEqual(p2.ppid(), p2_ppid)\n\n    def test_halfway_terminated_process(self):\n        # Test that NoSuchProcess exception gets raised in case the\n        # process dies after we create the Process object.\n        # Example:\n        # >>> proc = Process(1234)\n        # >>> time.sleep(2)  # time-consuming task, process dies in meantime\n        # >>> proc.name()\n        # Refers to Issue #15\n        def assert_raises_nsp(fun, fun_name):\n            try:\n                ret = fun()\n            except psutil.ZombieProcess:  # differentiate from NSP\n                raise\n            except psutil.NoSuchProcess:\n                pass\n            except psutil.AccessDenied:\n                if OPENBSD and fun_name in ('threads', 'num_threads'):\n                    return\n                raise\n            else:\n                # NtQuerySystemInformation succeeds even if process is gone.\n                if WINDOWS and fun_name in ('exe', 'name'):\n                    return\n                raise self.fail(\"%r didn't raise NSP and returned %r \"\n                                \"instead\" % (fun, ret))\n\n        p = self.spawn_psproc()\n        p.terminate()\n        p.wait()\n        if WINDOWS:  # XXX\n            call_until(psutil.pids, \"%s not in ret\" % p.pid)\n        self.assertProcessGone(p)\n\n        ns = process_namespace(p)\n        for fun, name in ns.iter(ns.all):\n            assert_raises_nsp(fun, name)\n\n        # NtQuerySystemInformation succeeds even if process is gone.\n        if WINDOWS and not GITHUB_ACTIONS:\n            normcase = os.path.normcase\n            self.assertEqual(normcase(p.exe()), normcase(PYTHON_EXE))\n\n    @unittest.skipIf(not POSIX, 'POSIX only')\n    def test_zombie_process(self):\n        def succeed_or_zombie_p_exc(fun):\n            try:\n                return fun()\n            except (psutil.ZombieProcess, psutil.AccessDenied):\n                pass\n\n        parent, zombie = self.spawn_zombie()\n        # A zombie process should always be instantiable\n        zproc = psutil.Process(zombie.pid)\n        # ...and at least its status always be querable\n        self.assertEqual(zproc.status(), psutil.STATUS_ZOMBIE)\n        # ...and it should be considered 'running'\n        assert zproc.is_running()\n        # ...and as_dict() shouldn't crash\n        zproc.as_dict()\n        # ...its parent should 'see' it (edit: not true on BSD and MACOS\n        # descendants = [x.pid for x in psutil.Process().children(\n        #                recursive=True)]\n        # self.assertIn(zpid, descendants)\n        # XXX should we also assume ppid be usable?  Note: this\n        # would be an important use case as the only way to get\n        # rid of a zombie is to kill its parent.\n        # self.assertEqual(zpid.ppid(), os.getpid())\n        # ...and all other APIs should be able to deal with it\n\n        ns = process_namespace(zproc)\n        for fun, name in ns.iter(ns.all):\n            succeed_or_zombie_p_exc(fun)\n\n        assert psutil.pid_exists(zproc.pid)\n        self.assertIn(zproc.pid, psutil.pids())\n        self.assertIn(zproc.pid, [x.pid for x in psutil.process_iter()])\n        psutil._pmap = {}\n        self.assertIn(zproc.pid, [x.pid for x in psutil.process_iter()])\n\n    @unittest.skipIf(not POSIX, 'POSIX only')\n    def test_zombie_process_is_running_w_exc(self):\n        # Emulate a case where internally is_running() raises\n        # ZombieProcess.\n        p = psutil.Process()\n        with mock.patch(\"psutil.Process\",\n                        side_effect=psutil.ZombieProcess(0)) as m:\n            assert p.is_running()\n            assert m.called\n\n    @unittest.skipIf(not POSIX, 'POSIX only')\n    def test_zombie_process_status_w_exc(self):\n        # Emulate a case where internally status() raises\n        # ZombieProcess.\n        p = psutil.Process()\n        with mock.patch(\"psutil._psplatform.Process.status\",\n                        side_effect=psutil.ZombieProcess(0)) as m:\n            self.assertEqual(p.status(), psutil.STATUS_ZOMBIE)\n            assert m.called\n\n    def test_pid_0(self):\n        # Process(0) is supposed to work on all platforms except Linux\n        if 0 not in psutil.pids():\n            self.assertRaises(psutil.NoSuchProcess, psutil.Process, 0)\n            # These 2 are a contradiction, but \"ps\" says PID 1's parent\n            # is PID 0.\n            assert not psutil.pid_exists(0)\n            self.assertEqual(psutil.Process(1).ppid(), 0)\n            return\n\n        p = psutil.Process(0)\n        exc = psutil.AccessDenied if WINDOWS else ValueError\n        self.assertRaises(exc, p.wait)\n        self.assertRaises(exc, p.terminate)\n        self.assertRaises(exc, p.suspend)\n        self.assertRaises(exc, p.resume)\n        self.assertRaises(exc, p.kill)\n        self.assertRaises(exc, p.send_signal, signal.SIGTERM)\n\n        # test all methods\n        ns = process_namespace(p)\n        for fun, name in ns.iter(ns.getters + ns.setters):\n            try:\n                ret = fun()\n            except psutil.AccessDenied:\n                pass\n            else:\n                if name in (\"uids\", \"gids\"):\n                    self.assertEqual(ret.real, 0)\n                elif name == \"username\":\n                    user = 'NT AUTHORITY\\\\SYSTEM' if WINDOWS else 'root'\n                    self.assertEqual(p.username(), user)\n                elif name == \"name\":\n                    assert name, name\n\n        if not OPENBSD:\n            self.assertIn(0, psutil.pids())\n            assert psutil.pid_exists(0)\n\n    @unittest.skipIf(not HAS_ENVIRON, \"not supported\")\n    def test_environ(self):\n        def clean_dict(d):\n            # Most of these are problematic on Travis.\n            d.pop(\"PSUTIL_TESTING\", None)\n            d.pop(\"PLAT\", None)\n            d.pop(\"HOME\", None)\n            if MACOS:\n                d.pop(\"__CF_USER_TEXT_ENCODING\", None)\n                d.pop(\"VERSIONER_PYTHON_PREFER_32_BIT\", None)\n                d.pop(\"VERSIONER_PYTHON_VERSION\", None)\n            return dict(\n                [(k.replace(\"\\r\", \"\").replace(\"\\n\", \"\"),\n                  v.replace(\"\\r\", \"\").replace(\"\\n\", \"\"))\n                 for k, v in d.items()])\n\n        self.maxDiff = None\n        p = psutil.Process()\n        d1 = clean_dict(p.environ())\n        d2 = clean_dict(os.environ.copy())\n        if not OSX and GITHUB_ACTIONS:\n            self.assertEqual(d1, d2)\n\n    @unittest.skipIf(not HAS_ENVIRON, \"not supported\")\n    @unittest.skipIf(not POSIX, \"POSIX only\")\n    def test_weird_environ(self):\n        # environment variables can contain values without an equals sign\n        code = textwrap.dedent(\"\"\"\n            #include <unistd.h>\n            #include <fcntl.h>\n            char * const argv[] = {\"cat\", 0};\n            char * const envp[] = {\"A=1\", \"X\", \"C=3\", 0};\n            int main(void) {\n                /* Close stderr on exec so parent can wait for the execve to\n                 * finish. */\n                if (fcntl(2, F_SETFD, FD_CLOEXEC) != 0)\n                    return 0;\n                return execve(\"/bin/cat\", argv, envp);\n            }\n            \"\"\")\n        path = self.get_testfn()\n        create_exe(path, c_code=code)\n        sproc = self.spawn_testproc(\n            [path], stdin=subprocess.PIPE, stderr=subprocess.PIPE)\n        p = psutil.Process(sproc.pid)\n        wait_for_pid(p.pid)\n        assert p.is_running()\n        # Wait for process to exec or exit.\n        self.assertEqual(sproc.stderr.read(), b\"\")\n        if MACOS and CI_TESTING:\n            try:\n                env = p.environ()\n            except psutil.AccessDenied:\n                # XXX: fails sometimes with:\n                # PermissionError from 'sysctl(KERN_PROCARGS2) -> EIO'\n                return\n        else:\n            env = p.environ()\n        self.assertEqual(env, {\"A\": \"1\", \"C\": \"3\"})\n        sproc.communicate()\n        self.assertEqual(sproc.returncode, 0)\n\n\n# ===================================================================\n# --- Limited user tests\n# ===================================================================\n\n\nif POSIX and os.getuid() == 0:\n\n    class LimitedUserTestCase(TestProcess):\n        \"\"\"Repeat the previous tests by using a limited user.\n        Executed only on UNIX and only if the user who run the test script\n        is root.\n        \"\"\"\n        # the uid/gid the test suite runs under\n        if hasattr(os, 'getuid'):\n            PROCESS_UID = os.getuid()\n            PROCESS_GID = os.getgid()\n\n        def __init__(self, *args, **kwargs):\n            super().__init__(*args, **kwargs)\n            # re-define all existent test methods in order to\n            # ignore AccessDenied exceptions\n            for attr in [x for x in dir(self) if x.startswith('test')]:\n                meth = getattr(self, attr)\n\n                def test_(self):\n                    try:\n                        meth()\n                    except psutil.AccessDenied:\n                        pass\n                setattr(self, attr, types.MethodType(test_, self))\n\n        def setUp(self):\n            super().setUp()\n            os.setegid(1000)\n            os.seteuid(1000)\n\n        def tearDown(self):\n            os.setegid(self.PROCESS_UID)\n            os.seteuid(self.PROCESS_GID)\n            super().tearDown()\n\n        def test_nice(self):\n            try:\n                psutil.Process().nice(-1)\n            except psutil.AccessDenied:\n                pass\n            else:\n                self.fail(\"exception not raised\")\n\n        @unittest.skipIf(1, \"causes problem as root\")\n        def test_zombie_process(self):\n            pass\n\n\n# ===================================================================\n# --- psutil.Popen tests\n# ===================================================================\n\n\nclass TestPopen(PsutilTestCase):\n    \"\"\"Tests for psutil.Popen class.\"\"\"\n\n    @classmethod\n    def tearDownClass(cls):\n        reap_children()\n\n    def test_misc(self):\n        # XXX this test causes a ResourceWarning on Python 3 because\n        # psutil.__subproc instance doesn't get propertly freed.\n        # Not sure what to do though.\n        cmd = [PYTHON_EXE, \"-c\", \"import time; time.sleep(60);\"]\n        with psutil.Popen(cmd, stdout=subprocess.PIPE,\n                          stderr=subprocess.PIPE) as proc:\n            proc.name()\n            proc.cpu_times()\n            proc.stdin\n            self.assertTrue(dir(proc))\n            self.assertRaises(AttributeError, getattr, proc, 'foo')\n            proc.terminate()\n        if POSIX:\n            self.assertEqual(proc.wait(5), -signal.SIGTERM)\n        else:\n            self.assertEqual(proc.wait(5), signal.SIGTERM)\n\n    def test_ctx_manager(self):\n        with psutil.Popen([PYTHON_EXE, \"-V\"],\n                          stdout=subprocess.PIPE,\n                          stderr=subprocess.PIPE,\n                          stdin=subprocess.PIPE) as proc:\n            proc.communicate()\n        assert proc.stdout.closed\n        assert proc.stderr.closed\n        assert proc.stdin.closed\n        self.assertEqual(proc.returncode, 0)\n\n    def test_kill_terminate(self):\n        # subprocess.Popen()'s terminate(), kill() and send_signal() do\n        # not raise exception after the process is gone. psutil.Popen\n        # diverges from that.\n        cmd = [PYTHON_EXE, \"-c\", \"import time; time.sleep(60);\"]\n        with psutil.Popen(cmd, stdout=subprocess.PIPE,\n                          stderr=subprocess.PIPE) as proc:\n            proc.terminate()\n            proc.wait()\n            self.assertRaises(psutil.NoSuchProcess, proc.terminate)\n            self.assertRaises(psutil.NoSuchProcess, proc.kill)\n            self.assertRaises(psutil.NoSuchProcess, proc.send_signal,\n                              signal.SIGTERM)\n            if WINDOWS and sys.version_info >= (2, 7):\n                self.assertRaises(psutil.NoSuchProcess, proc.send_signal,\n                                  signal.CTRL_C_EVENT)\n                self.assertRaises(psutil.NoSuchProcess, proc.send_signal,\n                                  signal.CTRL_BREAK_EVENT)\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n    run_from_name(__file__)\n"
                    },
                    "test_sunos": {
                        "type": "module",
                        "extension": "py",
                        "code": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Sun OS specific tests.\"\"\"\n\nimport os\n\nimport psutil\nfrom psutil import SUNOS\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import sh\nfrom psutil.tests import unittest\n\n\n@unittest.skipIf(not SUNOS, \"SUNOS only\")\nclass SunOSSpecificTestCase(PsutilTestCase):\n\n    def test_swap_memory(self):\n        out = sh('env PATH=/usr/sbin:/sbin:%s swap -l' % os.environ['PATH'])\n        lines = out.strip().split('\\n')[1:]\n        if not lines:\n            raise ValueError('no swap device(s) configured')\n        total = free = 0\n        for line in lines:\n            line = line.split()\n            t, f = line[-2:]\n            total += int(int(t) * 512)\n            free += int(int(f) * 512)\n        used = total - free\n\n        psutil_swap = psutil.swap_memory()\n        self.assertEqual(psutil_swap.total, total)\n        self.assertEqual(psutil_swap.used, used)\n        self.assertEqual(psutil_swap.free, free)\n\n    def test_cpu_count(self):\n        out = sh(\"/usr/sbin/psrinfo\")\n        self.assertEqual(psutil.cpu_count(), len(out.split('\\n')))\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n    run_from_name(__file__)\n"
                    },
                    "test_system": {
                        "type": "module",
                        "extension": "py",
                        "code": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Tests for system APIS.\"\"\"\n\nimport contextlib\nimport datetime\nimport errno\nimport os\nimport pprint\nimport shutil\nimport signal\nimport socket\nimport sys\nimport time\n\nimport psutil\nfrom psutil import AIX\nfrom psutil import BSD\nfrom psutil import FREEBSD\nfrom psutil import LINUX\nfrom psutil import MACOS\nfrom psutil import NETBSD\nfrom psutil import OPENBSD\nfrom psutil import POSIX\nfrom psutil import SUNOS\nfrom psutil import WINDOWS\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import long\nfrom psutil.tests import ASCII_FS\nfrom psutil.tests import check_net_address\nfrom psutil.tests import CI_TESTING\nfrom psutil.tests import DEVNULL\nfrom psutil.tests import enum\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_NET_IO_COUNTERS\nfrom psutil.tests import HAS_SENSORS_BATTERY\nfrom psutil.tests import HAS_SENSORS_FANS\nfrom psutil.tests import HAS_SENSORS_TEMPERATURES\nfrom psutil.tests import IS_64BIT\nfrom psutil.tests import mock\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import PYPY\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import UNICODE_SUFFIX\nfrom psutil.tests import unittest\n\n\n# ===================================================================\n# --- System-related API tests\n# ===================================================================\n\n\nclass TestProcessAPIs(PsutilTestCase):\n\n    def test_process_iter(self):\n        self.assertIn(os.getpid(), [x.pid for x in psutil.process_iter()])\n        sproc = self.spawn_testproc()\n        self.assertIn(sproc.pid, [x.pid for x in psutil.process_iter()])\n        p = psutil.Process(sproc.pid)\n        p.kill()\n        p.wait()\n        self.assertNotIn(sproc.pid, [x.pid for x in psutil.process_iter()])\n\n        with mock.patch('psutil.Process',\n                        side_effect=psutil.NoSuchProcess(os.getpid())):\n            self.assertEqual(list(psutil.process_iter()), [])\n        with mock.patch('psutil.Process',\n                        side_effect=psutil.AccessDenied(os.getpid())):\n            with self.assertRaises(psutil.AccessDenied):\n                list(psutil.process_iter())\n\n    def test_prcess_iter_w_attrs(self):\n        for p in psutil.process_iter(attrs=['pid']):\n            self.assertEqual(list(p.info.keys()), ['pid'])\n        with self.assertRaises(ValueError):\n            list(psutil.process_iter(attrs=['foo']))\n        with mock.patch(\"psutil._psplatform.Process.cpu_times\",\n                        side_effect=psutil.AccessDenied(0, \"\")) as m:\n            for p in psutil.process_iter(attrs=[\"pid\", \"cpu_times\"]):\n                self.assertIsNone(p.info['cpu_times'])\n                self.assertGreaterEqual(p.info['pid'], 0)\n            assert m.called\n        with mock.patch(\"psutil._psplatform.Process.cpu_times\",\n                        side_effect=psutil.AccessDenied(0, \"\")) as m:\n            flag = object()\n            for p in psutil.process_iter(\n                    attrs=[\"pid\", \"cpu_times\"], ad_value=flag):\n                self.assertIs(p.info['cpu_times'], flag)\n                self.assertGreaterEqual(p.info['pid'], 0)\n            assert m.called\n\n    @unittest.skipIf(PYPY and WINDOWS,\n                     \"spawn_testproc() unreliable on PYPY + WINDOWS\")\n    def test_wait_procs(self):\n        def callback(p):\n            pids.append(p.pid)\n\n        pids = []\n        sproc1 = self.spawn_testproc()\n        sproc2 = self.spawn_testproc()\n        sproc3 = self.spawn_testproc()\n        procs = [psutil.Process(x.pid) for x in (sproc1, sproc2, sproc3)]\n        self.assertRaises(ValueError, psutil.wait_procs, procs, timeout=-1)\n        self.assertRaises(TypeError, psutil.wait_procs, procs, callback=1)\n        t = time.time()\n        gone, alive = psutil.wait_procs(procs, timeout=0.01, callback=callback)\n\n        self.assertLess(time.time() - t, 0.5)\n        self.assertEqual(gone, [])\n        self.assertEqual(len(alive), 3)\n        self.assertEqual(pids, [])\n        for p in alive:\n            self.assertFalse(hasattr(p, 'returncode'))\n\n        @retry_on_failure(30)\n        def test(procs, callback):\n            gone, alive = psutil.wait_procs(procs, timeout=0.03,\n                                            callback=callback)\n            self.assertEqual(len(gone), 1)\n            self.assertEqual(len(alive), 2)\n            return gone, alive\n\n        sproc3.terminate()\n        gone, alive = test(procs, callback)\n        self.assertIn(sproc3.pid, [x.pid for x in gone])\n        if POSIX:\n            self.assertEqual(gone.pop().returncode, -signal.SIGTERM)\n        else:\n            self.assertEqual(gone.pop().returncode, 1)\n        self.assertEqual(pids, [sproc3.pid])\n        for p in alive:\n            self.assertFalse(hasattr(p, 'returncode'))\n\n        @retry_on_failure(30)\n        def test(procs, callback):\n            gone, alive = psutil.wait_procs(procs, timeout=0.03,\n                                            callback=callback)\n            self.assertEqual(len(gone), 3)\n            self.assertEqual(len(alive), 0)\n            return gone, alive\n\n        sproc1.terminate()\n        sproc2.terminate()\n        gone, alive = test(procs, callback)\n        self.assertEqual(set(pids), set([sproc1.pid, sproc2.pid, sproc3.pid]))\n        for p in gone:\n            self.assertTrue(hasattr(p, 'returncode'))\n\n    @unittest.skipIf(PYPY and WINDOWS,\n                     \"spawn_testproc() unreliable on PYPY + WINDOWS\")\n    def test_wait_procs_no_timeout(self):\n        sproc1 = self.spawn_testproc()\n        sproc2 = self.spawn_testproc()\n        sproc3 = self.spawn_testproc()\n        procs = [psutil.Process(x.pid) for x in (sproc1, sproc2, sproc3)]\n        for p in procs:\n            p.terminate()\n        gone, alive = psutil.wait_procs(procs)\n\n    def test_pid_exists(self):\n        sproc = self.spawn_testproc()\n        self.assertTrue(psutil.pid_exists(sproc.pid))\n        p = psutil.Process(sproc.pid)\n        p.kill()\n        p.wait()\n        self.assertFalse(psutil.pid_exists(sproc.pid))\n        self.assertFalse(psutil.pid_exists(-1))\n        self.assertEqual(psutil.pid_exists(0), 0 in psutil.pids())\n\n    def test_pid_exists_2(self):\n        pids = psutil.pids()\n        for pid in pids:\n            try:\n                assert psutil.pid_exists(pid)\n            except AssertionError:\n                # in case the process disappeared in meantime fail only\n                # if it is no longer in psutil.pids()\n                time.sleep(.1)\n                if pid in psutil.pids():\n                    self.fail(pid)\n        pids = range(max(pids) + 5000, max(pids) + 6000)\n        for pid in pids:\n            self.assertFalse(psutil.pid_exists(pid), msg=pid)\n\n\nclass TestMiscAPIs(PsutilTestCase):\n\n    def test_boot_time(self):\n        bt = psutil.boot_time()\n        self.assertIsInstance(bt, float)\n        self.assertGreater(bt, 0)\n        self.assertLess(bt, time.time())\n\n    @unittest.skipIf(CI_TESTING and not psutil.users(), \"unreliable on CI\")\n    def test_users(self):\n        users = psutil.users()\n        self.assertNotEqual(users, [])\n        for user in users:\n            assert user.name, user\n            self.assertIsInstance(user.name, str)\n            self.assertIsInstance(user.terminal, (str, type(None)))\n            if user.host is not None:\n                self.assertIsInstance(user.host, (str, type(None)))\n            user.terminal\n            user.host\n            assert user.started > 0.0, user\n            datetime.datetime.fromtimestamp(user.started)\n            if WINDOWS or OPENBSD:\n                self.assertIsNone(user.pid)\n            else:\n                psutil.Process(user.pid)\n\n    def test_test(self):\n        # test for psutil.test() function\n        stdout = sys.stdout\n        sys.stdout = DEVNULL\n        try:\n            psutil.test()\n        finally:\n            sys.stdout = stdout\n\n    def test_os_constants(self):\n        names = [\"POSIX\", \"WINDOWS\", \"LINUX\", \"MACOS\", \"FREEBSD\", \"OPENBSD\",\n                 \"NETBSD\", \"BSD\", \"SUNOS\"]\n        for name in names:\n            self.assertIsInstance(getattr(psutil, name), bool, msg=name)\n\n        if os.name == 'posix':\n            assert psutil.POSIX\n            assert not psutil.WINDOWS\n            names.remove(\"POSIX\")\n            if \"linux\" in sys.platform.lower():\n                assert psutil.LINUX\n                names.remove(\"LINUX\")\n            elif \"bsd\" in sys.platform.lower():\n                assert psutil.BSD\n                self.assertEqual([psutil.FREEBSD, psutil.OPENBSD,\n                                  psutil.NETBSD].count(True), 1)\n                names.remove(\"BSD\")\n                names.remove(\"FREEBSD\")\n                names.remove(\"OPENBSD\")\n                names.remove(\"NETBSD\")\n            elif \"sunos\" in sys.platform.lower() or \\\n                    \"solaris\" in sys.platform.lower():\n                assert psutil.SUNOS\n                names.remove(\"SUNOS\")\n            elif \"darwin\" in sys.platform.lower():\n                assert psutil.MACOS\n                names.remove(\"MACOS\")\n        else:\n            assert psutil.WINDOWS\n            assert not psutil.POSIX\n            names.remove(\"WINDOWS\")\n\n        # assert all other constants are set to False\n        for name in names:\n            self.assertIs(getattr(psutil, name), False, msg=name)\n\n\nclass TestMemoryAPIs(PsutilTestCase):\n\n    def test_virtual_memory(self):\n        mem = psutil.virtual_memory()\n        assert mem.total > 0, mem\n        assert mem.available > 0, mem\n        assert 0 <= mem.percent <= 100, mem\n        assert mem.used > 0, mem\n        assert mem.free >= 0, mem\n        for name in mem._fields:\n            value = getattr(mem, name)\n            if name != 'percent':\n                self.assertIsInstance(value, (int, long))\n            if name != 'total':\n                if not value >= 0:\n                    self.fail(\"%r < 0 (%s)\" % (name, value))\n                if value > mem.total:\n                    self.fail(\"%r > total (total=%s, %s=%s)\"\n                              % (name, mem.total, name, value))\n\n    def test_swap_memory(self):\n        mem = psutil.swap_memory()\n        self.assertEqual(\n            mem._fields, ('total', 'used', 'free', 'percent', 'sin', 'sout'))\n\n        assert mem.total >= 0, mem\n        assert mem.used >= 0, mem\n        if mem.total > 0:\n            # likely a system with no swap partition\n            assert mem.free > 0, mem\n        else:\n            assert mem.free == 0, mem\n        assert 0 <= mem.percent <= 100, mem\n        assert mem.sin >= 0, mem\n        assert mem.sout >= 0, mem\n\n\nclass TestCpuAPIs(PsutilTestCase):\n\n    def test_cpu_count_logical(self):\n        logical = psutil.cpu_count()\n        self.assertIsNotNone(logical)\n        self.assertEqual(logical, len(psutil.cpu_times(percpu=True)))\n        self.assertGreaterEqual(logical, 1)\n        #\n        if os.path.exists(\"/proc/cpuinfo\"):\n            with open(\"/proc/cpuinfo\") as fd:\n                cpuinfo_data = fd.read()\n            if \"physical id\" not in cpuinfo_data:\n                raise unittest.SkipTest(\"cpuinfo doesn't include physical id\")\n\n    def test_cpu_count_physical(self):\n        logical = psutil.cpu_count()\n        physical = psutil.cpu_count(logical=False)\n        if physical is None:\n            raise self.skipTest(\"physical cpu_count() is None\")\n        if WINDOWS and sys.getwindowsversion()[:2] <= (6, 1):  # <= Vista\n            self.assertIsNone(physical)\n        else:\n            self.assertGreaterEqual(physical, 1)\n            self.assertGreaterEqual(logical, physical)\n\n    def test_cpu_count_none(self):\n        # https://github.com/giampaolo/psutil/issues/1085\n        for val in (-1, 0, None):\n            with mock.patch('psutil._psplatform.cpu_count_logical',\n                            return_value=val) as m:\n                self.assertIsNone(psutil.cpu_count())\n                assert m.called\n            with mock.patch('psutil._psplatform.cpu_count_physical',\n                            return_value=val) as m:\n                self.assertIsNone(psutil.cpu_count(logical=False))\n                assert m.called\n\n    def test_cpu_times(self):\n        # Check type, value >= 0, str().\n        total = 0\n        times = psutil.cpu_times()\n        sum(times)\n        for cp_time in times:\n            self.assertIsInstance(cp_time, float)\n            self.assertGreaterEqual(cp_time, 0.0)\n            total += cp_time\n        self.assertEqual(total, sum(times))\n        str(times)\n        # CPU times are always supposed to increase over time\n        # or at least remain the same and that's because time\n        # cannot go backwards.\n        # Surprisingly sometimes this might not be the case (at\n        # least on Windows and Linux), see:\n        # https://github.com/giampaolo/psutil/issues/392\n        # https://github.com/giampaolo/psutil/issues/645\n        # if not WINDOWS:\n        #     last = psutil.cpu_times()\n        #     for x in range(100):\n        #         new = psutil.cpu_times()\n        #         for field in new._fields:\n        #             new_t = getattr(new, field)\n        #             last_t = getattr(last, field)\n        #             self.assertGreaterEqual(new_t, last_t,\n        #                                     msg=\"%s %s\" % (new_t, last_t))\n        #         last = new\n\n    def test_cpu_times_time_increases(self):\n        # Make sure time increases between calls.\n        t1 = sum(psutil.cpu_times())\n        stop_at = time.time() + GLOBAL_TIMEOUT\n        while time.time() < stop_at:\n            t2 = sum(psutil.cpu_times())\n            if t2 > t1:\n                return\n        self.fail(\"time remained the same\")\n\n    def test_per_cpu_times(self):\n        # Check type, value >= 0, str().\n        for times in psutil.cpu_times(percpu=True):\n            total = 0\n            sum(times)\n            for cp_time in times:\n                self.assertIsInstance(cp_time, float)\n                self.assertGreaterEqual(cp_time, 0.0)\n                total += cp_time\n            self.assertEqual(total, sum(times))\n            str(times)\n        self.assertEqual(len(psutil.cpu_times(percpu=True)[0]),\n                         len(psutil.cpu_times(percpu=False)))\n\n        # Note: in theory CPU times are always supposed to increase over\n        # time or remain the same but never go backwards. In practice\n        # sometimes this is not the case.\n        # This issue seemd to be afflict Windows:\n        # https://github.com/giampaolo/psutil/issues/392\n        # ...but it turns out also Linux (rarely) behaves the same.\n        # last = psutil.cpu_times(percpu=True)\n        # for x in range(100):\n        #     new = psutil.cpu_times(percpu=True)\n        #     for index in range(len(new)):\n        #         newcpu = new[index]\n        #         lastcpu = last[index]\n        #         for field in newcpu._fields:\n        #             new_t = getattr(newcpu, field)\n        #             last_t = getattr(lastcpu, field)\n        #             self.assertGreaterEqual(\n        #                 new_t, last_t, msg=\"%s %s\" % (lastcpu, newcpu))\n        #     last = new\n\n    def test_per_cpu_times_2(self):\n        # Simulate some work load then make sure time have increased\n        # between calls.\n        tot1 = psutil.cpu_times(percpu=True)\n        giveup_at = time.time() + GLOBAL_TIMEOUT\n        while True:\n            if time.time() >= giveup_at:\n                return self.fail(\"timeout\")\n            tot2 = psutil.cpu_times(percpu=True)\n            for t1, t2 in zip(tot1, tot2):\n                t1, t2 = psutil._cpu_busy_time(t1), psutil._cpu_busy_time(t2)\n                difference = t2 - t1\n                if difference >= 0.05:\n                    return\n\n    def test_cpu_times_comparison(self):\n        # Make sure the sum of all per cpu times is almost equal to\n        # base \"one cpu\" times.\n        base = psutil.cpu_times()\n        per_cpu = psutil.cpu_times(percpu=True)\n        summed_values = base._make([sum(num) for num in zip(*per_cpu)])\n        for field in base._fields:\n            self.assertAlmostEqual(\n                getattr(base, field), getattr(summed_values, field), delta=1)\n\n    def _test_cpu_percent(self, percent, last_ret, new_ret):\n        try:\n            self.assertIsInstance(percent, float)\n            self.assertGreaterEqual(percent, 0.0)\n            self.assertIsNot(percent, -0.0)\n            self.assertLessEqual(percent, 100.0 * psutil.cpu_count())\n        except AssertionError as err:\n            raise AssertionError(\"\\n%s\\nlast=%s\\nnew=%s\" % (\n                err, pprint.pformat(last_ret), pprint.pformat(new_ret)))\n\n    def test_cpu_percent(self):\n        last = psutil.cpu_percent(interval=0.001)\n        for x in range(100):\n            new = psutil.cpu_percent(interval=None)\n            self._test_cpu_percent(new, last, new)\n            last = new\n        with self.assertRaises(ValueError):\n            psutil.cpu_percent(interval=-1)\n\n    def test_per_cpu_percent(self):\n        last = psutil.cpu_percent(interval=0.001, percpu=True)\n        self.assertEqual(len(last), psutil.cpu_count())\n        for x in range(100):\n            new = psutil.cpu_percent(interval=None, percpu=True)\n            for percent in new:\n                self._test_cpu_percent(percent, last, new)\n            last = new\n        with self.assertRaises(ValueError):\n            psutil.cpu_percent(interval=-1, percpu=True)\n\n    def test_cpu_times_percent(self):\n        last = psutil.cpu_times_percent(interval=0.001)\n        for x in range(100):\n            new = psutil.cpu_times_percent(interval=None)\n            for percent in new:\n                self._test_cpu_percent(percent, last, new)\n            self._test_cpu_percent(sum(new), last, new)\n            last = new\n        with self.assertRaises(ValueError):\n            psutil.cpu_times_percent(interval=-1)\n\n    def test_per_cpu_times_percent(self):\n        last = psutil.cpu_times_percent(interval=0.001, percpu=True)\n        self.assertEqual(len(last), psutil.cpu_count())\n        for x in range(100):\n            new = psutil.cpu_times_percent(interval=None, percpu=True)\n            for cpu in new:\n                for percent in cpu:\n                    self._test_cpu_percent(percent, last, new)\n                self._test_cpu_percent(sum(cpu), last, new)\n            last = new\n\n    def test_per_cpu_times_percent_negative(self):\n        # see: https://github.com/giampaolo/psutil/issues/645\n        psutil.cpu_times_percent(percpu=True)\n        zero_times = [x._make([0 for x in range(len(x._fields))])\n                      for x in psutil.cpu_times(percpu=True)]\n        with mock.patch('psutil.cpu_times', return_value=zero_times):\n            for cpu in psutil.cpu_times_percent(percpu=True):\n                for percent in cpu:\n                    self._test_cpu_percent(percent, None, None)\n\n    def test_cpu_stats(self):\n        # Tested more extensively in per-platform test modules.\n        infos = psutil.cpu_stats()\n        self.assertEqual(\n            infos._fields,\n            ('ctx_switches', 'interrupts', 'soft_interrupts', 'syscalls'))\n        for name in infos._fields:\n            value = getattr(infos, name)\n            self.assertGreaterEqual(value, 0)\n            # on AIX, ctx_switches is always 0\n            if not AIX and name in ('ctx_switches', 'interrupts'):\n                self.assertGreater(value, 0)\n\n    @unittest.skipIf(not HAS_CPU_FREQ, \"not suported\")\n    def test_cpu_freq(self):\n        def check_ls(ls):\n            for nt in ls:\n                self.assertEqual(nt._fields, ('current', 'min', 'max'))\n                if nt.max != 0.0:\n                    self.assertLessEqual(nt.current, nt.max)\n                for name in nt._fields:\n                    value = getattr(nt, name)\n                    self.assertIsInstance(value, (int, long, float))\n                    self.assertGreaterEqual(value, 0)\n\n        ls = psutil.cpu_freq(percpu=True)\n        if FREEBSD and not ls:\n            raise self.skipTest(\"returns empty list on FreeBSD\")\n\n        assert ls, ls\n        check_ls([psutil.cpu_freq(percpu=False)])\n\n        if LINUX:\n            self.assertEqual(len(ls), psutil.cpu_count())\n\n    @unittest.skipIf(not HAS_GETLOADAVG, \"not supported\")\n    def test_getloadavg(self):\n        loadavg = psutil.getloadavg()\n        self.assertEqual(len(loadavg), 3)\n        for load in loadavg:\n            self.assertIsInstance(load, float)\n            self.assertGreaterEqual(load, 0.0)\n\n\nclass TestDiskAPIs(PsutilTestCase):\n\n    @unittest.skipIf(PYPY and not IS_64BIT, \"unreliable on PYPY32 + 32BIT\")\n    def test_disk_usage(self):\n        usage = psutil.disk_usage(os.getcwd())\n        self.assertEqual(usage._fields, ('total', 'used', 'free', 'percent'))\n\n        assert usage.total > 0, usage\n        assert usage.used > 0, usage\n        assert usage.free > 0, usage\n        assert usage.total > usage.used, usage\n        assert usage.total > usage.free, usage\n        assert 0 <= usage.percent <= 100, usage.percent\n        if hasattr(shutil, 'disk_usage'):\n            # py >= 3.3, see: http://bugs.python.org/issue12442\n            shutil_usage = shutil.disk_usage(os.getcwd())\n            tolerance = 5 * 1024 * 1024  # 5MB\n            self.assertEqual(usage.total, shutil_usage.total)\n            self.assertAlmostEqual(usage.free, shutil_usage.free,\n                                   delta=tolerance)\n            self.assertAlmostEqual(usage.used, shutil_usage.used,\n                                   delta=tolerance)\n\n        # if path does not exist OSError ENOENT is expected across\n        # all platforms\n        fname = self.get_testfn()\n        with self.assertRaises(FileNotFoundError):\n            psutil.disk_usage(fname)\n\n    @unittest.skipIf(not ASCII_FS, \"not an ASCII fs\")\n    def test_disk_usage_unicode(self):\n        # See: https://github.com/giampaolo/psutil/issues/416\n        with self.assertRaises(UnicodeEncodeError):\n            psutil.disk_usage(UNICODE_SUFFIX)\n\n    def test_disk_usage_bytes(self):\n        psutil.disk_usage(b'.')\n\n    def test_disk_partitions(self):\n        def check_ntuple(nt):\n            self.assertIsInstance(nt.device, str)\n            self.assertIsInstance(nt.mountpoint, str)\n            self.assertIsInstance(nt.fstype, str)\n            self.assertIsInstance(nt.opts, str)\n            self.assertIsInstance(nt.maxfile, (int, type(None)))\n            self.assertIsInstance(nt.maxpath, (int, type(None)))\n            if nt.maxfile is not None and not GITHUB_ACTIONS:\n                self.assertGreater(nt.maxfile, 0)\n            if nt.maxpath is not None:\n                self.assertGreater(nt.maxpath, 0)\n\n        # all = False\n        ls = psutil.disk_partitions(all=False)\n        self.assertTrue(ls, msg=ls)\n        for disk in ls:\n            check_ntuple(disk)\n            if WINDOWS and 'cdrom' in disk.opts:\n                continue\n            if not POSIX:\n                assert os.path.exists(disk.device), disk\n            else:\n                # we cannot make any assumption about this, see:\n                # http://goo.gl/p9c43\n                disk.device\n            # on modern systems mount points can also be files\n            assert os.path.exists(disk.mountpoint), disk\n            assert disk.fstype, disk\n\n        # all = True\n        ls = psutil.disk_partitions(all=True)\n        self.assertTrue(ls, msg=ls)\n        for disk in psutil.disk_partitions(all=True):\n            check_ntuple(disk)\n            if not WINDOWS and disk.mountpoint:\n                try:\n                    os.stat(disk.mountpoint)\n                except OSError as err:\n                    if GITHUB_ACTIONS and MACOS and err.errno == errno.EIO:\n                        continue\n                    # http://mail.python.org/pipermail/python-dev/\n                    #     2012-June/120787.html\n                    if err.errno not in (errno.EPERM, errno.EACCES):\n                        raise\n                else:\n                    assert os.path.exists(disk.mountpoint), disk\n\n        # ---\n\n        def find_mount_point(path):\n            path = os.path.abspath(path)\n            while not os.path.ismount(path):\n                path = os.path.dirname(path)\n            return path.lower()\n\n        mount = find_mount_point(__file__)\n        mounts = [x.mountpoint.lower() for x in\n                  psutil.disk_partitions(all=True) if x.mountpoint]\n        self.assertIn(mount, mounts)\n\n    @unittest.skipIf(LINUX and not os.path.exists('/proc/diskstats'),\n                     '/proc/diskstats not available on this linux version')\n    @unittest.skipIf(CI_TESTING and not psutil.disk_io_counters(),\n                     \"unreliable on CI\")  # no visible disks\n    def test_disk_io_counters(self):\n        def check_ntuple(nt):\n            self.assertEqual(nt[0], nt.read_count)\n            self.assertEqual(nt[1], nt.write_count)\n            self.assertEqual(nt[2], nt.read_bytes)\n            self.assertEqual(nt[3], nt.write_bytes)\n            if not (OPENBSD or NETBSD):\n                self.assertEqual(nt[4], nt.read_time)\n                self.assertEqual(nt[5], nt.write_time)\n                if LINUX:\n                    self.assertEqual(nt[6], nt.read_merged_count)\n                    self.assertEqual(nt[7], nt.write_merged_count)\n                    self.assertEqual(nt[8], nt.busy_time)\n                elif FREEBSD:\n                    self.assertEqual(nt[6], nt.busy_time)\n            for name in nt._fields:\n                assert getattr(nt, name) >= 0, nt\n\n        ret = psutil.disk_io_counters(perdisk=False)\n        assert ret is not None, \"no disks on this system?\"\n        check_ntuple(ret)\n        ret = psutil.disk_io_counters(perdisk=True)\n        # make sure there are no duplicates\n        self.assertEqual(len(ret), len(set(ret)))\n        for key in ret:\n            assert key, key\n            check_ntuple(ret[key])\n\n    def test_disk_io_counters_no_disks(self):\n        # Emulate a case where no disks are installed, see:\n        # https://github.com/giampaolo/psutil/issues/1062\n        with mock.patch('psutil._psplatform.disk_io_counters',\n                        return_value={}) as m:\n            self.assertIsNone(psutil.disk_io_counters(perdisk=False))\n            self.assertEqual(psutil.disk_io_counters(perdisk=True), {})\n            assert m.called\n\n\nclass TestNetAPIs(PsutilTestCase):\n\n    @unittest.skipIf(not HAS_NET_IO_COUNTERS, 'not supported')\n    def test_net_io_counters(self):\n        def check_ntuple(nt):\n            self.assertEqual(nt[0], nt.bytes_sent)\n            self.assertEqual(nt[1], nt.bytes_recv)\n            self.assertEqual(nt[2], nt.packets_sent)\n            self.assertEqual(nt[3], nt.packets_recv)\n            self.assertEqual(nt[4], nt.errin)\n            self.assertEqual(nt[5], nt.errout)\n            self.assertEqual(nt[6], nt.dropin)\n            self.assertEqual(nt[7], nt.dropout)\n            assert nt.bytes_sent >= 0, nt\n            assert nt.bytes_recv >= 0, nt\n            assert nt.packets_sent >= 0, nt\n            assert nt.packets_recv >= 0, nt\n            assert nt.errin >= 0, nt\n            assert nt.errout >= 0, nt\n            assert nt.dropin >= 0, nt\n            assert nt.dropout >= 0, nt\n\n        ret = psutil.net_io_counters(pernic=False)\n        check_ntuple(ret)\n        ret = psutil.net_io_counters(pernic=True)\n        self.assertNotEqual(ret, [])\n        for key in ret:\n            self.assertTrue(key)\n            self.assertIsInstance(key, str)\n            check_ntuple(ret[key])\n\n    @unittest.skipIf(not HAS_NET_IO_COUNTERS, 'not supported')\n    def test_net_io_counters_no_nics(self):\n        # Emulate a case where no NICs are installed, see:\n        # https://github.com/giampaolo/psutil/issues/1062\n        with mock.patch('psutil._psplatform.net_io_counters',\n                        return_value={}) as m:\n            self.assertIsNone(psutil.net_io_counters(pernic=False))\n            self.assertEqual(psutil.net_io_counters(pernic=True), {})\n            assert m.called\n\n    def test_net_if_addrs(self):\n        nics = psutil.net_if_addrs()\n        assert nics, nics\n\n        nic_stats = psutil.net_if_stats()\n\n        # Not reliable on all platforms (net_if_addrs() reports more\n        # interfaces).\n        # self.assertEqual(sorted(nics.keys()),\n        #                  sorted(psutil.net_io_counters(pernic=True).keys()))\n\n        families = set([socket.AF_INET, socket.AF_INET6, psutil.AF_LINK])\n        for nic, addrs in nics.items():\n            self.assertIsInstance(nic, str)\n            self.assertEqual(len(set(addrs)), len(addrs))\n            for addr in addrs:\n                self.assertIsInstance(addr.family, int)\n                self.assertIsInstance(addr.address, str)\n                self.assertIsInstance(addr.netmask, (str, type(None)))\n                self.assertIsInstance(addr.broadcast, (str, type(None)))\n                self.assertIn(addr.family, families)\n                if sys.version_info >= (3, 4) and not PYPY:\n                    self.assertIsInstance(addr.family, enum.IntEnum)\n                if nic_stats[nic].isup:\n                    # Do not test binding to addresses of interfaces\n                    # that are down\n                    if addr.family == socket.AF_INET:\n                        s = socket.socket(addr.family)\n                        with contextlib.closing(s):\n                            s.bind((addr.address, 0))\n                    elif addr.family == socket.AF_INET6:\n                        info = socket.getaddrinfo(\n                            addr.address, 0, socket.AF_INET6,\n                            socket.SOCK_STREAM, 0, socket.AI_PASSIVE)[0]\n                        af, socktype, proto, canonname, sa = info\n                        s = socket.socket(af, socktype, proto)\n                        with contextlib.closing(s):\n                            s.bind(sa)\n                for ip in (addr.address, addr.netmask, addr.broadcast,\n                           addr.ptp):\n                    if ip is not None:\n                        # TODO: skip AF_INET6 for now because I get:\n                        # AddressValueError: Only hex digits permitted in\n                        # u'c6f3%lxcbr0' in u'fe80::c8e0:fff:fe54:c6f3%lxcbr0'\n                        if addr.family != socket.AF_INET6:\n                            check_net_address(ip, addr.family)\n                # broadcast and ptp addresses are mutually exclusive\n                if addr.broadcast:\n                    self.assertIsNone(addr.ptp)\n                elif addr.ptp:\n                    self.assertIsNone(addr.broadcast)\n\n        if BSD or MACOS or SUNOS:\n            if hasattr(socket, \"AF_LINK\"):\n                self.assertEqual(psutil.AF_LINK, socket.AF_LINK)\n        elif LINUX:\n            self.assertEqual(psutil.AF_LINK, socket.AF_PACKET)\n        elif WINDOWS:\n            self.assertEqual(psutil.AF_LINK, -1)\n\n    def test_net_if_addrs_mac_null_bytes(self):\n        # Simulate that the underlying C function returns an incomplete\n        # MAC address. psutil is supposed to fill it with null bytes.\n        # https://github.com/giampaolo/psutil/issues/786\n        if POSIX:\n            ret = [('em1', psutil.AF_LINK, '06:3d:29', None, None, None)]\n        else:\n            ret = [('em1', -1, '06-3d-29', None, None, None)]\n        with mock.patch('psutil._psplatform.net_if_addrs',\n                        return_value=ret) as m:\n            addr = psutil.net_if_addrs()['em1'][0]\n            assert m.called\n            if POSIX:\n                self.assertEqual(addr.address, '06:3d:29:00:00:00')\n            else:\n                self.assertEqual(addr.address, '06-3d-29-00-00-00')\n\n    def test_net_if_stats(self):\n        nics = psutil.net_if_stats()\n        assert nics, nics\n        all_duplexes = (psutil.NIC_DUPLEX_FULL,\n                        psutil.NIC_DUPLEX_HALF,\n                        psutil.NIC_DUPLEX_UNKNOWN)\n        for name, stats in nics.items():\n            self.assertIsInstance(name, str)\n            isup, duplex, speed, mtu = stats\n            self.assertIsInstance(isup, bool)\n            self.assertIn(duplex, all_duplexes)\n            self.assertIn(duplex, all_duplexes)\n            self.assertGreaterEqual(speed, 0)\n            self.assertGreaterEqual(mtu, 0)\n\n    @unittest.skipIf(not (LINUX or BSD or MACOS),\n                     \"LINUX or BSD or MACOS specific\")\n    def test_net_if_stats_enodev(self):\n        # See: https://github.com/giampaolo/psutil/issues/1279\n        with mock.patch('psutil._psutil_posix.net_if_mtu',\n                        side_effect=OSError(errno.ENODEV, \"\")) as m:\n            ret = psutil.net_if_stats()\n            self.assertEqual(ret, {})\n            assert m.called\n\n\nclass TestSensorsAPIs(PsutilTestCase):\n\n    @unittest.skipIf(not HAS_SENSORS_TEMPERATURES, \"not supported\")\n    def test_sensors_temperatures(self):\n        temps = psutil.sensors_temperatures()\n        for name, entries in temps.items():\n            self.assertIsInstance(name, str)\n            for entry in entries:\n                self.assertIsInstance(entry.label, str)\n                if entry.current is not None:\n                    self.assertGreaterEqual(entry.current, 0)\n                if entry.high is not None:\n                    self.assertGreaterEqual(entry.high, 0)\n                if entry.critical is not None:\n                    self.assertGreaterEqual(entry.critical, 0)\n\n    @unittest.skipIf(not HAS_SENSORS_TEMPERATURES, \"not supported\")\n    def test_sensors_temperatures_fahreneit(self):\n        d = {'coretemp': [('label', 50.0, 60.0, 70.0)]}\n        with mock.patch(\"psutil._psplatform.sensors_temperatures\",\n                        return_value=d) as m:\n            temps = psutil.sensors_temperatures(\n                fahrenheit=True)['coretemp'][0]\n            assert m.called\n            self.assertEqual(temps.current, 122.0)\n            self.assertEqual(temps.high, 140.0)\n            self.assertEqual(temps.critical, 158.0)\n\n    @unittest.skipIf(not HAS_SENSORS_BATTERY, \"not supported\")\n    @unittest.skipIf(not HAS_BATTERY, \"no battery\")\n    def test_sensors_battery(self):\n        ret = psutil.sensors_battery()\n        self.assertGreaterEqual(ret.percent, 0)\n        self.assertLessEqual(ret.percent, 100)\n        if ret.secsleft not in (psutil.POWER_TIME_UNKNOWN,\n                                psutil.POWER_TIME_UNLIMITED):\n            self.assertGreaterEqual(ret.secsleft, 0)\n        else:\n            if ret.secsleft == psutil.POWER_TIME_UNLIMITED:\n                self.assertTrue(ret.power_plugged)\n        self.assertIsInstance(ret.power_plugged, bool)\n\n    @unittest.skipIf(not HAS_SENSORS_FANS, \"not supported\")\n    def test_sensors_fans(self):\n        fans = psutil.sensors_fans()\n        for name, entries in fans.items():\n            self.assertIsInstance(name, str)\n            for entry in entries:\n                self.assertIsInstance(entry.label, str)\n                self.assertIsInstance(entry.current, (int, long))\n                self.assertGreaterEqual(entry.current, 0)\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n    run_from_name(__file__)\n"
                    },
                    "test_testutils": {
                        "type": "module",
                        "extension": "py",
                        "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"\nTests for testing utils (psutil.tests namespace).\n\"\"\"\n\nimport collections\nimport contextlib\nimport errno\nimport os\nimport socket\nimport stat\nimport subprocess\n\nfrom psutil import FREEBSD\nfrom psutil import NETBSD\nfrom psutil import POSIX\nfrom psutil._common import open_binary\nfrom psutil._common import open_text\nfrom psutil._common import supports_ipv6\nfrom psutil.tests import bind_socket\nfrom psutil.tests import bind_unix_socket\nfrom psutil.tests import call_until\nfrom psutil.tests import chdir\nfrom psutil.tests import CI_TESTING\nfrom psutil.tests import create_sockets\nfrom psutil.tests import get_free_port\nfrom psutil.tests import HAS_CONNECTIONS_UNIX\nfrom psutil.tests import is_namedtuple\nfrom psutil.tests import mock\nfrom psutil.tests import process_namespace\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import PYTHON_EXE\nfrom psutil.tests import reap_children\nfrom psutil.tests import retry\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_mkdir\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import serialrun\nfrom psutil.tests import system_namespace\nfrom psutil.tests import tcp_socketpair\nfrom psutil.tests import terminate\nfrom psutil.tests import TestMemoryLeak\nfrom psutil.tests import unittest\nfrom psutil.tests import unix_socketpair\nfrom psutil.tests import wait_for_file\nfrom psutil.tests import wait_for_pid\nimport psutil\nimport psutil.tests\n\n# ===================================================================\n# --- Unit tests for test utilities.\n# ===================================================================\n\n\nclass TestRetryDecorator(PsutilTestCase):\n\n    @mock.patch('time.sleep')\n    def test_retry_success(self, sleep):\n        # Fail 3 times out of 5; make sure the decorated fun returns.\n\n        @retry(retries=5, interval=1, logfun=None)\n        def foo():\n            while queue:\n                queue.pop()\n                1 / 0\n            return 1\n\n        queue = list(range(3))\n        self.assertEqual(foo(), 1)\n        self.assertEqual(sleep.call_count, 3)\n\n    @mock.patch('time.sleep')\n    def test_retry_failure(self, sleep):\n        # Fail 6 times out of 5; th function is supposed to raise exc.\n        @retry(retries=5, interval=1, logfun=None)\n        def foo():\n            while queue:\n                queue.pop()\n                1 / 0\n            return 1\n\n        queue = list(range(6))\n        self.assertRaises(ZeroDivisionError, foo)\n        self.assertEqual(sleep.call_count, 5)\n\n    @mock.patch('time.sleep')\n    def test_exception_arg(self, sleep):\n        @retry(exception=ValueError, interval=1)\n        def foo():\n            raise TypeError\n\n        self.assertRaises(TypeError, foo)\n        self.assertEqual(sleep.call_count, 0)\n\n    @mock.patch('time.sleep')\n    def test_no_interval_arg(self, sleep):\n        # if interval is not specified sleep is not supposed to be called\n\n        @retry(retries=5, interval=None, logfun=None)\n        def foo():\n            1 / 0\n\n        self.assertRaises(ZeroDivisionError, foo)\n        self.assertEqual(sleep.call_count, 0)\n\n    @mock.patch('time.sleep')\n    def test_retries_arg(self, sleep):\n\n        @retry(retries=5, interval=1, logfun=None)\n        def foo():\n            1 / 0\n\n        self.assertRaises(ZeroDivisionError, foo)\n        self.assertEqual(sleep.call_count, 5)\n\n    @mock.patch('time.sleep')\n    def test_retries_and_timeout_args(self, sleep):\n        self.assertRaises(ValueError, retry, retries=5, timeout=1)\n\n\nclass TestSyncTestUtils(PsutilTestCase):\n\n    def test_wait_for_pid(self):\n        wait_for_pid(os.getpid())\n        nopid = max(psutil.pids()) + 99999\n        with mock.patch('psutil.tests.retry.__iter__', return_value=iter([0])):\n            self.assertRaises(psutil.NoSuchProcess, wait_for_pid, nopid)\n\n    def test_wait_for_file(self):\n        testfn = self.get_testfn()\n        with open(testfn, 'w') as f:\n            f.write('foo')\n        wait_for_file(testfn)\n        assert not os.path.exists(testfn)\n\n    def test_wait_for_file_empty(self):\n        testfn = self.get_testfn()\n        with open(testfn, 'w'):\n            pass\n        wait_for_file(testfn, empty=True)\n        assert not os.path.exists(testfn)\n\n    def test_wait_for_file_no_file(self):\n        testfn = self.get_testfn()\n        with mock.patch('psutil.tests.retry.__iter__', return_value=iter([0])):\n            self.assertRaises(IOError, wait_for_file, testfn)\n\n    def test_wait_for_file_no_delete(self):\n        testfn = self.get_testfn()\n        with open(testfn, 'w') as f:\n            f.write('foo')\n        wait_for_file(testfn, delete=False)\n        assert os.path.exists(testfn)\n\n    def test_call_until(self):\n        ret = call_until(lambda: 1, \"ret == 1\")\n        self.assertEqual(ret, 1)\n\n\nclass TestFSTestUtils(PsutilTestCase):\n\n    def test_open_text(self):\n        with open_text(__file__) as f:\n            self.assertEqual(f.mode, 'rt')\n\n    def test_open_binary(self):\n        with open_binary(__file__) as f:\n            self.assertEqual(f.mode, 'rb')\n\n    def test_safe_mkdir(self):\n        testfn = self.get_testfn()\n        safe_mkdir(testfn)\n        assert os.path.isdir(testfn)\n        safe_mkdir(testfn)\n        assert os.path.isdir(testfn)\n\n    def test_safe_rmpath(self):\n        # test file is removed\n        testfn = self.get_testfn()\n        open(testfn, 'w').close()\n        safe_rmpath(testfn)\n        assert not os.path.exists(testfn)\n        # test no exception if path does not exist\n        safe_rmpath(testfn)\n        # test dir is removed\n        os.mkdir(testfn)\n        safe_rmpath(testfn)\n        assert not os.path.exists(testfn)\n        # test other exceptions are raised\n        with mock.patch('psutil.tests.os.stat',\n                        side_effect=OSError(errno.EINVAL, \"\")) as m:\n            with self.assertRaises(OSError):\n                safe_rmpath(testfn)\n            assert m.called\n\n    def test_chdir(self):\n        testfn = self.get_testfn()\n        base = os.getcwd()\n        os.mkdir(testfn)\n        with chdir(testfn):\n            self.assertEqual(os.getcwd(), os.path.join(base, testfn))\n        self.assertEqual(os.getcwd(), base)\n\n\nclass TestProcessUtils(PsutilTestCase):\n\n    def test_reap_children(self):\n        subp = self.spawn_testproc()\n        p = psutil.Process(subp.pid)\n        assert p.is_running()\n        reap_children()\n        assert not p.is_running()\n        assert not psutil.tests._pids_started\n        assert not psutil.tests._subprocesses_started\n\n    def test_spawn_children_pair(self):\n        child, grandchild = self.spawn_children_pair()\n        self.assertNotEqual(child.pid, grandchild.pid)\n        assert child.is_running()\n        assert grandchild.is_running()\n        children = psutil.Process().children()\n        self.assertEqual(children, [child])\n        children = psutil.Process().children(recursive=True)\n        self.assertEqual(len(children), 2)\n        self.assertIn(child, children)\n        self.assertIn(grandchild, children)\n        self.assertEqual(child.ppid(), os.getpid())\n        self.assertEqual(grandchild.ppid(), child.pid)\n\n        terminate(child)\n        assert not child.is_running()\n        assert grandchild.is_running()\n\n        terminate(grandchild)\n        assert not grandchild.is_running()\n\n    @unittest.skipIf(not POSIX, \"POSIX only\")\n    def test_spawn_zombie(self):\n        parent, zombie = self.spawn_zombie()\n        self.assertEqual(zombie.status(), psutil.STATUS_ZOMBIE)\n\n    def test_terminate(self):\n        # by subprocess.Popen\n        p = self.spawn_testproc()\n        terminate(p)\n        self.assertProcessGone(p)\n        terminate(p)\n        # by psutil.Process\n        p = psutil.Process(self.spawn_testproc().pid)\n        terminate(p)\n        self.assertProcessGone(p)\n        terminate(p)\n        # by psutil.Popen\n        cmd = [PYTHON_EXE, \"-c\", \"import time; time.sleep(60);\"]\n        p = psutil.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        terminate(p)\n        self.assertProcessGone(p)\n        terminate(p)\n        # by PID\n        pid = self.spawn_testproc().pid\n        terminate(pid)\n        self.assertProcessGone(p)\n        terminate(pid)\n        # zombie\n        if POSIX:\n            parent, zombie = self.spawn_zombie()\n            terminate(parent)\n            terminate(zombie)\n            self.assertProcessGone(parent)\n            self.assertProcessGone(zombie)\n\n\nclass TestNetUtils(PsutilTestCase):\n\n    def bind_socket(self):\n        port = get_free_port()\n        with contextlib.closing(bind_socket(addr=('', port))) as s:\n            self.assertEqual(s.getsockname()[1], port)\n\n    @unittest.skipIf(not POSIX, \"POSIX only\")\n    def test_bind_unix_socket(self):\n        name = self.get_testfn()\n        sock = bind_unix_socket(name)\n        with contextlib.closing(sock):\n            self.assertEqual(sock.family, socket.AF_UNIX)\n            self.assertEqual(sock.type, socket.SOCK_STREAM)\n            self.assertEqual(sock.getsockname(), name)\n            assert os.path.exists(name)\n            assert stat.S_ISSOCK(os.stat(name).st_mode)\n        # UDP\n        name = self.get_testfn()\n        sock = bind_unix_socket(name, type=socket.SOCK_DGRAM)\n        with contextlib.closing(sock):\n            self.assertEqual(sock.type, socket.SOCK_DGRAM)\n\n    def tcp_tcp_socketpair(self):\n        addr = (\"127.0.0.1\", get_free_port())\n        server, client = tcp_socketpair(socket.AF_INET, addr=addr)\n        with contextlib.closing(server):\n            with contextlib.closing(client):\n                # Ensure they are connected and the positions are\n                # correct.\n                self.assertEqual(server.getsockname(), addr)\n                self.assertEqual(client.getpeername(), addr)\n                self.assertNotEqual(client.getsockname(), addr)\n\n    @unittest.skipIf(not POSIX, \"POSIX only\")\n    @unittest.skipIf(NETBSD or FREEBSD,\n                     \"/var/run/log UNIX socket opened by default\")\n    def test_unix_socketpair(self):\n        p = psutil.Process()\n        num_fds = p.num_fds()\n        assert not p.connections(kind='unix')\n        name = self.get_testfn()\n        server, client = unix_socketpair(name)\n        try:\n            assert os.path.exists(name)\n            assert stat.S_ISSOCK(os.stat(name).st_mode)\n            self.assertEqual(p.num_fds() - num_fds, 2)\n            self.assertEqual(len(p.connections(kind='unix')), 2)\n            self.assertEqual(server.getsockname(), name)\n            self.assertEqual(client.getpeername(), name)\n        finally:\n            client.close()\n            server.close()\n\n    def test_create_sockets(self):\n        with create_sockets() as socks:\n            fams = collections.defaultdict(int)\n            types = collections.defaultdict(int)\n            for s in socks:\n                fams[s.family] += 1\n                # work around http://bugs.python.org/issue30204\n                types[s.getsockopt(socket.SOL_SOCKET, socket.SO_TYPE)] += 1\n            self.assertGreaterEqual(fams[socket.AF_INET], 2)\n            if supports_ipv6():\n                self.assertGreaterEqual(fams[socket.AF_INET6], 2)\n            if POSIX and HAS_CONNECTIONS_UNIX:\n                self.assertGreaterEqual(fams[socket.AF_UNIX], 2)\n            self.assertGreaterEqual(types[socket.SOCK_STREAM], 2)\n            self.assertGreaterEqual(types[socket.SOCK_DGRAM], 2)\n\n\n@serialrun\nclass TestMemLeakClass(TestMemoryLeak):\n\n    def test_times(self):\n        def fun():\n            cnt['cnt'] += 1\n        cnt = {'cnt': 0}\n        self.execute(fun, times=10, warmup_times=15)\n        self.assertEqual(cnt['cnt'], 26)\n\n    def test_param_err(self):\n        self.assertRaises(ValueError, self.execute, lambda: 0, times=0)\n        self.assertRaises(ValueError, self.execute, lambda: 0, times=-1)\n        self.assertRaises(ValueError, self.execute, lambda: 0, warmup_times=-1)\n        self.assertRaises(ValueError, self.execute, lambda: 0, tolerance=-1)\n        self.assertRaises(ValueError, self.execute, lambda: 0, retries=-1)\n\n    @retry_on_failure()\n    @unittest.skipIf(CI_TESTING, \"skipped on CI\")\n    def test_leak_mem(self):\n        ls = []\n\n        def fun(ls=ls):\n            ls.append(\"x\" * 24 * 1024)\n\n        try:\n            # will consume around 3M in total\n            self.assertRaisesRegex(AssertionError, \"extra-mem\",\n                                   self.execute, fun, times=50)\n        finally:\n            del ls\n\n    def test_unclosed_files(self):\n        def fun():\n            f = open(__file__)\n            self.addCleanup(f.close)\n            box.append(f)\n\n        box = []\n        kind = \"fd\" if POSIX else \"handle\"\n        self.assertRaisesRegex(AssertionError, \"unclosed \" + kind,\n                               self.execute, fun)\n\n    def test_tolerance(self):\n        def fun():\n            ls.append(\"x\" * 24 * 1024)\n        ls = []\n        times = 100\n        self.execute(fun, times=times, warmup_times=0,\n                     tolerance=200 * 1024 * 1024)\n        self.assertEqual(len(ls), times + 1)\n\n    def test_execute_w_exc(self):\n        def fun():\n            1 / 0\n        self.execute_w_exc(ZeroDivisionError, fun)\n        with self.assertRaises(ZeroDivisionError):\n            self.execute_w_exc(OSError, fun)\n\n        def fun():\n            pass\n        with self.assertRaises(AssertionError):\n            self.execute_w_exc(ZeroDivisionError, fun)\n\n\nclass TestTestingUtils(PsutilTestCase):\n\n    def test_process_namespace(self):\n        p = psutil.Process()\n        ns = process_namespace(p)\n        ns.test()\n        fun = [x for x in ns.iter(ns.getters) if x[1] == 'ppid'][0][0]\n        self.assertEqual(fun(), p.ppid())\n\n    def test_system_namespace(self):\n        ns = system_namespace()\n        fun = [x for x in ns.iter(ns.getters) if x[1] == 'net_if_addrs'][0][0]\n        self.assertEqual(fun(), psutil.net_if_addrs())\n\n\nclass TestOtherUtils(PsutilTestCase):\n\n    def test_is_namedtuple(self):\n        assert is_namedtuple(collections.namedtuple('foo', 'a b c')(1, 2, 3))\n        assert not is_namedtuple(tuple())\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n    run_from_name(__file__)\n"
                    },
                    "test_unicode": {
                        "type": "module",
                        "extension": "py",
                        "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"\nNotes about unicode handling in psutil\n======================================\n\nStarting from version 5.3.0 psutil adds unicode support, see:\nhttps://github.com/giampaolo/psutil/issues/1040\nThe notes below apply to *any* API returning a string such as\nprocess exe(), cwd() or username():\n\n* all strings are encoded by using the OS filesystem encoding\n  (sys.getfilesystemencoding()) which varies depending on the platform\n  (e.g. \"UTF-8\" on macOS, \"mbcs\" on Win)\n* no API call is supposed to crash with UnicodeDecodeError\n* instead, in case of badly encoded data returned by the OS, the\n  following error handlers are used to replace the corrupted characters in\n  the string:\n    * Python 3: sys.getfilesystemencodeerrors() (PY 3.6+) or\n      \"surrogatescape\" on POSIX and \"replace\" on Windows\n    * Python 2: \"replace\"\n* on Python 2 all APIs return bytes (str type), never unicode\n* on Python 2, you can go back to unicode by doing:\n\n    >>> unicode(p.exe(), sys.getdefaultencoding(), errors=\"replace\")\n\nFor a detailed explanation of how psutil handles unicode see #1040.\n\nTests\n=====\n\nList of APIs returning or dealing with a string:\n('not tested' means they are not tested to deal with non-ASCII strings):\n\n* Process.cmdline()\n* Process.connections('unix')\n* Process.cwd()\n* Process.environ()\n* Process.exe()\n* Process.memory_maps()\n* Process.name()\n* Process.open_files()\n* Process.username()             (not tested)\n\n* disk_io_counters()             (not tested)\n* disk_partitions()              (not tested)\n* disk_usage(str)\n* net_connections('unix')\n* net_if_addrs()                 (not tested)\n* net_if_stats()                 (not tested)\n* net_io_counters()              (not tested)\n* sensors_fans()                 (not tested)\n* sensors_temperatures()         (not tested)\n* users()                        (not tested)\n\n* WindowsService.binpath()       (not tested)\n* WindowsService.description()   (not tested)\n* WindowsService.display_name()  (not tested)\n* WindowsService.name()          (not tested)\n* WindowsService.status()        (not tested)\n* WindowsService.username()      (not tested)\n\nIn here we create a unicode path with a funky non-ASCII name and (where\npossible) make psutil return it back (e.g. on name(), exe(), open_files(),\netc.) and make sure that:\n\n* psutil never crashes with UnicodeDecodeError\n* the returned path matches\n\"\"\"\n\nimport os\nimport shutil\nimport traceback\nimport warnings\nfrom contextlib import closing\n\nfrom psutil import BSD\nfrom psutil import OPENBSD\nfrom psutil import POSIX\nfrom psutil import WINDOWS\nfrom psutil._compat import PY3\nfrom psutil._compat import u\nfrom psutil.tests import APPVEYOR\nfrom psutil.tests import ASCII_FS\nfrom psutil.tests import bind_unix_socket\nfrom psutil.tests import chdir\nfrom psutil.tests import CI_TESTING\nfrom psutil.tests import copyload_shared_lib\nfrom psutil.tests import create_exe\nfrom psutil.tests import get_testfn\nfrom psutil.tests import HAS_CONNECTIONS_UNIX\nfrom psutil.tests import HAS_ENVIRON\nfrom psutil.tests import HAS_MEMORY_MAPS\nfrom psutil.tests import INVALID_UNICODE_SUFFIX\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import PYPY\nfrom psutil.tests import safe_mkdir\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import serialrun\nfrom psutil.tests import skip_on_access_denied\nfrom psutil.tests import spawn_testproc\nfrom psutil.tests import terminate\nfrom psutil.tests import TESTFN_PREFIX\nfrom psutil.tests import UNICODE_SUFFIX\nfrom psutil.tests import unittest\nimport psutil\n\n\nif APPVEYOR:\n    def safe_rmpath(path):  # NOQA\n        # TODO - this is quite random and I'm not sure why it happens,\n        # nor I can reproduce it locally:\n        # https://ci.appveyor.com/project/giampaolo/psutil/build/job/\n        #     jiq2cgd6stsbtn60\n        # safe_rmpath() happens after reap_children() so this is weird\n        # Perhaps wait_procs() on Windows is broken? Maybe because\n        # of STILL_ACTIVE?\n        # https://github.com/giampaolo/psutil/blob/\n        #     68c7a70728a31d8b8b58f4be6c4c0baa2f449eda/psutil/arch/\n        #     windows/process_info.c#L146\n        from psutil.tests import safe_rmpath as rm\n        try:\n            return rm(path)\n        except WindowsError:\n            traceback.print_exc()\n\n\ndef try_unicode(suffix):\n    \"\"\"Return True if both the fs and the subprocess module can\n    deal with a unicode file name.\n    \"\"\"\n    sproc = None\n    testfn = get_testfn(suffix=suffix)\n    try:\n        safe_rmpath(testfn)\n        create_exe(testfn)\n        sproc = spawn_testproc(cmd=[testfn])\n        shutil.copyfile(testfn, testfn + '-2')\n        safe_rmpath(testfn + '-2')\n    except (UnicodeEncodeError, IOError):\n        return False\n    else:\n        return True\n    finally:\n        if sproc is not None:\n            terminate(sproc)\n        safe_rmpath(testfn)\n\n\n# ===================================================================\n# FS APIs\n# ===================================================================\n\n\nclass BaseUnicodeTest(PsutilTestCase):\n    funky_suffix = None\n\n    def setUp(self):\n        if self.funky_suffix is not None:\n            if not try_unicode(self.funky_suffix):\n                raise self.skipTest(\"can't handle unicode str\")\n\n\n@serialrun\n@unittest.skipIf(ASCII_FS, \"ASCII fs\")\n@unittest.skipIf(PYPY and not PY3, \"too much trouble on PYPY2\")\nclass TestFSAPIs(BaseUnicodeTest):\n    \"\"\"Test FS APIs with a funky, valid, UTF8 path name.\"\"\"\n\n    funky_suffix = UNICODE_SUFFIX\n\n    @classmethod\n    def setUpClass(cls):\n        cls.funky_name = get_testfn(suffix=cls.funky_suffix)\n        create_exe(cls.funky_name)\n\n    @classmethod\n    def tearDownClass(cls):\n        safe_rmpath(cls.funky_name)\n\n    def expect_exact_path_match(self):\n        # Do not expect psutil to correctly handle unicode paths on\n        # Python 2 if os.listdir() is not able either.\n        here = '.' if isinstance(self.funky_name, str) else u('.')\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            return self.funky_name in os.listdir(here)\n\n    # ---\n\n    def test_proc_exe(self):\n        subp = self.spawn_testproc(cmd=[self.funky_name])\n        p = psutil.Process(subp.pid)\n        exe = p.exe()\n        self.assertIsInstance(exe, str)\n        if self.expect_exact_path_match():\n            self.assertEqual(os.path.normcase(exe),\n                             os.path.normcase(self.funky_name))\n\n    def test_proc_name(self):\n        subp = self.spawn_testproc(cmd=[self.funky_name])\n        name = psutil.Process(subp.pid).name()\n        self.assertIsInstance(name, str)\n        if self.expect_exact_path_match():\n            self.assertEqual(name, os.path.basename(self.funky_name))\n\n    def test_proc_cmdline(self):\n        subp = self.spawn_testproc(cmd=[self.funky_name])\n        p = psutil.Process(subp.pid)\n        cmdline = p.cmdline()\n        for part in cmdline:\n            self.assertIsInstance(part, str)\n        if self.expect_exact_path_match():\n            self.assertEqual(cmdline, [self.funky_name])\n\n    def test_proc_cwd(self):\n        dname = self.funky_name + \"2\"\n        self.addCleanup(safe_rmpath, dname)\n        safe_mkdir(dname)\n        with chdir(dname):\n            p = psutil.Process()\n            cwd = p.cwd()\n        self.assertIsInstance(p.cwd(), str)\n        if self.expect_exact_path_match():\n            self.assertEqual(cwd, dname)\n\n    @unittest.skipIf(PYPY and WINDOWS, \"fails on PYPY + WINDOWS\")\n    def test_proc_open_files(self):\n        p = psutil.Process()\n        start = set(p.open_files())\n        with open(self.funky_name, 'rb'):\n            new = set(p.open_files())\n        path = (new - start).pop().path\n        self.assertIsInstance(path, str)\n        if BSD and not path:\n            # XXX - see https://github.com/giampaolo/psutil/issues/595\n            return self.skipTest(\"open_files on BSD is broken\")\n        if self.expect_exact_path_match():\n            self.assertEqual(os.path.normcase(path),\n                             os.path.normcase(self.funky_name))\n\n    @unittest.skipIf(not POSIX, \"POSIX only\")\n    def test_proc_connections(self):\n        name = self.get_testfn(suffix=self.funky_suffix)\n        try:\n            sock = bind_unix_socket(name)\n        except UnicodeEncodeError:\n            if PY3:\n                raise\n            else:\n                raise unittest.SkipTest(\"not supported\")\n        with closing(sock):\n            conn = psutil.Process().connections('unix')[0]\n            self.assertIsInstance(conn.laddr, str)\n            # AF_UNIX addr not set on OpenBSD\n            if not OPENBSD:  # XXX\n                self.assertEqual(conn.laddr, name)\n\n    @unittest.skipIf(not POSIX, \"POSIX only\")\n    @unittest.skipIf(not HAS_CONNECTIONS_UNIX, \"can't list UNIX sockets\")\n    @skip_on_access_denied()\n    def test_net_connections(self):\n        def find_sock(cons):\n            for conn in cons:\n                if os.path.basename(conn.laddr).startswith(TESTFN_PREFIX):\n                    return conn\n            raise ValueError(\"connection not found\")\n\n        name = self.get_testfn(suffix=self.funky_suffix)\n        try:\n            sock = bind_unix_socket(name)\n        except UnicodeEncodeError:\n            if PY3:\n                raise\n            else:\n                raise unittest.SkipTest(\"not supported\")\n        with closing(sock):\n            cons = psutil.net_connections(kind='unix')\n            # AF_UNIX addr not set on OpenBSD\n            if not OPENBSD:\n                conn = find_sock(cons)\n                self.assertIsInstance(conn.laddr, str)\n                self.assertEqual(conn.laddr, name)\n\n    def test_disk_usage(self):\n        dname = self.funky_name + \"2\"\n        self.addCleanup(safe_rmpath, dname)\n        safe_mkdir(dname)\n        psutil.disk_usage(dname)\n\n    @unittest.skipIf(not HAS_MEMORY_MAPS, \"not supported\")\n    @unittest.skipIf(not PY3, \"ctypes does not support unicode on PY2\")\n    @unittest.skipIf(PYPY, \"unstable on PYPY\")\n    def test_memory_maps(self):\n        # XXX: on Python 2, using ctypes.CDLL with a unicode path\n        # opens a message box which blocks the test run.\n        with copyload_shared_lib(suffix=self.funky_suffix) as funky_path:\n            def normpath(p):\n                return os.path.realpath(os.path.normcase(p))\n            libpaths = [normpath(x.path)\n                        for x in psutil.Process().memory_maps()]\n            # ...just to have a clearer msg in case of failure\n            libpaths = [x for x in libpaths if TESTFN_PREFIX in x]\n            self.assertIn(normpath(funky_path), libpaths)\n            for path in libpaths:\n                self.assertIsInstance(path, str)\n\n\n@unittest.skipIf(CI_TESTING, \"unreliable on CI\")\nclass TestFSAPIsWithInvalidPath(TestFSAPIs):\n    \"\"\"Test FS APIs with a funky, invalid path name.\"\"\"\n    funky_suffix = INVALID_UNICODE_SUFFIX\n\n    @classmethod\n    def expect_exact_path_match(cls):\n        # Invalid unicode names are supposed to work on Python 2.\n        return True\n\n\n# ===================================================================\n# Non fs APIs\n# ===================================================================\n\n\nclass TestNonFSAPIS(BaseUnicodeTest):\n    \"\"\"Unicode tests for non fs-related APIs.\"\"\"\n    funky_suffix = UNICODE_SUFFIX if PY3 else '\u00e8'\n\n    @unittest.skipIf(not HAS_ENVIRON, \"not supported\")\n    @unittest.skipIf(PYPY and WINDOWS, \"segfaults on PYPY + WINDOWS\")\n    def test_proc_environ(self):\n        # Note: differently from others, this test does not deal\n        # with fs paths. On Python 2 subprocess module is broken as\n        # it's not able to handle with non-ASCII env vars, so\n        # we use \"\u00e8\", which is part of the extended ASCII table\n        # (unicode point <= 255).\n        env = os.environ.copy()\n        env['FUNNY_ARG'] = self.funky_suffix\n        sproc = self.spawn_testproc(env=env)\n        p = psutil.Process(sproc.pid)\n        env = p.environ()\n        for k, v in env.items():\n            self.assertIsInstance(k, str)\n            self.assertIsInstance(v, str)\n        self.assertEqual(env['FUNNY_ARG'], self.funky_suffix)\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n    run_from_name(__file__)\n"
                    },
                    "test_windows": {
                        "type": "module",
                        "extension": "py",
                        "code": "#!/usr/bin/env python3\n# -*- coding: UTF-8 -*\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Windows specific tests.\"\"\"\n\nimport datetime\nimport errno\nimport glob\nimport os\nimport platform\nimport re\nimport signal\nimport subprocess\nimport sys\nimport time\nimport warnings\n\nimport psutil\nfrom psutil import WINDOWS\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import super\nfrom psutil.tests import APPVEYOR\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import IS_64BIT\nfrom psutil.tests import mock\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import PY3\nfrom psutil.tests import PYPY\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import sh\nfrom psutil.tests import spawn_testproc\nfrom psutil.tests import terminate\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import unittest\n\n\nif WINDOWS and not PYPY:\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        import win32api  # requires \"pip install pywin32\"\n        import win32con\n        import win32process\n        import wmi  # requires \"pip install wmi\" / \"make setup-dev-env\"\n\n\ncext = psutil._psplatform.cext\n\n\ndef wrap_exceptions(fun):\n    def wrapper(self, *args, **kwargs):\n        try:\n            return fun(self, *args, **kwargs)\n        except OSError as err:\n            from psutil._pswindows import ACCESS_DENIED_SET\n            if err.errno in ACCESS_DENIED_SET:\n                raise psutil.AccessDenied(None, None)\n            if err.errno == errno.ESRCH:\n                raise psutil.NoSuchProcess(None, None)\n            raise\n    return wrapper\n\n\n@unittest.skipIf(not WINDOWS, \"WINDOWS only\")\n@unittest.skipIf(PYPY, \"pywin32 not available on PYPY\")\n# https://github.com/giampaolo/psutil/pull/1762#issuecomment-632892692\n@unittest.skipIf(GITHUB_ACTIONS and not PY3, \"pywin32 broken on GITHUB + PY2\")\nclass WindowsTestCase(PsutilTestCase):\n    pass\n\n\n# ===================================================================\n# System APIs\n# ===================================================================\n\n\nclass TestCpuAPIs(WindowsTestCase):\n\n    @unittest.skipIf('NUMBER_OF_PROCESSORS' not in os.environ,\n                     'NUMBER_OF_PROCESSORS env var is not available')\n    def test_cpu_count_vs_NUMBER_OF_PROCESSORS(self):\n        # Will likely fail on many-cores systems:\n        # https://stackoverflow.com/questions/31209256\n        num_cpus = int(os.environ['NUMBER_OF_PROCESSORS'])\n        self.assertEqual(num_cpus, psutil.cpu_count())\n\n    def test_cpu_count_vs_GetSystemInfo(self):\n        # Will likely fail on many-cores systems:\n        # https://stackoverflow.com/questions/31209256\n        sys_value = win32api.GetSystemInfo()[5]\n        psutil_value = psutil.cpu_count()\n        self.assertEqual(sys_value, psutil_value)\n\n    def test_cpu_count_logical_vs_wmi(self):\n        w = wmi.WMI()\n        proc = w.Win32_Processor()[0]\n        self.assertEqual(psutil.cpu_count(), proc.NumberOfLogicalProcessors)\n\n    def test_cpu_count_phys_vs_wmi(self):\n        w = wmi.WMI()\n        proc = w.Win32_Processor()[0]\n        self.assertEqual(psutil.cpu_count(logical=False), proc.NumberOfCores)\n\n    def test_cpu_count_vs_cpu_times(self):\n        self.assertEqual(psutil.cpu_count(),\n                         len(psutil.cpu_times(percpu=True)))\n\n    def test_cpu_freq(self):\n        w = wmi.WMI()\n        proc = w.Win32_Processor()[0]\n        self.assertEqual(proc.CurrentClockSpeed, psutil.cpu_freq().current)\n        self.assertEqual(proc.MaxClockSpeed, psutil.cpu_freq().max)\n\n\nclass TestSystemAPIs(WindowsTestCase):\n\n    def test_nic_names(self):\n        out = sh('ipconfig /all')\n        nics = psutil.net_io_counters(pernic=True).keys()\n        for nic in nics:\n            if \"pseudo-interface\" in nic.replace(' ', '-').lower():\n                continue\n            if nic not in out:\n                self.fail(\n                    \"%r nic wasn't found in 'ipconfig /all' output\" % nic)\n\n    def test_total_phymem(self):\n        w = wmi.WMI().Win32_ComputerSystem()[0]\n        self.assertEqual(int(w.TotalPhysicalMemory),\n                         psutil.virtual_memory().total)\n\n    # @unittest.skipIf(wmi is None, \"wmi module is not installed\")\n    # def test__UPTIME(self):\n    #     # _UPTIME constant is not public but it is used internally\n    #     # as value to return for pid 0 creation time.\n    #     # WMI behaves the same.\n    #     w = wmi.WMI().Win32_Process(ProcessId=self.pid)[0]\n    #     p = psutil.Process(0)\n    #     wmic_create = str(w.CreationDate.split('.')[0])\n    #     psutil_create = time.strftime(\"%Y%m%d%H%M%S\",\n    #                                   time.localtime(p.create_time()))\n\n    # Note: this test is not very reliable\n    @unittest.skipIf(APPVEYOR, \"test not relieable on appveyor\")\n    @retry_on_failure()\n    def test_pids(self):\n        # Note: this test might fail if the OS is starting/killing\n        # other processes in the meantime\n        w = wmi.WMI().Win32_Process()\n        wmi_pids = set([x.ProcessId for x in w])\n        psutil_pids = set(psutil.pids())\n        self.assertEqual(wmi_pids, psutil_pids)\n\n    @retry_on_failure()\n    def test_disks(self):\n        ps_parts = psutil.disk_partitions(all=True)\n        wmi_parts = wmi.WMI().Win32_LogicalDisk()\n        for ps_part in ps_parts:\n            for wmi_part in wmi_parts:\n                if ps_part.device.replace('\\\\', '') == wmi_part.DeviceID:\n                    if not ps_part.mountpoint:\n                        # this is usually a CD-ROM with no disk inserted\n                        break\n                    if 'cdrom' in ps_part.opts:\n                        break\n                    if ps_part.mountpoint.startswith('A:'):\n                        break  # floppy\n                    try:\n                        usage = psutil.disk_usage(ps_part.mountpoint)\n                    except FileNotFoundError:\n                        # usually this is the floppy\n                        break\n                    self.assertEqual(usage.total, int(wmi_part.Size))\n                    wmi_free = int(wmi_part.FreeSpace)\n                    self.assertEqual(usage.free, wmi_free)\n                    # 10 MB tollerance\n                    if abs(usage.free - wmi_free) > 10 * 1024 * 1024:\n                        self.fail(\"psutil=%s, wmi=%s\" % (\n                            usage.free, wmi_free))\n                    break\n            else:\n                self.fail(\"can't find partition %s\" % repr(ps_part))\n\n    @retry_on_failure()\n    def test_disk_usage(self):\n        for disk in psutil.disk_partitions():\n            if 'cdrom' in disk.opts:\n                continue\n            sys_value = win32api.GetDiskFreeSpaceEx(disk.mountpoint)\n            psutil_value = psutil.disk_usage(disk.mountpoint)\n            self.assertAlmostEqual(sys_value[0], psutil_value.free,\n                                   delta=TOLERANCE_DISK_USAGE)\n            self.assertAlmostEqual(sys_value[1], psutil_value.total,\n                                   delta=TOLERANCE_DISK_USAGE)\n            self.assertEqual(psutil_value.used,\n                             psutil_value.total - psutil_value.free)\n\n    def test_disk_partitions(self):\n        sys_value = [\n            x + '\\\\' for x in win32api.GetLogicalDriveStrings().split(\"\\\\\\x00\")\n            if x and not x.startswith('A:')]\n        psutil_value = [x.mountpoint for x in psutil.disk_partitions(all=True)\n                        if not x.mountpoint.startswith('A:')]\n        self.assertEqual(sys_value, psutil_value)\n\n    def test_net_if_stats(self):\n        ps_names = set(cext.net_if_stats())\n        wmi_adapters = wmi.WMI().Win32_NetworkAdapter()\n        wmi_names = set()\n        for wmi_adapter in wmi_adapters:\n            wmi_names.add(wmi_adapter.Name)\n            wmi_names.add(wmi_adapter.NetConnectionID)\n        self.assertTrue(ps_names & wmi_names,\n                        \"no common entries in %s, %s\" % (ps_names, wmi_names))\n\n    def test_boot_time(self):\n        wmi_os = wmi.WMI().Win32_OperatingSystem()\n        wmi_btime_str = wmi_os[0].LastBootUpTime.split('.')[0]\n        wmi_btime_dt = datetime.datetime.strptime(\n            wmi_btime_str, \"%Y%m%d%H%M%S\")\n        psutil_dt = datetime.datetime.fromtimestamp(psutil.boot_time())\n        diff = abs((wmi_btime_dt - psutil_dt).total_seconds())\n        self.assertLessEqual(diff, 3)\n\n    def test_boot_time_fluctuation(self):\n        # https://github.com/giampaolo/psutil/issues/1007\n        with mock.patch('psutil._pswindows.cext.boot_time', return_value=5):\n            self.assertEqual(psutil.boot_time(), 5)\n        with mock.patch('psutil._pswindows.cext.boot_time', return_value=4):\n            self.assertEqual(psutil.boot_time(), 5)\n        with mock.patch('psutil._pswindows.cext.boot_time', return_value=6):\n            self.assertEqual(psutil.boot_time(), 5)\n        with mock.patch('psutil._pswindows.cext.boot_time', return_value=333):\n            self.assertEqual(psutil.boot_time(), 333)\n\n\n# ===================================================================\n# sensors_battery()\n# ===================================================================\n\n\nclass TestSensorsBattery(WindowsTestCase):\n\n    def test_has_battery(self):\n        if win32api.GetPwrCapabilities()['SystemBatteriesPresent']:\n            self.assertIsNotNone(psutil.sensors_battery())\n        else:\n            self.assertIsNone(psutil.sensors_battery())\n\n    @unittest.skipIf(not HAS_BATTERY, \"no battery\")\n    def test_percent(self):\n        w = wmi.WMI()\n        battery_wmi = w.query('select * from Win32_Battery')[0]\n        battery_psutil = psutil.sensors_battery()\n        self.assertAlmostEqual(\n            battery_psutil.percent, battery_wmi.EstimatedChargeRemaining,\n            delta=1)\n\n    @unittest.skipIf(not HAS_BATTERY, \"no battery\")\n    def test_power_plugged(self):\n        w = wmi.WMI()\n        battery_wmi = w.query('select * from Win32_Battery')[0]\n        battery_psutil = psutil.sensors_battery()\n        # Status codes:\n        # https://msdn.microsoft.com/en-us/library/aa394074(v=vs.85).aspx\n        self.assertEqual(battery_psutil.power_plugged,\n                         battery_wmi.BatteryStatus == 2)\n\n    def test_emulate_no_battery(self):\n        with mock.patch(\"psutil._pswindows.cext.sensors_battery\",\n                        return_value=(0, 128, 0, 0)) as m:\n            self.assertIsNone(psutil.sensors_battery())\n            assert m.called\n\n    def test_emulate_power_connected(self):\n        with mock.patch(\"psutil._pswindows.cext.sensors_battery\",\n                        return_value=(1, 0, 0, 0)) as m:\n            self.assertEqual(psutil.sensors_battery().secsleft,\n                             psutil.POWER_TIME_UNLIMITED)\n            assert m.called\n\n    def test_emulate_power_charging(self):\n        with mock.patch(\"psutil._pswindows.cext.sensors_battery\",\n                        return_value=(0, 8, 0, 0)) as m:\n            self.assertEqual(psutil.sensors_battery().secsleft,\n                             psutil.POWER_TIME_UNLIMITED)\n            assert m.called\n\n    def test_emulate_secs_left_unknown(self):\n        with mock.patch(\"psutil._pswindows.cext.sensors_battery\",\n                        return_value=(0, 0, 0, -1)) as m:\n            self.assertEqual(psutil.sensors_battery().secsleft,\n                             psutil.POWER_TIME_UNKNOWN)\n            assert m.called\n\n\n# ===================================================================\n# Process APIs\n# ===================================================================\n\n\nclass TestProcess(WindowsTestCase):\n\n    @classmethod\n    def setUpClass(cls):\n        cls.pid = spawn_testproc().pid\n\n    @classmethod\n    def tearDownClass(cls):\n        terminate(cls.pid)\n\n    def test_issue_24(self):\n        p = psutil.Process(0)\n        self.assertRaises(psutil.AccessDenied, p.kill)\n\n    def test_special_pid(self):\n        p = psutil.Process(4)\n        self.assertEqual(p.name(), 'System')\n        # use __str__ to access all common Process properties to check\n        # that nothing strange happens\n        str(p)\n        p.username()\n        self.assertTrue(p.create_time() >= 0.0)\n        try:\n            rss, vms = p.memory_info()[:2]\n        except psutil.AccessDenied:\n            # expected on Windows Vista and Windows 7\n            if not platform.uname()[1] in ('vista', 'win-7', 'win7'):\n                raise\n        else:\n            self.assertTrue(rss > 0)\n\n    def test_send_signal(self):\n        p = psutil.Process(self.pid)\n        self.assertRaises(ValueError, p.send_signal, signal.SIGINT)\n\n    def test_num_handles_increment(self):\n        p = psutil.Process(os.getpid())\n        before = p.num_handles()\n        handle = win32api.OpenProcess(win32con.PROCESS_QUERY_INFORMATION,\n                                      win32con.FALSE, os.getpid())\n        after = p.num_handles()\n        self.assertEqual(after, before + 1)\n        win32api.CloseHandle(handle)\n        self.assertEqual(p.num_handles(), before)\n\n    @unittest.skipIf(not sys.version_info >= (2, 7),\n                     \"CTRL_* signals not supported\")\n    def test_ctrl_signals(self):\n        p = psutil.Process(self.spawn_testproc().pid)\n        p.send_signal(signal.CTRL_C_EVENT)\n        p.send_signal(signal.CTRL_BREAK_EVENT)\n        p.kill()\n        p.wait()\n        self.assertRaises(psutil.NoSuchProcess,\n                          p.send_signal, signal.CTRL_C_EVENT)\n        self.assertRaises(psutil.NoSuchProcess,\n                          p.send_signal, signal.CTRL_BREAK_EVENT)\n\n    def test_username(self):\n        self.assertEqual(psutil.Process().username(),\n                         win32api.GetUserNameEx(win32con.NameSamCompatible))\n\n    def test_cmdline(self):\n        sys_value = re.sub(' +', ' ', win32api.GetCommandLine()).strip()\n        psutil_value = ' '.join(psutil.Process().cmdline())\n        self.assertEqual(sys_value, psutil_value)\n\n    # XXX - occasional failures\n\n    # def test_cpu_times(self):\n    #     handle = win32api.OpenProcess(win32con.PROCESS_QUERY_INFORMATION,\n    #                                   win32con.FALSE, os.getpid())\n    #     self.addCleanup(win32api.CloseHandle, handle)\n    #     sys_value = win32process.GetProcessTimes(handle)\n    #     psutil_value = psutil.Process().cpu_times()\n    #     self.assertAlmostEqual(\n    #         psutil_value.user, sys_value['UserTime'] / 10000000.0,\n    #         delta=0.2)\n    #     self.assertAlmostEqual(\n    #         psutil_value.user, sys_value['KernelTime'] / 10000000.0,\n    #         delta=0.2)\n\n    def test_nice(self):\n        handle = win32api.OpenProcess(win32con.PROCESS_QUERY_INFORMATION,\n                                      win32con.FALSE, os.getpid())\n        self.addCleanup(win32api.CloseHandle, handle)\n        sys_value = win32process.GetPriorityClass(handle)\n        psutil_value = psutil.Process().nice()\n        self.assertEqual(psutil_value, sys_value)\n\n    def test_memory_info(self):\n        handle = win32api.OpenProcess(win32con.PROCESS_QUERY_INFORMATION,\n                                      win32con.FALSE, self.pid)\n        self.addCleanup(win32api.CloseHandle, handle)\n        sys_value = win32process.GetProcessMemoryInfo(handle)\n        psutil_value = psutil.Process(self.pid).memory_info()\n        self.assertEqual(\n            sys_value['PeakWorkingSetSize'], psutil_value.peak_wset)\n        self.assertEqual(\n            sys_value['WorkingSetSize'], psutil_value.wset)\n        self.assertEqual(\n            sys_value['QuotaPeakPagedPoolUsage'], psutil_value.peak_paged_pool)\n        self.assertEqual(\n            sys_value['QuotaPagedPoolUsage'], psutil_value.paged_pool)\n        self.assertEqual(\n            sys_value['QuotaPeakNonPagedPoolUsage'],\n            psutil_value.peak_nonpaged_pool)\n        self.assertEqual(\n            sys_value['QuotaNonPagedPoolUsage'], psutil_value.nonpaged_pool)\n        self.assertEqual(\n            sys_value['PagefileUsage'], psutil_value.pagefile)\n        self.assertEqual(\n            sys_value['PeakPagefileUsage'], psutil_value.peak_pagefile)\n\n        self.assertEqual(psutil_value.rss, psutil_value.wset)\n        self.assertEqual(psutil_value.vms, psutil_value.pagefile)\n\n    def test_wait(self):\n        handle = win32api.OpenProcess(win32con.PROCESS_QUERY_INFORMATION,\n                                      win32con.FALSE, self.pid)\n        self.addCleanup(win32api.CloseHandle, handle)\n        p = psutil.Process(self.pid)\n        p.terminate()\n        psutil_value = p.wait()\n        sys_value = win32process.GetExitCodeProcess(handle)\n        self.assertEqual(psutil_value, sys_value)\n\n    def test_cpu_affinity(self):\n        def from_bitmask(x):\n            return [i for i in range(64) if (1 << i) & x]\n\n        handle = win32api.OpenProcess(win32con.PROCESS_QUERY_INFORMATION,\n                                      win32con.FALSE, self.pid)\n        self.addCleanup(win32api.CloseHandle, handle)\n        sys_value = from_bitmask(\n            win32process.GetProcessAffinityMask(handle)[0])\n        psutil_value = psutil.Process(self.pid).cpu_affinity()\n        self.assertEqual(psutil_value, sys_value)\n\n    def test_io_counters(self):\n        handle = win32api.OpenProcess(win32con.PROCESS_QUERY_INFORMATION,\n                                      win32con.FALSE, os.getpid())\n        self.addCleanup(win32api.CloseHandle, handle)\n        sys_value = win32process.GetProcessIoCounters(handle)\n        psutil_value = psutil.Process().io_counters()\n        self.assertEqual(\n            psutil_value.read_count, sys_value['ReadOperationCount'])\n        self.assertEqual(\n            psutil_value.write_count, sys_value['WriteOperationCount'])\n        self.assertEqual(\n            psutil_value.read_bytes, sys_value['ReadTransferCount'])\n        self.assertEqual(\n            psutil_value.write_bytes, sys_value['WriteTransferCount'])\n        self.assertEqual(\n            psutil_value.other_count, sys_value['OtherOperationCount'])\n        self.assertEqual(\n            psutil_value.other_bytes, sys_value['OtherTransferCount'])\n\n    def test_num_handles(self):\n        import ctypes\n        import ctypes.wintypes\n        PROCESS_QUERY_INFORMATION = 0x400\n        handle = ctypes.windll.kernel32.OpenProcess(\n            PROCESS_QUERY_INFORMATION, 0, self.pid)\n        self.addCleanup(ctypes.windll.kernel32.CloseHandle, handle)\n\n        hndcnt = ctypes.wintypes.DWORD()\n        ctypes.windll.kernel32.GetProcessHandleCount(\n            handle, ctypes.byref(hndcnt))\n        sys_value = hndcnt.value\n        psutil_value = psutil.Process(self.pid).num_handles()\n        self.assertEqual(psutil_value, sys_value)\n\n    def test_error_partial_copy(self):\n        # https://github.com/giampaolo/psutil/issues/875\n        exc = WindowsError()\n        exc.winerror = 299\n        with mock.patch(\"psutil._psplatform.cext.proc_cwd\", side_effect=exc):\n            with mock.patch(\"time.sleep\") as m:\n                p = psutil.Process()\n                self.assertRaises(psutil.AccessDenied, p.cwd)\n        self.assertGreaterEqual(m.call_count, 5)\n\n    def test_exe(self):\n        # NtQuerySystemInformation succeeds if process is gone. Make sure\n        # it raises NSP for a non existent pid.\n        pid = psutil.pids()[-1] + 99999\n        proc = psutil._psplatform.Process(pid)\n        self.assertRaises(psutil.NoSuchProcess, proc.exe)\n\n\nclass TestProcessWMI(WindowsTestCase):\n    \"\"\"Compare Process API results with WMI.\"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        cls.pid = spawn_testproc().pid\n\n    @classmethod\n    def tearDownClass(cls):\n        terminate(cls.pid)\n\n    def test_name(self):\n        w = wmi.WMI().Win32_Process(ProcessId=self.pid)[0]\n        p = psutil.Process(self.pid)\n        self.assertEqual(p.name(), w.Caption)\n\n    # This fail on github because using virtualenv for test environment\n    @unittest.skipIf(GITHUB_ACTIONS, \"unreliable path on GITHUB_ACTIONS\")\n    def test_exe(self):\n        w = wmi.WMI().Win32_Process(ProcessId=self.pid)[0]\n        p = psutil.Process(self.pid)\n        # Note: wmi reports the exe as a lower case string.\n        # Being Windows paths case-insensitive we ignore that.\n        self.assertEqual(p.exe().lower(), w.ExecutablePath.lower())\n\n    def test_cmdline(self):\n        w = wmi.WMI().Win32_Process(ProcessId=self.pid)[0]\n        p = psutil.Process(self.pid)\n        self.assertEqual(' '.join(p.cmdline()),\n                         w.CommandLine.replace('\"', ''))\n\n    def test_username(self):\n        w = wmi.WMI().Win32_Process(ProcessId=self.pid)[0]\n        p = psutil.Process(self.pid)\n        domain, _, username = w.GetOwner()\n        username = \"%s\\\\%s\" % (domain, username)\n        self.assertEqual(p.username(), username)\n\n    @retry_on_failure()\n    def test_memory_rss(self):\n        w = wmi.WMI().Win32_Process(ProcessId=self.pid)[0]\n        p = psutil.Process(self.pid)\n        rss = p.memory_info().rss\n        self.assertEqual(rss, int(w.WorkingSetSize))\n\n    @retry_on_failure()\n    def test_memory_vms(self):\n        w = wmi.WMI().Win32_Process(ProcessId=self.pid)[0]\n        p = psutil.Process(self.pid)\n        vms = p.memory_info().vms\n        # http://msdn.microsoft.com/en-us/library/aa394372(VS.85).aspx\n        # ...claims that PageFileUsage is represented in Kilo\n        # bytes but funnily enough on certain platforms bytes are\n        # returned instead.\n        wmi_usage = int(w.PageFileUsage)\n        if (vms != wmi_usage) and (vms != wmi_usage * 1024):\n            self.fail(\"wmi=%s, psutil=%s\" % (wmi_usage, vms))\n\n    def test_create_time(self):\n        w = wmi.WMI().Win32_Process(ProcessId=self.pid)[0]\n        p = psutil.Process(self.pid)\n        wmic_create = str(w.CreationDate.split('.')[0])\n        psutil_create = time.strftime(\"%Y%m%d%H%M%S\",\n                                      time.localtime(p.create_time()))\n        self.assertEqual(wmic_create, psutil_create)\n\n\n# ---\n\n\n@unittest.skipIf(not WINDOWS, \"WINDOWS only\")\nclass TestDualProcessImplementation(PsutilTestCase):\n    \"\"\"\n    Certain APIs on Windows have 2 internal implementations, one\n    based on documented Windows APIs, another one based\n    NtQuerySystemInformation() which gets called as fallback in\n    case the first fails because of limited permission error.\n    Here we test that the two methods return the exact same value,\n    see:\n    https://github.com/giampaolo/psutil/issues/304\n    \"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        cls.pid = spawn_testproc().pid\n\n    @classmethod\n    def tearDownClass(cls):\n        terminate(cls.pid)\n\n    def test_memory_info(self):\n        mem_1 = psutil.Process(self.pid).memory_info()\n        with mock.patch(\"psutil._psplatform.cext.proc_memory_info\",\n                        side_effect=OSError(errno.EPERM, \"msg\")) as fun:\n            mem_2 = psutil.Process(self.pid).memory_info()\n            self.assertEqual(len(mem_1), len(mem_2))\n            for i in range(len(mem_1)):\n                self.assertGreaterEqual(mem_1[i], 0)\n                self.assertGreaterEqual(mem_2[i], 0)\n                self.assertAlmostEqual(mem_1[i], mem_2[i], delta=512)\n            assert fun.called\n\n    def test_create_time(self):\n        ctime = psutil.Process(self.pid).create_time()\n        with mock.patch(\"psutil._psplatform.cext.proc_times\",\n                        side_effect=OSError(errno.EPERM, \"msg\")) as fun:\n            self.assertEqual(psutil.Process(self.pid).create_time(), ctime)\n            assert fun.called\n\n    def test_cpu_times(self):\n        cpu_times_1 = psutil.Process(self.pid).cpu_times()\n        with mock.patch(\"psutil._psplatform.cext.proc_times\",\n                        side_effect=OSError(errno.EPERM, \"msg\")) as fun:\n            cpu_times_2 = psutil.Process(self.pid).cpu_times()\n            assert fun.called\n            self.assertAlmostEqual(\n                cpu_times_1.user, cpu_times_2.user, delta=0.01)\n            self.assertAlmostEqual(\n                cpu_times_1.system, cpu_times_2.system, delta=0.01)\n\n    def test_io_counters(self):\n        io_counters_1 = psutil.Process(self.pid).io_counters()\n        with mock.patch(\"psutil._psplatform.cext.proc_io_counters\",\n                        side_effect=OSError(errno.EPERM, \"msg\")) as fun:\n            io_counters_2 = psutil.Process(self.pid).io_counters()\n            for i in range(len(io_counters_1)):\n                self.assertAlmostEqual(\n                    io_counters_1[i], io_counters_2[i], delta=5)\n            assert fun.called\n\n    def test_num_handles(self):\n        num_handles = psutil.Process(self.pid).num_handles()\n        with mock.patch(\"psutil._psplatform.cext.proc_num_handles\",\n                        side_effect=OSError(errno.EPERM, \"msg\")) as fun:\n            self.assertEqual(psutil.Process(self.pid).num_handles(),\n                             num_handles)\n            assert fun.called\n\n    def test_cmdline(self):\n        from psutil._pswindows import convert_oserror\n        for pid in psutil.pids():\n            try:\n                a = cext.proc_cmdline(pid, use_peb=True)\n                b = cext.proc_cmdline(pid, use_peb=False)\n            except OSError as err:\n                err = convert_oserror(err)\n                if not isinstance(err, (psutil.AccessDenied,\n                                        psutil.NoSuchProcess)):\n                    raise\n            else:\n                self.assertEqual(a, b)\n\n\n@unittest.skipIf(not WINDOWS, \"WINDOWS only\")\nclass RemoteProcessTestCase(PsutilTestCase):\n    \"\"\"Certain functions require calling ReadProcessMemory.\n    This trivially works when called on the current process.\n    Check that this works on other processes, especially when they\n    have a different bitness.\n    \"\"\"\n\n    @staticmethod\n    def find_other_interpreter():\n        # find a python interpreter that is of the opposite bitness from us\n        code = \"import sys; sys.stdout.write(str(sys.maxsize > 2**32))\"\n\n        # XXX: a different and probably more stable approach might be to access\n        # the registry but accessing 64 bit paths from a 32 bit process\n        for filename in glob.glob(r\"C:\\Python*\\python.exe\"):\n            proc = subprocess.Popen(args=[filename, \"-c\", code],\n                                    stdout=subprocess.PIPE,\n                                    stderr=subprocess.STDOUT)\n            output, _ = proc.communicate()\n            proc.wait()\n            if output == str(not IS_64BIT):\n                return filename\n\n    test_args = [\"-c\", \"import sys; sys.stdin.read()\"]\n\n    def setUp(self):\n        super().setUp()\n\n        other_python = self.find_other_interpreter()\n        if other_python is None:\n            raise unittest.SkipTest(\n                \"could not find interpreter with opposite bitness\")\n        if IS_64BIT:\n            self.python64 = sys.executable\n            self.python32 = other_python\n        else:\n            self.python64 = other_python\n            self.python32 = sys.executable\n\n        env = os.environ.copy()\n        env[\"THINK_OF_A_NUMBER\"] = str(os.getpid())\n        self.proc32 = self.spawn_testproc(\n            [self.python32] + self.test_args,\n            env=env,\n            stdin=subprocess.PIPE)\n        self.proc64 = self.spawn_testproc(\n            [self.python64] + self.test_args,\n            env=env,\n            stdin=subprocess.PIPE)\n\n    def tearDown(self):\n        super().tearDown()\n        self.proc32.communicate()\n        self.proc64.communicate()\n\n    def test_cmdline_32(self):\n        p = psutil.Process(self.proc32.pid)\n        self.assertEqual(len(p.cmdline()), 3)\n        self.assertEqual(p.cmdline()[1:], self.test_args)\n\n    def test_cmdline_64(self):\n        p = psutil.Process(self.proc64.pid)\n        self.assertEqual(len(p.cmdline()), 3)\n        self.assertEqual(p.cmdline()[1:], self.test_args)\n\n    def test_cwd_32(self):\n        p = psutil.Process(self.proc32.pid)\n        self.assertEqual(p.cwd(), os.getcwd())\n\n    def test_cwd_64(self):\n        p = psutil.Process(self.proc64.pid)\n        self.assertEqual(p.cwd(), os.getcwd())\n\n    def test_environ_32(self):\n        p = psutil.Process(self.proc32.pid)\n        e = p.environ()\n        self.assertIn(\"THINK_OF_A_NUMBER\", e)\n        self.assertEquals(e[\"THINK_OF_A_NUMBER\"], str(os.getpid()))\n\n    def test_environ_64(self):\n        p = psutil.Process(self.proc64.pid)\n        try:\n            p.environ()\n        except psutil.AccessDenied:\n            pass\n\n\n# ===================================================================\n# Windows services\n# ===================================================================\n\n\n@unittest.skipIf(not WINDOWS, \"WINDOWS only\")\nclass TestServices(PsutilTestCase):\n\n    def test_win_service_iter(self):\n        valid_statuses = set([\n            \"running\",\n            \"paused\",\n            \"start\",\n            \"pause\",\n            \"continue\",\n            \"stop\",\n            \"stopped\",\n        ])\n        valid_start_types = set([\n            \"automatic\",\n            \"manual\",\n            \"disabled\",\n        ])\n        valid_statuses = set([\n            \"running\",\n            \"paused\",\n            \"start_pending\",\n            \"pause_pending\",\n            \"continue_pending\",\n            \"stop_pending\",\n            \"stopped\"\n        ])\n        for serv in psutil.win_service_iter():\n            data = serv.as_dict()\n            self.assertIsInstance(data['name'], str)\n            self.assertNotEqual(data['name'].strip(), \"\")\n            self.assertIsInstance(data['display_name'], str)\n            self.assertIsInstance(data['username'], str)\n            self.assertIn(data['status'], valid_statuses)\n            if data['pid'] is not None:\n                psutil.Process(data['pid'])\n            self.assertIsInstance(data['binpath'], str)\n            self.assertIsInstance(data['username'], str)\n            self.assertIsInstance(data['start_type'], str)\n            self.assertIn(data['start_type'], valid_start_types)\n            self.assertIn(data['status'], valid_statuses)\n            self.assertIsInstance(data['description'], str)\n            pid = serv.pid()\n            if pid is not None:\n                p = psutil.Process(pid)\n                self.assertTrue(p.is_running())\n            # win_service_get\n            s = psutil.win_service_get(serv.name())\n            # test __eq__\n            self.assertEqual(serv, s)\n\n    def test_win_service_get(self):\n        ERROR_SERVICE_DOES_NOT_EXIST = \\\n            psutil._psplatform.cext.ERROR_SERVICE_DOES_NOT_EXIST\n        ERROR_ACCESS_DENIED = psutil._psplatform.cext.ERROR_ACCESS_DENIED\n\n        name = next(psutil.win_service_iter()).name()\n        with self.assertRaises(psutil.NoSuchProcess) as cm:\n            psutil.win_service_get(name + '???')\n        self.assertEqual(cm.exception.name, name + '???')\n\n        # test NoSuchProcess\n        service = psutil.win_service_get(name)\n        if PY3:\n            args = (0, \"msg\", 0, ERROR_SERVICE_DOES_NOT_EXIST)\n        else:\n            args = (ERROR_SERVICE_DOES_NOT_EXIST, \"msg\")\n        exc = WindowsError(*args)\n        with mock.patch(\"psutil._psplatform.cext.winservice_query_status\",\n                        side_effect=exc):\n            self.assertRaises(psutil.NoSuchProcess, service.status)\n        with mock.patch(\"psutil._psplatform.cext.winservice_query_config\",\n                        side_effect=exc):\n            self.assertRaises(psutil.NoSuchProcess, service.username)\n\n        # test AccessDenied\n        if PY3:\n            args = (0, \"msg\", 0, ERROR_ACCESS_DENIED)\n        else:\n            args = (ERROR_ACCESS_DENIED, \"msg\")\n        exc = WindowsError(*args)\n        with mock.patch(\"psutil._psplatform.cext.winservice_query_status\",\n                        side_effect=exc):\n            self.assertRaises(psutil.AccessDenied, service.status)\n        with mock.patch(\"psutil._psplatform.cext.winservice_query_config\",\n                        side_effect=exc):\n            self.assertRaises(psutil.AccessDenied, service.username)\n\n        # test __str__ and __repr__\n        self.assertIn(service.name(), str(service))\n        self.assertIn(service.display_name(), str(service))\n        self.assertIn(service.name(), repr(service))\n        self.assertIn(service.display_name(), repr(service))\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n    run_from_name(__file__)\n"
                    }
                }
            }
        }
    }
}