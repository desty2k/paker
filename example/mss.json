{
    "mss": {
        "type": "package",
        "code": "\"\"\"\nAn ultra fast cross-platform multiple screenshots module in pure python\nusing ctypes.\n\nThis module is maintained by Micka\u00ebl Schoentgen <contact@tiger-222.fr>.\n\nYou can always get the latest version of this module at:\n    https://github.com/BoboTiG/python-mss\nIf that URL should fail, try contacting the author.\n\"\"\"\n\nfrom .exception import ScreenShotError\nfrom .factory import mss\n\n__version__ = \"6.1.0\"\n__author__ = \"Micka\u00ebl 'Tiger-222' Schoentgen\"\n__copyright__ = \"\"\"\n    Copyright (c) 2013-2020, Micka\u00ebl 'Tiger-222' Schoentgen\n\n    Permission to use, copy, modify, and distribute this software and its\n    documentation for any purpose and without fee or royalty is hereby\n    granted, provided that the above copyright notice appear in all copies\n    and that both that copyright notice and this permission notice appear\n    in supporting documentation or portions thereof, including\n    modifications, that you make.\n\"\"\"\n__all__ = (\"ScreenShotError\", \"mss\")\n",
        "modules": {
            "base": {
                "type": "module",
                "code": "\"\"\"\nThis is part of the MSS Python's module.\nSource: https://github.com/BoboTiG/python-mss\n\"\"\"\n\nfrom abc import ABCMeta, abstractmethod\nfrom datetime import datetime\nfrom typing import TYPE_CHECKING\nfrom threading import Lock\n\nfrom .exception import ScreenShotError\nfrom .screenshot import ScreenShot\nfrom .tools import to_png\n\nif TYPE_CHECKING:\n    # pylint: disable=ungrouped-imports\n    from typing import Any, Callable, Iterator, List, Optional, Type  # noqa\n\n    from .models import Monitor, Monitors  # noqa\n\n\nlock = Lock()\n\n\nclass MSSBase(metaclass=ABCMeta):\n    \"\"\" This class will be overloaded by a system specific one. \"\"\"\n\n    __slots__ = {\"_monitors\", \"cls_image\", \"compression_level\"}\n\n    def __init__(self):\n        self.cls_image = ScreenShot  # type: Type[ScreenShot]\n        self.compression_level = 6\n        self._monitors = []  # type: Monitors\n\n    def __enter__(self):\n        # type: () -> MSSBase\n        \"\"\" For the cool call `with MSS() as mss:`. \"\"\"\n\n        return self\n\n    def __exit__(self, *_):\n        \"\"\" For the cool call `with MSS() as mss:`. \"\"\"\n\n        self.close()\n\n    @abstractmethod\n    def _grab_impl(self, monitor):\n        # type: (Monitor) -> ScreenShot\n        \"\"\"\n        Retrieve all pixels from a monitor. Pixels have to be RGB.\n        That method has to be run using a threading lock.\n        \"\"\"\n\n    @abstractmethod\n    def _monitors_impl(self):\n        # type: () -> None\n        \"\"\"\n        Get positions of monitors (has to be run using a threading lock).\n        It must populate self._monitors.\n        \"\"\"\n\n    def close(self):\n        # type: () -> None\n        \"\"\" Clean-up. \"\"\"\n\n    def grab(self, monitor):\n        # type: (Monitor) -> ScreenShot\n        \"\"\"\n        Retrieve screen pixels for a given monitor.\n\n        Note: *monitor* can be a tuple like PIL.Image.grab() accepts.\n\n        :param monitor: The coordinates and size of the box to capture.\n                        See :meth:`monitors <monitors>` for object details.\n        :return :class:`ScreenShot <ScreenShot>`.\n        \"\"\"\n\n        # Convert PIL bbox style\n        if isinstance(monitor, tuple):\n            monitor = {\n                \"left\": monitor[0],\n                \"top\": monitor[1],\n                \"width\": monitor[2] - monitor[0],\n                \"height\": monitor[3] - monitor[1],\n            }\n\n        with lock:\n            return self._grab_impl(monitor)\n\n    @property\n    def monitors(self):\n        # type: () -> Monitors\n        \"\"\"\n        Get positions of all monitors.\n        If the monitor has rotation, you have to deal with it\n        inside this method.\n\n        This method has to fill self._monitors with all information\n        and use it as a cache:\n            self._monitors[0] is a dict of all monitors together\n            self._monitors[N] is a dict of the monitor N (with N > 0)\n\n        Each monitor is a dict with:\n        {\n            'left':   the x-coordinate of the upper-left corner,\n            'top':    the y-coordinate of the upper-left corner,\n            'width':  the width,\n            'height': the height\n        }\n        \"\"\"\n\n        if not self._monitors:\n            with lock:\n                self._monitors_impl()\n\n        return self._monitors\n\n    def save(self, mon=0, output=\"monitor-{mon}.png\", callback=None):\n        # type: (int, str, Callable[[str], None]) -> Iterator[str]\n        \"\"\"\n        Grab a screen shot and save it to a file.\n\n        :param int mon: The monitor to screen shot (default=0).\n                        -1: grab one screen shot of all monitors\n                         0: grab one screen shot by monitor\n                        N: grab the screen shot of the monitor N\n\n        :param str output: The output filename.\n\n            It can take several keywords to customize the filename:\n            - `{mon}`: the monitor number\n            - `{top}`: the screen shot y-coordinate of the upper-left corner\n            - `{left}`: the screen shot x-coordinate of the upper-left corner\n            - `{width}`: the screen shot's width\n            - `{height}`: the screen shot's height\n            - `{date}`: the current date using the default formatter\n\n            As it is using the `format()` function, you can specify\n            formatting options like `{date:%Y-%m-%s}`.\n\n        :param callable callback: Callback called before saving the\n            screen shot to a file.  Take the `output` argument as parameter.\n\n        :return generator: Created file(s).\n        \"\"\"\n\n        monitors = self.monitors\n        if not monitors:\n            raise ScreenShotError(\"No monitor found.\")\n\n        if mon == 0:\n            # One screen shot by monitor\n            for idx, monitor in enumerate(monitors[1:], 1):\n                fname = output.format(mon=idx, date=datetime.now(), **monitor)\n                if callable(callback):\n                    callback(fname)\n                sct = self.grab(monitor)\n                to_png(sct.rgb, sct.size, level=self.compression_level, output=fname)\n                yield fname\n        else:\n            # A screen shot of all monitors together or\n            # a screen shot of the monitor N.\n            mon = 0 if mon == -1 else mon\n            try:\n                monitor = monitors[mon]\n            except IndexError:\n                # pylint: disable=raise-missing-from\n                raise ScreenShotError(\"Monitor {!r} does not exist.\".format(mon))\n\n            output = output.format(mon=mon, date=datetime.now(), **monitor)\n            if callable(callback):\n                callback(output)\n            sct = self.grab(monitor)\n            to_png(sct.rgb, sct.size, level=self.compression_level, output=output)\n            yield output\n\n    def shot(self, **kwargs):\n        # type: (Any) -> str\n        \"\"\"\n        Helper to save the screen shot of the 1st monitor, by default.\n        You can pass the same arguments as for ``save``.\n        \"\"\"\n\n        kwargs[\"mon\"] = kwargs.get(\"mon\", 1)\n        return next(self.save(**kwargs))\n\n    @staticmethod\n    def _cfactory(attr, func, argtypes, restype, errcheck=None):\n        # type: (Any, str, List[Any], Any, Optional[Callable]) -> None\n        \"\"\" Factory to create a ctypes function and automatically manage errors. \"\"\"\n\n        meth = getattr(attr, func)\n        meth.argtypes = argtypes\n        meth.restype = restype\n        if errcheck:\n            meth.errcheck = errcheck\n"
            },
            "darwin": {
                "type": "module",
                "code": "\"\"\"\nThis is part of the MSS Python's module.\nSource: https://github.com/BoboTiG/python-mss\n\"\"\"\n\nimport ctypes\nimport ctypes.util\nimport sys\nfrom ctypes import (\n    POINTER,\n    Structure,\n    c_double,\n    c_float,\n    c_int32,\n    c_uint64,\n    c_ubyte,\n    c_uint32,\n    c_void_p,\n)\nfrom platform import mac_ver\nfrom typing import TYPE_CHECKING\n\nfrom .base import MSSBase\nfrom .exception import ScreenShotError\nfrom .screenshot import Size\n\nif TYPE_CHECKING:\n    from typing import Any, List, Type, Union  # noqa\n\n    from .models import Monitor, Monitors  # noqa\n    from .screenshot import ScreenShot  # noqa\n\n__all__ = (\"MSS\",)\n\n\ndef cgfloat():\n    # type: () -> Union[Type[c_double], Type[c_float]]\n    \"\"\" Get the appropriate value for a float. \"\"\"\n\n    return c_double if sys.maxsize > 2 ** 32 else c_float\n\n\nclass CGPoint(Structure):\n    \"\"\" Structure that contains coordinates of a rectangle. \"\"\"\n\n    _fields_ = [(\"x\", cgfloat()), (\"y\", cgfloat())]\n\n    def __repr__(self):\n        return \"{}(left={} top={})\".format(type(self).__name__, self.x, self.y)\n\n\nclass CGSize(Structure):\n    \"\"\" Structure that contains dimensions of an rectangle. \"\"\"\n\n    _fields_ = [(\"width\", cgfloat()), (\"height\", cgfloat())]\n\n    def __repr__(self):\n        return \"{}(width={} height={})\".format(\n            type(self).__name__, self.width, self.height\n        )\n\n\nclass CGRect(Structure):\n    \"\"\" Structure that contains information about a rectangle. \"\"\"\n\n    _fields_ = [(\"origin\", CGPoint), (\"size\", CGSize)]\n\n    def __repr__(self):\n        return \"{}<{} {}>\".format(type(self).__name__, self.origin, self.size)\n\n\n# C functions that will be initialised later.\n#\n# This is a dict:\n#    cfunction: (attr, argtypes, restype)\n#\n# Available attr: core.\n#\n# Note: keep it sorted by cfunction.\nCFUNCTIONS = {\n    \"CGDataProviderCopyData\": (\"core\", [c_void_p], c_void_p),\n    \"CGDisplayBounds\": (\"core\", [c_uint32], CGRect),\n    \"CGDisplayRotation\": (\"core\", [c_uint32], c_float),\n    \"CFDataGetBytePtr\": (\"core\", [c_void_p], c_void_p),\n    \"CFDataGetLength\": (\"core\", [c_void_p], c_uint64),\n    \"CFRelease\": (\"core\", [c_void_p], c_void_p),\n    \"CGDataProviderRelease\": (\"core\", [c_void_p], c_void_p),\n    \"CGGetActiveDisplayList\": (\n        \"core\",\n        [c_uint32, POINTER(c_uint32), POINTER(c_uint32)],\n        c_int32,\n    ),\n    \"CGImageGetBitsPerPixel\": (\"core\", [c_void_p], int),\n    \"CGImageGetBytesPerRow\": (\"core\", [c_void_p], int),\n    \"CGImageGetDataProvider\": (\"core\", [c_void_p], c_void_p),\n    \"CGImageGetHeight\": (\"core\", [c_void_p], int),\n    \"CGImageGetWidth\": (\"core\", [c_void_p], int),\n    \"CGRectStandardize\": (\"core\", [CGRect], CGRect),\n    \"CGRectUnion\": (\"core\", [CGRect, CGRect], CGRect),\n    \"CGWindowListCreateImage\": (\n        \"core\",\n        [CGRect, c_uint32, c_uint32, c_uint32],\n        c_void_p,\n    ),\n}\n\n\nclass MSS(MSSBase):\n    \"\"\"\n    Multiple ScreenShots implementation for macOS.\n    It uses intensively the CoreGraphics library.\n    \"\"\"\n\n    __slots__ = {\"core\", \"max_displays\"}\n\n    def __init__(self, **_):\n        \"\"\" macOS initialisations. \"\"\"\n\n        super().__init__()\n\n        self.max_displays = 32\n\n        self._init_library()\n        self._set_cfunctions()\n\n    def _init_library(self):\n        \"\"\" Load the CoreGraphics library. \"\"\"\n        version = float(\".\".join(mac_ver()[0].split(\".\")[:2]))\n        if version < 10.16:\n            coregraphics = ctypes.util.find_library(\"CoreGraphics\")\n        else:\n            # macOS Big Sur and newer\n            # pylint: disable=line-too-long\n            coregraphics = \"/System/Library/Frameworks/CoreGraphics.framework/Versions/Current/CoreGraphics\"\n\n        if not coregraphics:\n            raise ScreenShotError(\"No CoreGraphics library found.\")\n        self.core = ctypes.cdll.LoadLibrary(coregraphics)\n\n    def _set_cfunctions(self):\n        # type: () -> None\n        \"\"\" Set all ctypes functions and attach them to attributes. \"\"\"\n\n        cfactory = self._cfactory\n        attrs = {\"core\": self.core}\n        for func, (attr, argtypes, restype) in CFUNCTIONS.items():\n            cfactory(\n                attr=attrs[attr],\n                func=func,\n                argtypes=argtypes,  # type: ignore\n                restype=restype,\n            )\n\n    def _monitors_impl(self):\n        # type: () -> None\n        \"\"\" Get positions of monitors. It will populate self._monitors. \"\"\"\n\n        int_ = int\n        core = self.core\n\n        # All monitors\n        # We need to update the value with every single monitor found\n        # using CGRectUnion.  Else we will end with infinite values.\n        all_monitors = CGRect()\n        self._monitors.append({})\n\n        # Each monitors\n        display_count = c_uint32(0)\n        active_displays = (c_uint32 * self.max_displays)()\n        core.CGGetActiveDisplayList(\n            self.max_displays, active_displays, ctypes.byref(display_count)\n        )\n        rotations = {0.0: \"normal\", 90.0: \"right\", -90.0: \"left\"}\n        for idx in range(display_count.value):\n            display = active_displays[idx]\n            rect = core.CGDisplayBounds(display)\n            rect = core.CGRectStandardize(rect)\n            width, height = rect.size.width, rect.size.height\n            rot = core.CGDisplayRotation(display)\n            if rotations[rot] in [\"left\", \"right\"]:\n                width, height = height, width\n            self._monitors.append(\n                {\n                    \"left\": int_(rect.origin.x),\n                    \"top\": int_(rect.origin.y),\n                    \"width\": int_(width),\n                    \"height\": int_(height),\n                }\n            )\n\n            # Update AiO monitor's values\n            all_monitors = core.CGRectUnion(all_monitors, rect)\n\n        # Set the AiO monitor's values\n        self._monitors[0] = {\n            \"left\": int_(all_monitors.origin.x),\n            \"top\": int_(all_monitors.origin.y),\n            \"width\": int_(all_monitors.size.width),\n            \"height\": int_(all_monitors.size.height),\n        }\n\n    def _grab_impl(self, monitor):\n        # type: (Monitor) -> ScreenShot\n        \"\"\" Retrieve all pixels from a monitor. Pixels have to be RGB. \"\"\"\n\n        # pylint: disable=too-many-locals\n\n        core = self.core\n        rect = CGRect(\n            (monitor[\"left\"], monitor[\"top\"]), (monitor[\"width\"], monitor[\"height\"])\n        )\n\n        image_ref = core.CGWindowListCreateImage(rect, 1, 0, 0)\n        if not image_ref:\n            raise ScreenShotError(\"CoreGraphics.CGWindowListCreateImage() failed.\")\n\n        width = core.CGImageGetWidth(image_ref)\n        height = core.CGImageGetHeight(image_ref)\n        prov = copy_data = None\n        try:\n            prov = core.CGImageGetDataProvider(image_ref)\n            copy_data = core.CGDataProviderCopyData(prov)\n            data_ref = core.CFDataGetBytePtr(copy_data)\n            buf_len = core.CFDataGetLength(copy_data)\n            raw = ctypes.cast(data_ref, POINTER(c_ubyte * buf_len))\n            data = bytearray(raw.contents)\n\n            # Remove padding per row\n            bytes_per_row = core.CGImageGetBytesPerRow(image_ref)\n            bytes_per_pixel = core.CGImageGetBitsPerPixel(image_ref)\n            bytes_per_pixel = (bytes_per_pixel + 7) // 8\n\n            if bytes_per_pixel * width != bytes_per_row:\n                cropped = bytearray()\n                for row in range(height):\n                    start = row * bytes_per_row\n                    end = start + width * bytes_per_pixel\n                    cropped.extend(data[start:end])\n                data = cropped\n        finally:\n            if prov:\n                core.CGDataProviderRelease(prov)\n            if copy_data:\n                core.CFRelease(copy_data)\n\n        return self.cls_image(data, monitor, size=Size(width, height))\n"
            },
            "exception": {
                "type": "module",
                "code": "\"\"\"\nThis is part of the MSS Python's module.\nSource: https://github.com/BoboTiG/python-mss\n\"\"\"\n\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from typing import Any, Dict  # noqa\n\n\nclass ScreenShotError(Exception):\n    \"\"\" Error handling class. \"\"\"\n\n    def __init__(self, message, details=None):\n        # type: (str, Dict[str, Any]) -> None\n        super().__init__(message)\n        self.details = details or {}\n"
            },
            "factory": {
                "type": "module",
                "code": "\"\"\"\nThis is part of the MSS Python's module.\nSource: https://github.com/BoboTiG/python-mss\n\"\"\"\n\nimport platform\nfrom typing import TYPE_CHECKING\n\nfrom .exception import ScreenShotError\n\n\nif TYPE_CHECKING:\n    from typing import Any  # noqa\n\n    from .base import MSSBase  # noqa\n\n\ndef mss(**kwargs):\n    # type: (Any) -> MSSBase\n    \"\"\" Factory returning a proper MSS class instance.\n\n        It detects the plateform we are running on\n        and choose the most adapted mss_class to take\n        screenshots.\n\n        It then proxies its arguments to the class for\n        instantiation.\n    \"\"\"\n    # pylint: disable=import-outside-toplevel\n\n    os_ = platform.system().lower()\n\n    if os_ == \"darwin\":\n        from . import darwin\n\n        return darwin.MSS(**kwargs)\n\n    if os_ == \"linux\":\n        from . import linux\n\n        return linux.MSS(**kwargs)\n\n    if os_ == \"windows\":\n        from . import windows\n\n        return windows.MSS(**kwargs)\n\n    raise ScreenShotError(\"System {!r} not (yet?) implemented.\".format(os_))\n"
            },
            "linux": {
                "type": "module",
                "code": "\"\"\"\nThis is part of the MSS Python's module.\nSource: https://github.com/BoboTiG/python-mss\n\"\"\"\n\nimport ctypes\nimport ctypes.util\nimport os\nimport threading\nfrom ctypes import (\n    POINTER,\n    CFUNCTYPE,\n    Structure,\n    c_char_p,\n    c_int,\n    c_int32,\n    c_long,\n    c_ubyte,\n    c_uint,\n    c_uint32,\n    c_ulong,\n    c_ushort,\n    c_void_p,\n)\nfrom types import SimpleNamespace\nfrom typing import TYPE_CHECKING\n\nfrom .base import MSSBase, lock\nfrom .exception import ScreenShotError\n\nif TYPE_CHECKING:\n    from typing import Any, Dict, List, Optional, Tuple, Union  # noqa\n\n    from .models import Monitor, Monitors  # noqa\n    from .screenshot import ScreenShot  # noqa\n\n\n__all__ = (\"MSS\",)\n\n\nERROR = SimpleNamespace(details=None)\nPLAINMASK = 0x00FFFFFF\nZPIXMAP = 2\n\n\nclass Display(Structure):\n    \"\"\"\n    Structure that serves as the connection to the X server\n    and that contains all the information about that X server.\n    \"\"\"\n\n\nclass Event(Structure):\n    \"\"\"\n    XErrorEvent to debug eventual errors.\n    https://tronche.com/gui/x/xlib/event-handling/protocol-errors/default-handlers.html\n    \"\"\"\n\n    _fields_ = [\n        (\"type\", c_int),\n        (\"display\", POINTER(Display)),\n        (\"serial\", c_ulong),\n        (\"error_code\", c_ubyte),\n        (\"request_code\", c_ubyte),\n        (\"minor_code\", c_ubyte),\n        (\"resourceid\", c_void_p),\n    ]\n\n\nclass XWindowAttributes(Structure):\n    \"\"\" Attributes for the specified window. \"\"\"\n\n    _fields_ = [\n        (\"x\", c_int32),\n        (\"y\", c_int32),\n        (\"width\", c_int32),\n        (\"height\", c_int32),\n        (\"border_width\", c_int32),\n        (\"depth\", c_int32),\n        (\"visual\", c_ulong),\n        (\"root\", c_ulong),\n        (\"class\", c_int32),\n        (\"bit_gravity\", c_int32),\n        (\"win_gravity\", c_int32),\n        (\"backing_store\", c_int32),\n        (\"backing_planes\", c_ulong),\n        (\"backing_pixel\", c_ulong),\n        (\"save_under\", c_int32),\n        (\"colourmap\", c_ulong),\n        (\"mapinstalled\", c_uint32),\n        (\"map_state\", c_uint32),\n        (\"all_event_masks\", c_ulong),\n        (\"your_event_mask\", c_ulong),\n        (\"do_not_propagate_mask\", c_ulong),\n        (\"override_redirect\", c_int32),\n        (\"screen\", c_ulong),\n    ]\n\n\nclass XImage(Structure):\n    \"\"\"\n    Description of an image as it exists in the client's memory.\n    https://tronche.com/gui/x/xlib/graphics/images.html\n    \"\"\"\n\n    _fields_ = [\n        (\"width\", c_int),\n        (\"height\", c_int),\n        (\"xoffset\", c_int),\n        (\"format\", c_int),\n        (\"data\", c_void_p),\n        (\"byte_order\", c_int),\n        (\"bitmap_unit\", c_int),\n        (\"bitmap_bit_order\", c_int),\n        (\"bitmap_pad\", c_int),\n        (\"depth\", c_int),\n        (\"bytes_per_line\", c_int),\n        (\"bits_per_pixel\", c_int),\n        (\"red_mask\", c_ulong),\n        (\"green_mask\", c_ulong),\n        (\"blue_mask\", c_ulong),\n    ]\n\n\nclass XRRModeInfo(Structure):\n    \"\"\" Voil\u00e0, voil\u00e0. \"\"\"\n\n\nclass XRRScreenResources(Structure):\n    \"\"\"\n    Structure that contains arrays of XIDs that point to the\n    available outputs and associated CRTCs.\n    \"\"\"\n\n    _fields_ = [\n        (\"timestamp\", c_ulong),\n        (\"configTimestamp\", c_ulong),\n        (\"ncrtc\", c_int),\n        (\"crtcs\", POINTER(c_long)),\n        (\"noutput\", c_int),\n        (\"outputs\", POINTER(c_long)),\n        (\"nmode\", c_int),\n        (\"modes\", POINTER(XRRModeInfo)),\n    ]\n\n\nclass XRRCrtcInfo(Structure):\n    \"\"\" Structure that contains CRTC information. \"\"\"\n\n    _fields_ = [\n        (\"timestamp\", c_ulong),\n        (\"x\", c_int),\n        (\"y\", c_int),\n        (\"width\", c_int),\n        (\"height\", c_int),\n        (\"mode\", c_long),\n        (\"rotation\", c_int),\n        (\"noutput\", c_int),\n        (\"outputs\", POINTER(c_long)),\n        (\"rotations\", c_ushort),\n        (\"npossible\", c_int),\n        (\"possible\", POINTER(c_long)),\n    ]\n\n\n@CFUNCTYPE(c_int, POINTER(Display), POINTER(Event))\ndef error_handler(_, event):\n    # type: (Any, Any) -> int\n    \"\"\" Specifies the program's supplied error handler. \"\"\"\n\n    evt = event.contents\n    ERROR.details = {\n        \"type\": evt.type,\n        \"serial\": evt.serial,\n        \"error_code\": evt.error_code,\n        \"request_code\": evt.request_code,\n        \"minor_code\": evt.minor_code,\n    }\n    return 0\n\n\ndef validate(retval, func, args):\n    # type: (int, Any, Tuple[Any, Any]) -> Optional[Tuple[Any, Any]]\n    \"\"\" Validate the returned value of a Xlib or XRANDR function. \"\"\"\n\n    if retval != 0 and not ERROR.details:\n        return args\n\n    err = \"{}() failed\".format(func.__name__)\n    details = {\"retval\": retval, \"args\": args}\n    raise ScreenShotError(err, details=details)\n\n\n# C functions that will be initialised later.\n# See https://tronche.com/gui/x/xlib/function-index.html for details.\n#\n# This is a dict:\n#    cfunction: (attr, argtypes, restype)\n#\n# Available attr: xlib, xrandr.\n#\n# Note: keep it sorted by cfunction.\nCFUNCTIONS = {\n    \"XDefaultRootWindow\": (\"xlib\", [POINTER(Display)], POINTER(XWindowAttributes)),\n    \"XDestroyImage\": (\"xlib\", [POINTER(XImage)], c_void_p),\n    \"XGetErrorText\": (\"xlib\", [POINTER(Display), c_int, c_char_p, c_int], c_void_p),\n    \"XGetImage\": (\n        \"xlib\",\n        [\n            POINTER(Display),\n            POINTER(Display),\n            c_int,\n            c_int,\n            c_uint,\n            c_uint,\n            c_ulong,\n            c_int,\n        ],\n        POINTER(XImage),\n    ),\n    \"XGetWindowAttributes\": (\n        \"xlib\",\n        [POINTER(Display), POINTER(XWindowAttributes), POINTER(XWindowAttributes)],\n        c_int,\n    ),\n    \"XOpenDisplay\": (\"xlib\", [c_char_p], POINTER(Display)),\n    \"XQueryExtension\": (\n        \"xlib\",\n        [\n            POINTER(Display),\n            c_char_p,\n            POINTER(c_int),\n            POINTER(c_int),\n            POINTER(c_int),\n        ],\n        c_uint,\n    ),\n    \"XRRFreeCrtcInfo\": (\"xrandr\", [POINTER(XRRCrtcInfo)], c_void_p),\n    \"XRRFreeScreenResources\": (\"xrandr\", [POINTER(XRRScreenResources)], c_void_p),\n    \"XRRGetCrtcInfo\": (\n        \"xrandr\",\n        [POINTER(Display), POINTER(XRRScreenResources), c_long],\n        POINTER(XRRCrtcInfo),\n    ),\n    \"XRRGetScreenResources\": (\n        \"xrandr\",\n        [POINTER(Display), POINTER(Display)],\n        POINTER(XRRScreenResources),\n    ),\n    \"XRRGetScreenResourcesCurrent\": (\n        \"xrandr\",\n        [POINTER(Display), POINTER(Display)],\n        POINTER(XRRScreenResources),\n    ),\n    \"XSetErrorHandler\": (\"xlib\", [c_void_p], c_int),\n}\n\n\nclass MSS(MSSBase):\n    \"\"\"\n    Multiple ScreenShots implementation for GNU/Linux.\n    It uses intensively the Xlib and its Xrandr extension.\n    \"\"\"\n\n    __slots__ = {\"drawable\", \"root\", \"xlib\", \"xrandr\"}\n\n    # A dict to maintain *display* values created by multiple threads.\n    _display_dict = {}  # type: Dict[threading.Thread, int]\n\n    def __init__(self, display=None):\n        # type: (Optional[Union[bytes, str]]) -> None\n        \"\"\" GNU/Linux initialisations. \"\"\"\n\n        super().__init__()\n\n        if not display:\n            try:\n                display = os.environ[\"DISPLAY\"].encode(\"utf-8\")\n            except KeyError:\n                # pylint: disable=raise-missing-from\n                raise ScreenShotError(\"$DISPLAY not set.\")\n\n        if not isinstance(display, bytes):\n            display = display.encode(\"utf-8\")\n\n        if b\":\" not in display:\n            raise ScreenShotError(\"Bad display value: {!r}.\".format(display))\n\n        x11 = ctypes.util.find_library(\"X11\")\n        if not x11:\n            raise ScreenShotError(\"No X11 library found.\")\n        self.xlib = ctypes.cdll.LoadLibrary(x11)\n\n        # Install the error handler to prevent interpreter crashes:\n        # any error will raise a ScreenShotError exception.\n        self.xlib.XSetErrorHandler(error_handler)\n\n        xrandr = ctypes.util.find_library(\"Xrandr\")\n        if not xrandr:\n            raise ScreenShotError(\"No Xrandr extension found.\")\n        self.xrandr = ctypes.cdll.LoadLibrary(xrandr)\n\n        self._set_cfunctions()\n\n        self.root = self.xlib.XDefaultRootWindow(self._get_display(display))\n\n        if not self.has_extension(\"RANDR\"):\n            raise ScreenShotError(\"No Xrandr extension found.\")\n\n        # Fix for XRRGetScreenResources and XGetImage:\n        #     expected LP_Display instance instead of LP_XWindowAttributes\n        self.drawable = ctypes.cast(self.root, POINTER(Display))\n\n    def has_extension(self, extension):\n        # type: (str) -> bool\n        \"\"\"Return True if the given *extension* is part of the extensions list of the server.\"\"\"\n        with lock:\n            major_opcode_return = c_int()\n            first_event_return = c_int()\n            first_error_return = c_int()\n\n            try:\n                self.xlib.XQueryExtension(\n                    self._get_display(),\n                    extension.encode(\"latin1\"),\n                    ctypes.byref(major_opcode_return),\n                    ctypes.byref(first_event_return),\n                    ctypes.byref(first_error_return),\n                )\n            except ScreenShotError:\n                return False\n            else:\n                return True\n\n    def _get_display(self, disp=None):\n        \"\"\"\n        Retrieve a thread-safe display from XOpenDisplay().\n        In multithreading, if the thread who creates *display* is dead, *display* will\n        no longer be valid to grab the screen. The *display* attribute is replaced\n        with *_display_dict* to maintain the *display* values in multithreading.\n        Since the current thread and main thread are always alive, reuse their\n        *display* value first.\n        \"\"\"\n        cur_thread, main_thread = threading.current_thread(), threading.main_thread()\n        display = MSS._display_dict.get(cur_thread) or MSS._display_dict.get(\n            main_thread\n        )\n        if not display:\n            display = MSS._display_dict[cur_thread] = self.xlib.XOpenDisplay(disp)\n        return display\n\n    def _set_cfunctions(self):\n        \"\"\" Set all ctypes functions and attach them to attributes. \"\"\"\n\n        cfactory = self._cfactory\n        attrs = {\n            \"xlib\": self.xlib,\n            \"xrandr\": self.xrandr,\n        }\n        for func, (attr, argtypes, restype) in CFUNCTIONS.items():\n            try:\n                cfactory(\n                    attr=attrs[attr],\n                    errcheck=validate,\n                    func=func,\n                    argtypes=argtypes,\n                    restype=restype,\n                )  # type: ignore\n            except AttributeError:\n                pass\n\n    def get_error_details(self):\n        # type: () -> Optional[Dict[str, Any]]\n        \"\"\" Get more information about the latest X server error. \"\"\"\n\n        details = {}  # type: Dict[str, Any]\n\n        if ERROR.details:\n            details = {\"xerror_details\": ERROR.details}\n            ERROR.details = None\n            xserver_error = ctypes.create_string_buffer(1024)\n            self.xlib.XGetErrorText(\n                self._get_display(),\n                details.get(\"xerror_details\", {}).get(\"error_code\", 0),\n                xserver_error,\n                len(xserver_error),\n            )\n            xerror = xserver_error.value.decode(\"utf-8\")\n            if xerror != \"0\":\n                details[\"xerror\"] = xerror\n\n        return details\n\n    def _monitors_impl(self):\n        # type: () -> None\n        \"\"\" Get positions of monitors. It will populate self._monitors. \"\"\"\n\n        display = self._get_display()\n        int_ = int\n        xrandr = self.xrandr\n\n        # All monitors\n        gwa = XWindowAttributes()\n        self.xlib.XGetWindowAttributes(display, self.root, ctypes.byref(gwa))\n        self._monitors.append(\n            {\n                \"left\": int_(gwa.x),\n                \"top\": int_(gwa.y),\n                \"width\": int_(gwa.width),\n                \"height\": int_(gwa.height),\n            }\n        )\n\n        # Each monitors\n        # A simple benchmark calling 10 times those 2 functions:\n        # XRRGetScreenResources():        0.1755971429956844 s\n        # XRRGetScreenResourcesCurrent(): 0.0039125580078689 s\n        # The second is faster by a factor of 44! So try to use it first.\n        try:\n            mon = xrandr.XRRGetScreenResourcesCurrent(display, self.drawable).contents\n        except AttributeError:\n            mon = xrandr.XRRGetScreenResources(display, self.drawable).contents\n\n        crtcs = mon.crtcs\n        for idx in range(mon.ncrtc):\n            crtc = xrandr.XRRGetCrtcInfo(display, mon, crtcs[idx]).contents\n            if crtc.noutput == 0:\n                xrandr.XRRFreeCrtcInfo(crtc)\n                continue\n\n            self._monitors.append(\n                {\n                    \"left\": int_(crtc.x),\n                    \"top\": int_(crtc.y),\n                    \"width\": int_(crtc.width),\n                    \"height\": int_(crtc.height),\n                }\n            )\n            xrandr.XRRFreeCrtcInfo(crtc)\n        xrandr.XRRFreeScreenResources(mon)\n\n    def _grab_impl(self, monitor):\n        # type: (Monitor) -> ScreenShot\n        \"\"\" Retrieve all pixels from a monitor. Pixels have to be RGB. \"\"\"\n\n        ximage = self.xlib.XGetImage(\n            self._get_display(),\n            self.drawable,\n            monitor[\"left\"],\n            monitor[\"top\"],\n            monitor[\"width\"],\n            monitor[\"height\"],\n            PLAINMASK,\n            ZPIXMAP,\n        )\n\n        try:\n            bits_per_pixel = ximage.contents.bits_per_pixel\n            if bits_per_pixel != 32:\n                raise ScreenShotError(\n                    \"[XImage] bits per pixel value not (yet?) implemented: {}.\".format(\n                        bits_per_pixel\n                    )\n                )\n\n            raw_data = ctypes.cast(\n                ximage.contents.data,\n                POINTER(c_ubyte * monitor[\"height\"] * monitor[\"width\"] * 4),\n            )\n            data = bytearray(raw_data.contents)\n        finally:\n            # Free\n            self.xlib.XDestroyImage(ximage)\n\n        return self.cls_image(data, monitor)\n"
            },
            "models": {
                "type": "module",
                "code": "\"\"\"\nThis is part of the MSS Python's module.\nSource: https://github.com/BoboTiG/python-mss\n\"\"\"\n\nimport collections\nfrom typing import Dict, List, Tuple\n\n\nMonitor = Dict[str, int]\nMonitors = List[Monitor]\n\nPixel = Tuple[int, int, int]\nPixels = List[Pixel]\n\nPos = collections.namedtuple(\"Pos\", \"left, top\")\nSize = collections.namedtuple(\"Size\", \"width, height\")\n"
            },
            "screenshot": {
                "type": "module",
                "code": "\"\"\"\nThis is part of the MSS Python's module.\nSource: https://github.com/BoboTiG/python-mss\n\"\"\"\n\nfrom typing import TYPE_CHECKING\n\nfrom .models import Size, Pos\nfrom .exception import ScreenShotError\n\nif TYPE_CHECKING:\n    from typing import Any, Dict, Iterator, Optional  # noqa\n\n    from .models import Monitor, Pixel, Pixels  # noqa\n\n\nclass ScreenShot:\n    \"\"\"\n    Screen shot object.\n\n    .. note::\n\n        A better name would have  been *Image*, but to prevent collisions\n        with PIL.Image, it has been decided to use *ScreenShot*.\n    \"\"\"\n\n    __slots__ = {\"__pixels\", \"__rgb\", \"pos\", \"raw\", \"size\"}\n\n    def __init__(self, data, monitor, size=None):\n        # type: (bytearray, Monitor, Optional[Size]) -> None\n\n        self.__pixels = None  # type: Optional[Pixels]\n        self.__rgb = None  # type: Optional[bytes]\n\n        #: Bytearray of the raw BGRA pixels retrieved by ctypes\n        #: OS independent implementations.\n        self.raw = data\n\n        #: NamedTuple of the screen shot coordinates.\n        self.pos = Pos(monitor[\"left\"], monitor[\"top\"])\n\n        if size is not None:\n            #: NamedTuple of the screen shot size.\n            self.size = size\n        else:\n            self.size = Size(monitor[\"width\"], monitor[\"height\"])\n\n    def __repr__(self):\n        return (\"<{!s} pos={cls.left},{cls.top} size={cls.width}x{cls.height}>\").format(\n            type(self).__name__, cls=self\n        )\n\n    @property\n    def __array_interface__(self):\n        # type: () -> Dict[str, Any]\n        \"\"\"\n        Numpy array interface support.\n        It uses raw data in BGRA form.\n\n        See https://docs.scipy.org/doc/numpy/reference/arrays.interface.html\n        \"\"\"\n\n        return {\n            \"version\": 3,\n            \"shape\": (self.height, self.width, 4),\n            \"typestr\": \"|u1\",\n            \"data\": self.raw,\n        }\n\n    @classmethod\n    def from_size(cls, data, width, height):\n        # type: (bytearray, int, int) -> ScreenShot\n        \"\"\" Instantiate a new class given only screen shot's data and size. \"\"\"\n\n        monitor = {\"left\": 0, \"top\": 0, \"width\": width, \"height\": height}\n        return cls(data, monitor)\n\n    @property\n    def bgra(self):\n        # type: () -> bytes\n        \"\"\" BGRA values from the BGRA raw pixels. \"\"\"\n        return bytes(self.raw)\n\n    @property\n    def height(self):\n        # type: () -> int\n        \"\"\" Convenient accessor to the height size. \"\"\"\n        return self.size.height\n\n    @property\n    def left(self):\n        # type: () -> int\n        \"\"\" Convenient accessor to the left position. \"\"\"\n        return self.pos.left\n\n    @property\n    def pixels(self):\n        # type: () -> Pixels\n        \"\"\"\n        :return list: RGB tuples.\n        \"\"\"\n\n        if not self.__pixels:\n            rgb_tuples = zip(\n                self.raw[2::4], self.raw[1::4], self.raw[0::4]\n            )  # type: Iterator[Pixel]\n            self.__pixels = list(zip(*[iter(rgb_tuples)] * self.width))  # type: ignore\n\n        return self.__pixels\n\n    @property\n    def rgb(self):\n        # type: () -> bytes\n        \"\"\"\n        Compute RGB values from the BGRA raw pixels.\n\n        :return bytes: RGB pixels.\n        \"\"\"\n\n        if not self.__rgb:\n            rgb = bytearray(self.height * self.width * 3)\n            raw = self.raw\n            rgb[0::3] = raw[2::4]\n            rgb[1::3] = raw[1::4]\n            rgb[2::3] = raw[0::4]\n            self.__rgb = bytes(rgb)\n\n        return self.__rgb\n\n    @property\n    def top(self):\n        # type: () -> int\n        \"\"\" Convenient accessor to the top position. \"\"\"\n        return self.pos.top\n\n    @property\n    def width(self):\n        # type: () -> int\n        \"\"\" Convenient accessor to the width size. \"\"\"\n        return self.size.width\n\n    def pixel(self, coord_x, coord_y):\n        # type: (int, int) -> Pixel\n        \"\"\"\n        Returns the pixel value at a given position.\n\n        :param int coord_x: The x coordinate.\n        :param int coord_y: The y coordinate.\n        :return tuple: The pixel value as (R, G, B).\n        \"\"\"\n\n        try:\n            return self.pixels[coord_y][coord_x]  # type: ignore\n        except IndexError:\n            # pylint: disable=raise-missing-from\n            raise ScreenShotError(\n                \"Pixel location ({}, {}) is out of range.\".format(coord_x, coord_y)\n            )\n"
            },
            "tools": {
                "type": "module",
                "code": "\"\"\"\nThis is part of the MSS Python's module.\nSource: https://github.com/BoboTiG/python-mss\n\"\"\"\n\nimport os\nimport struct\nimport zlib\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from typing import Optional, Tuple  # noqa\n\n\ndef to_png(data, size, level=6, output=None):\n    # type: (bytes, Tuple[int, int], int, Optional[str]) -> Optional[bytes]\n    \"\"\"\n    Dump data to a PNG file.  If `output` is `None`, create no file but return\n    the whole PNG data.\n\n    :param bytes data: RGBRGB...RGB data.\n    :param tuple size: The (width, height) pair.\n    :param int level: PNG compression level.\n    :param str output: Output file name.\n    \"\"\"\n    # pylint: disable=too-many-locals\n\n    pack = struct.pack\n    crc32 = zlib.crc32\n\n    width, height = size\n    line = width * 3\n    png_filter = pack(\">B\", 0)\n    scanlines = b\"\".join(\n        [png_filter + data[y * line : y * line + line] for y in range(height)]\n    )\n\n    magic = pack(\">8B\", 137, 80, 78, 71, 13, 10, 26, 10)\n\n    # Header: size, marker, data, CRC32\n    ihdr = [b\"\", b\"IHDR\", b\"\", b\"\"]\n    ihdr[2] = pack(\">2I5B\", width, height, 8, 2, 0, 0, 0)\n    ihdr[3] = pack(\">I\", crc32(b\"\".join(ihdr[1:3])) & 0xFFFFFFFF)\n    ihdr[0] = pack(\">I\", len(ihdr[2]))\n\n    # Data: size, marker, data, CRC32\n    idat = [b\"\", b\"IDAT\", zlib.compress(scanlines, level), b\"\"]\n    idat[3] = pack(\">I\", crc32(b\"\".join(idat[1:3])) & 0xFFFFFFFF)\n    idat[0] = pack(\">I\", len(idat[2]))\n\n    # Footer: size, marker, None, CRC32\n    iend = [b\"\", b\"IEND\", b\"\", b\"\"]\n    iend[3] = pack(\">I\", crc32(iend[1]) & 0xFFFFFFFF)\n    iend[0] = pack(\">I\", len(iend[2]))\n\n    if not output:\n        # Returns raw bytes of the whole PNG data\n        return magic + b\"\".join(ihdr + idat + iend)\n\n    with open(output, \"wb\") as fileh:\n        fileh.write(magic)\n        fileh.write(b\"\".join(ihdr))\n        fileh.write(b\"\".join(idat))\n        fileh.write(b\"\".join(iend))\n\n        # Force write of file to disk\n        fileh.flush()\n        os.fsync(fileh.fileno())\n\n    return None\n"
            },
            "windows": {
                "type": "module",
                "code": "\"\"\"\nThis is part of the MSS Python's module.\nSource: https://github.com/BoboTiG/python-mss\n\"\"\"\n\nimport sys\nimport ctypes\nimport threading\nfrom ctypes import POINTER, Structure, WINFUNCTYPE, c_void_p\nfrom ctypes.wintypes import (\n    BOOL,\n    DOUBLE,\n    DWORD,\n    HBITMAP,\n    HDC,\n    HGDIOBJ,\n    HWND,\n    INT,\n    LONG,\n    LPARAM,\n    RECT,\n    UINT,\n    WORD,\n)\nfrom typing import TYPE_CHECKING\n\nfrom .base import MSSBase\nfrom .exception import ScreenShotError\n\nif TYPE_CHECKING:\n    from typing import Any, Dict  # noqa\n\n    from .models import Monitor, Monitors  # noqa\n    from .screenshot import ScreenShot  # noqa\n\n__all__ = (\"MSS\",)\n\n\nCAPTUREBLT = 0x40000000\nDIB_RGB_COLORS = 0\nSRCCOPY = 0x00CC0020\n\n\nclass BITMAPINFOHEADER(Structure):\n    \"\"\" Information about the dimensions and color format of a DIB. \"\"\"\n\n    _fields_ = [\n        (\"biSize\", DWORD),\n        (\"biWidth\", LONG),\n        (\"biHeight\", LONG),\n        (\"biPlanes\", WORD),\n        (\"biBitCount\", WORD),\n        (\"biCompression\", DWORD),\n        (\"biSizeImage\", DWORD),\n        (\"biXPelsPerMeter\", LONG),\n        (\"biYPelsPerMeter\", LONG),\n        (\"biClrUsed\", DWORD),\n        (\"biClrImportant\", DWORD),\n    ]\n\n\nclass BITMAPINFO(Structure):\n    \"\"\"\n    Structure that defines the dimensions and color information for a DIB.\n    \"\"\"\n\n    _fields_ = [(\"bmiHeader\", BITMAPINFOHEADER), (\"bmiColors\", DWORD * 3)]\n\n\nMONITORNUMPROC = WINFUNCTYPE(INT, DWORD, DWORD, POINTER(RECT), DOUBLE)\n\n\n# C functions that will be initialised later.\n#\n# This is a dict:\n#    cfunction: (attr, argtypes, restype)\n#\n# Available attr: gdi32, user32.\n#\n# Note: keep it sorted by cfunction.\nCFUNCTIONS = {\n    \"BitBlt\": (\"gdi32\", [HDC, INT, INT, INT, INT, HDC, INT, INT, DWORD], BOOL),\n    \"CreateCompatibleBitmap\": (\"gdi32\", [HDC, INT, INT], HBITMAP),\n    \"CreateCompatibleDC\": (\"gdi32\", [HDC], HDC),\n    \"DeleteObject\": (\"gdi32\", [HGDIOBJ], INT),\n    \"EnumDisplayMonitors\": (\"user32\", [HDC, c_void_p, MONITORNUMPROC, LPARAM], BOOL),\n    \"GetDeviceCaps\": (\"gdi32\", [HWND, INT], INT),\n    \"GetDIBits\": (\n        \"gdi32\",\n        [HDC, HBITMAP, UINT, UINT, c_void_p, POINTER(BITMAPINFO), UINT],\n        BOOL,\n    ),\n    \"GetSystemMetrics\": (\"user32\", [INT], INT),\n    \"GetWindowDC\": (\"user32\", [HWND], HDC),\n    \"SelectObject\": (\"gdi32\", [HDC, HGDIOBJ], HGDIOBJ),\n}\n\n\nclass MSS(MSSBase):\n    \"\"\" Multiple ScreenShots implementation for Microsoft Windows. \"\"\"\n\n    __slots__ = {\"_bbox\", \"_bmi\", \"_data\", \"gdi32\", \"user32\"}\n\n    # Class attributes instanced one time to prevent resource leaks.\n    bmp = None\n    memdc = None\n\n    # A dict to maintain *srcdc* values created by multiple threads.\n    _srcdc_dict = {}  # type: Dict[threading.Thread, int]\n\n    def __init__(self, **_):\n        # type: (Any) -> None\n        \"\"\" Windows initialisations. \"\"\"\n\n        super().__init__()\n\n        self.user32 = ctypes.WinDLL(\"user32\")\n        self.gdi32 = ctypes.WinDLL(\"gdi32\")\n        self._set_cfunctions()\n        self._set_dpi_awareness()\n\n        self._bbox = {\"height\": 0, \"width\": 0}\n        self._data = ctypes.create_string_buffer(0)  # type: ctypes.Array[ctypes.c_char]\n\n        srcdc = self._get_srcdc()\n        if not MSS.memdc:\n            MSS.memdc = self.gdi32.CreateCompatibleDC(srcdc)\n\n        bmi = BITMAPINFO()\n        bmi.bmiHeader.biSize = ctypes.sizeof(BITMAPINFOHEADER)\n        bmi.bmiHeader.biPlanes = 1  # Always 1\n        bmi.bmiHeader.biBitCount = 32  # See grab.__doc__ [2]\n        bmi.bmiHeader.biCompression = 0  # 0 = BI_RGB (no compression)\n        bmi.bmiHeader.biClrUsed = 0  # See grab.__doc__ [3]\n        bmi.bmiHeader.biClrImportant = 0  # See grab.__doc__ [3]\n        self._bmi = bmi\n\n    def _set_cfunctions(self):\n        \"\"\" Set all ctypes functions and attach them to attributes. \"\"\"\n\n        cfactory = self._cfactory\n        attrs = {\n            \"gdi32\": self.gdi32,\n            \"user32\": self.user32,\n        }\n        for func, (attr, argtypes, restype) in CFUNCTIONS.items():\n            cfactory(\n                attr=attrs[attr],\n                func=func,\n                argtypes=argtypes,\n                restype=restype,\n            )  # type: ignore\n\n    def _set_dpi_awareness(self):\n        \"\"\" Set DPI aware to capture full screen on Hi-DPI monitors. \"\"\"\n\n        version = sys.getwindowsversion()[:2]  # pylint: disable=no-member\n        if version >= (6, 3):\n            # Windows 8.1+\n            # Here 2 = PROCESS_PER_MONITOR_DPI_AWARE, which means:\n            #     per monitor DPI aware. This app checks for the DPI when it is\n            #     created and adjusts the scale factor whenever the DPI changes.\n            #     These applications are not automatically scaled by the system.\n            ctypes.windll.shcore.SetProcessDpiAwareness(2)\n        elif (6, 0) <= version < (6, 3):\n            # Windows Vista, 7, 8 and Server 2012\n            self.user32.SetProcessDPIAware()\n\n    def _get_srcdc(self):\n        \"\"\"\n        Retrieve a thread-safe HDC from GetWindowDC().\n        In multithreading, if the thread who creates *srcdc* is dead, *srcdc* will\n        no longer be valid to grab the screen. The *srcdc* attribute is replaced\n        with *_srcdc_dict* to maintain the *srcdc* values in multithreading.\n        Since the current thread and main thread are always alive, reuse their *srcdc* value first.\n        \"\"\"\n        cur_thread, main_thread = threading.current_thread(), threading.main_thread()\n        srcdc = MSS._srcdc_dict.get(cur_thread) or MSS._srcdc_dict.get(main_thread)\n        if not srcdc:\n            srcdc = MSS._srcdc_dict[cur_thread] = self.user32.GetWindowDC(0)\n        return srcdc\n\n    def _monitors_impl(self):\n        # type: () -> None\n        \"\"\" Get positions of monitors. It will populate self._monitors. \"\"\"\n\n        int_ = int\n        user32 = self.user32\n        get_system_metrics = user32.GetSystemMetrics\n\n        # All monitors\n        self._monitors.append(\n            {\n                \"left\": int_(get_system_metrics(76)),  # SM_XVIRTUALSCREEN\n                \"top\": int_(get_system_metrics(77)),  # SM_YVIRTUALSCREEN\n                \"width\": int_(get_system_metrics(78)),  # SM_CXVIRTUALSCREEN\n                \"height\": int_(get_system_metrics(79)),  # SM_CYVIRTUALSCREEN\n            }\n        )\n\n        # Each monitors\n        def _callback(monitor, data, rect, dc_):\n            # types: (int, HDC, LPRECT, LPARAM) -> int\n            \"\"\"\n            Callback for monitorenumproc() function, it will return\n            a RECT with appropriate values.\n            \"\"\"\n            # pylint: disable=unused-argument\n\n            rct = rect.contents\n            self._monitors.append(\n                {\n                    \"left\": int_(rct.left),\n                    \"top\": int_(rct.top),\n                    \"width\": int_(rct.right - rct.left),\n                    \"height\": int_(rct.bottom - rct.top),\n                }\n            )\n            return 1\n\n        callback = MONITORNUMPROC(_callback)\n        user32.EnumDisplayMonitors(0, 0, callback, 0)\n\n    def _grab_impl(self, monitor):\n        # type: (Monitor) -> ScreenShot\n        \"\"\"\n        Retrieve all pixels from a monitor. Pixels have to be RGB.\n\n        In the code, there are few interesting things:\n\n        [1] bmi.bmiHeader.biHeight = -height\n\n        A bottom-up DIB is specified by setting the height to a\n        positive number, while a top-down DIB is specified by\n        setting the height to a negative number.\n        https://msdn.microsoft.com/en-us/library/ms787796.aspx\n        https://msdn.microsoft.com/en-us/library/dd144879%28v=vs.85%29.aspx\n\n\n        [2] bmi.bmiHeader.biBitCount = 32\n            image_data = create_string_buffer(height * width * 4)\n\n        We grab the image in RGBX mode, so that each word is 32bit\n        and we have no striding.\n        Inspired by https://github.com/zoofIO/flexx\n\n\n        [3] bmi.bmiHeader.biClrUsed = 0\n            bmi.bmiHeader.biClrImportant = 0\n\n        When biClrUsed and biClrImportant are set to zero, there\n        is \"no\" color table, so we can read the pixels of the bitmap\n        retrieved by gdi32.GetDIBits() as a sequence of RGB values.\n        Thanks to http://stackoverflow.com/a/3688682\n        \"\"\"\n\n        srcdc, memdc = self._get_srcdc(), MSS.memdc\n        width, height = monitor[\"width\"], monitor[\"height\"]\n\n        if (self._bbox[\"height\"], self._bbox[\"width\"]) != (height, width):\n            self._bbox = monitor\n            self._bmi.bmiHeader.biWidth = width\n            self._bmi.bmiHeader.biHeight = -height  # Why minus? [1]\n            self._data = ctypes.create_string_buffer(width * height * 4)  # [2]\n            if MSS.bmp:\n                self.gdi32.DeleteObject(MSS.bmp)\n            MSS.bmp = self.gdi32.CreateCompatibleBitmap(srcdc, width, height)\n            self.gdi32.SelectObject(memdc, MSS.bmp)\n\n        self.gdi32.BitBlt(\n            memdc,\n            0,\n            0,\n            width,\n            height,\n            srcdc,\n            monitor[\"left\"],\n            monitor[\"top\"],\n            SRCCOPY | CAPTUREBLT,\n        )\n        bits = self.gdi32.GetDIBits(\n            memdc, MSS.bmp, 0, height, self._data, self._bmi, DIB_RGB_COLORS\n        )\n        if bits != height:\n            raise ScreenShotError(\"gdi32.GetDIBits() failed.\")\n\n        return self.cls_image(bytearray(self._data), monitor)\n"
            }
        }
    }
}